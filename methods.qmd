## Overview of methods {#sec-methods_overview}

There are several statistical tasks involved in analyzing single-cell CRISPR screen data, including assigning gRNAs to cells, testing for association between gRNAs and the expression of responses (such as genes), and integrating information across gRNAs that target the same site (and that potentially exhibit variable effectiveness). This chapter provides an overview of the statistical methods that `sceptre` employs to carry out these analysis tasks. The methods described in this and subsequent chapters were introduced and validated on real data in @barry2021, @barry2022c, and @barry2023.

## Notation

We begin by introducing some notation that we use throughout the chapter. Let $\mathbb{N} = \{1, 2, \dots\}$ denote the set of positive integers. For a given single-cell CRISPR screen dataset, let $d\in\mathbb{N}$ denote the number of responses, $r\in\mathbb{N}$ the number of gRNAs, and $n\in\mathbb{N}$ the number of cells in the dataset. Next, let $Y\in \mathbb{N}^{d \times n}$ be the matrix of response UMI counts, where responses are in the rows and cells in the columns. A given entry $y_{ij}$ of $Y$ indicates the number of UMIs from response $i$ sequenced in cell $j$. Similarly, let $G \in \mathbb{N}^{r \times n}$ be the matrix of gRNA UMI counts; a given entry $g_{ij}$ of $G$ indicates the number of UMIs from gRNA $i$ sequenced in cell $j$. Finally, let $Z \in \mathbb{N}^{n\times p}$ be the matrix of cell-specific covariates, which can include variables such as `response_n_umis`, `response_n_nonzero`, `grna_n_umis`, `grna_n_nonzero`, `response_p_mito`, `batch`, and cell type.

## Assigning gRNAs to cells {#sec-methods_assign_grnas}

The first statistical task involved in single-cell CRISPR screen analysis is to assign gRNAs to cells. The gRNA assignment task involves leveraging the gRNA count matrix $G$ (and possibly the covariate matrix $Z$) to impute the (unobserved) binary matrix $X \in \{0,1\}^{r \times n}$ of gRNA presences and absences, where a given entry $x_{ij}$ of $X$ is defined to be $1$ (resp., $0$) if gRNA $i$ is present (resp., absent) in cell $j$. `sceptre` implements three gRNA assignment strategies: the thresholding method, maximum method, and the mixture method. All three methods account for background contamination, the phenomenon by which gRNA reads sometimes map to cells that do not contain the corresponding gRNA. (See @sec-sceptre_assign_grnas of the introductory chapter for a real-data example of background contamination.) We describe each method in greater depth here.

### Thresholding and maximum methods

The thresholding method assigns a gRNA to a cell if the UMI count of the gRNA in the cell exceeds some integer threshold $c \in \mathbb{N}$. Formally, the thresholding method sets $x_{ij}$ to $1$ if $g_{ij} \geq c$ and to $0$ if $g_{ij} < c$. The default value for $c$ is 5 (as proposed in @gasperini2019 and further validated by @barry2022c). An important special case is to set $c$ to $1$, which corresponds to the "naive" (but occasionally useful) strategy of assigning any gRNA expressed in a given cell to that cell (and ignoring background contamination). The thresholding method is available in both low- and high-MOI settings in `sceptre`.

The maximum method assigns the gRNA exhibiting the greatest UMI count in a given cell to that cell. Formally, consider a given cell $j$; the UMI count of gRNA $i$ in cell $j$ is $g_{ij}$. Let $i^* \in \{1, \dots, r\}$ be the index such that $$ g_{i^*j} = \max_{i \in \{1, \dots, r\}}{g_{ij}}.$$ (If multiple indices satisfy this criterion, select $i^*$ among these arbitrarily.) We assign gRNA $i^*$ to cell $j$, i.e. we set $x_{i^*j}$ to $1$ and $x_{ij}$ to $0$ for $i \neq i^*$. In carrying out the maximum assignment step, `sceptre` also flags cells that likely contain multiple gRNAs. Let $u \in [0,1]$ be a user-specified threshold (default value $0.8$). Suppose that the gRNA assigned to cell $j$ constitutes fewer than $u$ of the UMIs in that cell. In other words, suppose that

$$
 \frac{g_{i^*j}}{\sum_{i=1}^{r} g_{ij}} < u.
$$

Then cell $j$ is flagged as containing multiple gRNAs and is removed as part of the QC step. (Note that if multiple gRNAs are tied for most highly expressed in a given cell, and if $u > 0.5$, then that cell is flagged as containing multiple gRNAs, per the above rule.) The maximum method is available only in the low-MOI setting in `sceptre`.

### Mixture method

The mixture method assigns gRNAs to cells using a latent variable generalized linear model (GLM). Consider a given gRNA $i$. Let $g_j$ be the UMI count of gRNA $i$ in cell $j$, and let $x_j$ be the (unobserved) variable indicating whether gRNA $i$ is present ($x_j = 1$) or absent ($x_j = 0$) in cell $j$. (We drop the $i$ subscript for notational compactness.) Additionally, let $z_j$ be the vector of cell-specific covariates in cell $j.$ (We assume that the count-based covariates, such as `grna_n_nonzero` and `grna_n_umis`, have been log-transformed, which `sceptre` does by default.) We model the gRNA UMI counts using a latent variable Poisson GLM:

$$
\begin{cases}
g_j | \mu_j \sim \textrm{Pois}(\mu_j) \\
\log(\mu_j | x_j, z_j) = \beta_0 + \gamma x_j + \beta^T z_j \\
x_j \sim \textrm{Bernoulli}(\pi).
\end{cases}
$$ {#eq-latent-variable-glm}

Here, $\mu_j$ is the mean expression level of gRNA $i$ in cell $j$ (given the covariates); $\beta_0$, $\gamma$, and $\beta \in \mathbb{R}^d$ are the (unknown) regression coefficients; and $\pi \in [0,1]$ is the (unknown) probability that gRNA $i$ is present in a given cell. We fit the model @eq-latent-variable-glm using an EM algorithm, producing estimates $\hat{\beta}_0$, $\hat{\gamma}$, $\hat{\beta}$, and $\hat{\pi}$ for the model coefficients $\beta_0$, $\gamma$, $\beta$, and $\pi$. Using these estimates, we can compute the probability $T_{ij} := \mathbb{P}(x_{ij} = 1)$ that a given cell $j$ contains gRNA $i$. (The probabilities $T_{i1}, \dots, T_{in}$ are sometimes called "posterior probabilities.") Finally, we threshold the posterior probabilities at some threshold $u$ (default value 0.8) to assign gRNA $i$ to the cells, i.e. we set $x_{ij} = 1$ if $T_{ij} > u$ and $x_{ij} = 0$ if $T_{ij} \leq u$. An advantage of the Poisson GLM framework is that it enables us to account for cell-specific covariates that might affect the level of background contamination, such as the number of gRNA UMIs sequenced in a given cell (i.e., `grna_n_umis`). The mixture method is available in both low- and high-MOI settings in `sceptre`.

Formulating the model @eq-latent-variable-glm is fairly straightforward; fitting the model to data in a fast and numerically stable way is more challenging. `sceptre` leverages a novel variant of the EM algorithm for this purpose, which we describe below.

Approximating the model @eq-latent-variable-glm with a simpler model. We begin by approximating the latent variable model @eq-latent-variable-glm with a simpler latent variable model that is easier to estimate. First, we obtain accurate estimates for the parameters $\beta_0$ and $\beta$ by exploiting the fact that the gRNA is present in only a small fraction (typically $< 2\%$) of cells. Let $f(g_j; \mu_j)$ denote the probability mass function of the Poisson distribution with mean $\mu_j$ evaluated at $g_j$, i.e.,

$$
f(g_j; \mu_j) = \frac{\mu_j^{g_j} e^{-\mu_j}}{g_j!}.
$$Conditioning on the covariates (i.e., treating $x_j$ and $z_j$ as fixed), we can express the log-likelihood of the GLM in @eq-latent-variable-glm as follows:\
$$
\begin{multline}
L(\beta_0, \gamma, \beta^T) = \sum_{j=1}^n \log \left[ f(g_j;\mu_j )\right] = \sum_{j=1}^n \log \left[ f(g_j; \exp(\beta_0 + \gamma x_j + \beta^T z_j)) \right] \\ = \underbrace{\sum_{j:x_j = 1} \log \left[ f(g_j; \exp(\beta_0 + \gamma + \beta^T z_j)) \right]}_{\textrm{few terms}} + \underbrace{\sum_{j: x_j = 0} \log \left[ f(g_j; \exp(\beta_0 + \beta^T z_j)) \right]}_\textrm{many terms} \\ \approx \sum_{j=1}^n \log \left[ f(g_j; \exp(\beta_0 + \beta^T z_j)) \right].
\end{multline}
$$

In words, the gRNA indicator $x_j$ is equal to zero in the large majority of cells, and so we can approximate the GLM in @eq-latent-variable-glm with the GLM that results from excluding $x_j$ from the model:

$$
\begin{cases}
g_j | \mu_j \sim \textrm{Pois} (\mu_j) \\
\log(\mu_j | z_j) = \beta_0 + \beta^T z_j.
\end{cases}
$$ {#eq-simplified_glm}

We can fit the GLM @eq-simplified_glm using the standard procedure for fitting GLMs (e.g., in R), as the covariates in this GLM are observed. Doing so yields estimates $\hat{\beta}_0$ and $\hat{\beta}$ for $\beta_0$ and $\beta$, respectively. Assuming that $\hat{\beta_0} \approx \beta_0$ and $\hat{\beta} \approx \beta$ (which holds for large $n$ and small $\pi$), we can write

$$\gamma x_j + \beta_0 x_j + \beta z_j \approx \gamma x_j + \hat{\beta}_0 + \hat{\beta} z_j = \gamma x_i + o_j,$$where we have set $o_j$ to $\hat{\beta}_0 + \hat{\beta}z_j$, i.e. the $j$th fitted value (on the scale of the linear component) of the GLM @eq-simplified_glm. Finally, we propose a simplified model for expression of the gRNA:

$$\begin{cases}
g_j | \mu_j \sim \textrm{Pois}(\mu_j) \\
\log(\mu_j | x_j) = \gamma x_j + o_j \\
x_j \sim \textrm{Bernoulli}(\pi).
\end{cases}
$$ {#eq-simplified_glm_2}

Here, the $o_j$s are offset terms in the GLM. Notice that the GLM in @eq-simplified_glm_2 does not include covariates or an intercept term; rather, all information about the covariates and the baseline expression level of the gRNA has been "encoded" into the offsets $o_1, \dots, o_n$. In summary we (i) estimated $\beta_0$ and $\beta$ using the GLM @eq-simplified_glm and then (ii) replaced $\beta_0$ and $\beta$ in @eq-latent-variable-glm with their corresponding estimates, yielding the model @eq-simplified_glm_2. The model @eq-simplified_glm_2 is a good approximation to @eq-latent-variable-glm in the sense that the maximum likelihood estimates for $\gamma$ and $\pi$ in @eq-simplified_glm_2 are close to the corresponding estimates for these parameters in @eq-latent-variable-glm when $n$ is large and $\pi$ is small (as is the case on most single-cell CRISPR screen datasets). We turn our attention to estimating the model @eq-simplified_glm_2, treating the offset terms $o_1, \dots, o_n$ as known and fixed.

EM algorithm. We derive an EM algorithm to estimate the model @eq-simplified_glm_2. Let $\theta = (\gamma, \pi)$ denote the unknown model parameters. Let $G_j$ be a random variable that represents the UMI count of the gRNA in the $j$th cell, and let $g_j$ be the realized value of this random variable. (Similarly, let $x_j$ be the realized value of the random variable $X_j$.) We begin by writing down the complete-data likelihood $l$ of this model, which is the likelihood that would result if $x_1, \dots, x_n$ *had* been observed.

$$
\begin{multline*}
l(\theta) = \prod_{j=1}^n \mathbb{P}(G_j = g_j, X_j = x_j) = \prod_{j=1}^n\mathbb{P}(G_j = g_j | X_j = x_j) \mathbb{P}(X_j = x_j) \\ = \prod_{j=1}^n f(g_j; \exp( \gamma x_j + o_j))\left[\pi^{x_i} (1-\pi)^{1-x_i} \right].
\end{multline*}
$$

We obtain the complete-data log-likelihood $L$ by taking the log of $l$:

$$
L(\theta) = \log(l(\theta)) = \sum_{j=1}^n \log\left[ f(g_j; \exp(\gamma x_j + o_j)\right] + \sum_{j=1}^n x_j \log(\pi) + (1-x_j)(1-\pi).
$$

We derive the E and M steps for the EM algorithm in this model.

[E step]{.underline}: The E step entails computing the membership probability of each cell (i.e., the probability that each cell contains the gRNA given the current parameter estimates and the observed gRNA counts). Let $\theta^{(t)} = (\gamma^{(t)}, \pi^{(t)})$ be the parameter estimate for $\theta$ at the $t$th iteration of the algorithm. The $j$th membership probability at the $t$th iteration of the algorithm $T^{(t)}_j$ is defined as $T^{(t)}_j = \mathbb{P}(X_j = 1 | G_j = g_j, \theta^{(t)}).$ Let $[\mu_j(k)]^{(t)}$ be the mean gRNA UMI count in the $j$th cell at the $t$th iteration of the algorithm that results from setting $x_j$ to $k \in \{0,1\}$, i.e.,

$$
[\mu_j(k)]^{(t)} = \exp( \gamma^{(t)} \cdot k + o_j ).
$$

Applying Bayes rule, we can express the membership probability $T^{(t)}_j$ as

$$
\begin{multline*}
T^{(t)}_j = \mathbb{P}(X_j = 1 | G_j = g_j, \theta^{(t)}) = \frac{\mathbb{P}(G_j = g_j | X_j = 1, \theta^{(t)})\mathbb{P}(X_j = 1 | \theta^{(t)})}{ \sum_{k=0}^1 \mathbb{P}(G_j = g_j | X_j = k, \theta^{(t)}) \mathbb{P}(X_j = k | \theta^{(t)})} \\ = \left(\frac{\mathbb{P}(G_j = g_j | X_j = 0, \theta^{(t)}) \mathbb{P}(X_j = 0)}{\mathbb{P}( G_j = g_j | X_j = 1, \theta^{(t)}) \mathbb{P}(X_j = 1)} +1\right)^{-1} = \left(\frac{f(g_j; [\mu_j(0)]^{(t)})(1-\pi^{(t)}))}{f(g_j; [\mu_j(1)]^{(t)})\pi^{(t)})} + 1 \right)^{-1} \\ = \left(\exp(q_j^{(t)}) + 1 \right)^{-1},
\end{multline*}
$$ where we define $$q_j^{(t)} := \log\left( \frac{f(g_j; [\mu_j(0)]^{(t)})(1-\pi^{(t)})}{f(g_j; [\mu_j(1)]^{(t)})\pi^{(t)}} \right).$$

Plugging in the Poisson probability mass function for $f$, we can express $q_j^{(t)}$ is follows.

$$
\begin{multline*}
q_j^{(t)} := \log(1-\pi^{(t)}) - \log(\pi^{(t)}) + g_j \left(\log([\mu_j(0)]^{(t)}) - \log([\mu_j(1)]^{(t)}) \right) \\ + [\mu_j(1)]^{(t)} - [\mu_j(0)]^{(t)}.
\end{multline*}
$$ {#eq-q_j_expression}

This expression @eq-q_j_expression for $q_j^{(t)}$ is numerically stable and fast to evaluate. In summary the M step consists of computing $T^{(t)}_j$ for all $j\in\{1, \dots, n\}$ by computing $q^{(t)}_j$ (using @eq-q_j_expression) and then evaluating $T^{(t)}_j = \exp(q_j^{(t)} + 1)^{-1}.$

[M step]{.underline}: The M-step involves maximizing the so-called "Q function," which is the function that results from taking the expectation of the complete-data log-likelihood with respect to the $X_j$s while conditioning on the $G_j$s and the current parameter estimates $\theta^{(t)}$. Formally, the Q function $Q(\theta | \theta^{(t)})$ is defined as $Q(\theta|\theta^{(t)}) = \mathbb{E}_{X_1, \dots, X_n}[L(\theta) | G_1 = g_1, \dots, G_n = g_n \theta^{(t)}]$. We can express the Q function as

$$
\begin{multline*}
Q(\theta|\theta^{(t)}) = \sum_{j=1}^n T^{(t)}_j \log(\pi) + \sum_{j=1}^n (1 - T_j^{(t)})\log(1-\pi) \\ + \sum_{j=1}^n T_j^{(t)} \log \left[ f\left(g_j; \exp[\gamma + o_j] \right) \right] + \sum_{j=1}^n (1 - T^{(t)}_j) \log \left[f(g_j; \exp(o_j) \right].
\end{multline*}
$$ {#eq-q_function}

The goal of the M step to identify the parameter $\theta = (\pi, \gamma)$ that maximizes @eq-q_function. The first two terms of @eq-q_function are a function of $\pi$, and the last two terms are a function of $\gamma$. Thus, we can optimize these sets of terms separately.

To find the maximizer in $\pi$, we differentiate the first two terms of @eq-q_function with respect to $\pi$, yielding

$$
\frac{\sum_{j=1}^n T_j^{(t)}}{\pi} - \frac{\sum_{j=1}^n (1 - T_j^{(t)})}{1 - \pi}.
$$ {#eq-m_step_0}

Setting @eq-m_step_0 to zero and solving for $\pi$ produces the maximizer $\pi^{(t+1)}$:

$$ \pi^{(t+1)} = (1/n) \sum_{j=1}^n T_j^{(t)}.$$ {#eq-pi_update}

We turn our attention to the last two terms of @eq-q_function. The final term is not a function of $\gamma$ and thus can be ignored. We rewrite the penultimate term as follows:

$$
\begin{multline*}
\sum_{j=1}^n T^{(t)}_j \log\left[ f(g_j; \exp[\gamma + o_j])\right] \\ = \sum_{j=1}^n T^{(t)}_j \log\left[ \frac{\exp(\gamma + o_j)^{g_j} \exp(-\exp[\gamma + o_j])}{g_j!} \right] \\ = 
\sum_{j=1}^n T_j^{(t)}\left[ g_j(\gamma + o_j) - \exp(\gamma + o_j) - \log(g_j!) \right].
\end{multline*}
$$ {#eq-m_step_1}

The derivative of @eq-m_step_1 with respect to $\gamma$ is

$$
\begin{multline*}
\sum_{j=1}^n T^{(t)}_j g_j - T^{(t)}_j \exp(\gamma + o_j) = \sum_{j=1}^n T^{(t)}_j g_j - \exp(\gamma) \sum_{j=1}^n T_j^{(t)} \exp(o_j).
\end{multline*}
$$ {#eq-m_step_2}

Finally, setting @eq-m_step_2 to zero and solving for $\gamma$ yields the maximizer

$$
\gamma^{(t+1)} = \log\left(\frac{\sum_{j=1}^n T^{(t)}_j y_j }{\sum_{j=1}^n T^{(t)}_j e^{o_j} }\right).
$$ {#eq-gamma_update}

In summary the M step entails computing the updated parameter estimates $\pi^{(t+1)}$ and $\gamma^{(t+1)}$ using the formulas @eq-pi_update and @eq-gamma_update, respectively.

[Convergence]{.underline}: The incomplete-data likelihood (which we obtain by integrating the complete-data likelihood with respect to the $x_j$s) is

$$
l_\textrm{incomplete}(\theta) = \prod_{j=1}^n f(g_j; \gamma + o_j) \pi + f(g_j; o_j)(1-\pi).
$$

The incomplete-data log-likelihood is

$$
L_\textrm{incomplete}(\theta) = \log(l_\textrm{incomplete}(\theta)) = \sum_{j=1}^n \log\left[ f(g_j; \gamma + o_j) \pi + f(g_j; o_j)(1-\pi) \right].
$$

Note that the incomplete-data log-likelihood --- in contrast to the complete-data log-likelihood --- is computable (albeit hard to optimize directly). We iterate between E and M steps until $L_\textrm{incomplete}$ converges. We declare that the sequence of estimates $\theta^{(0)}, \theta^{(1)}, \theta^{(2)}, \dots$ has converged when

$$
\frac{|L_\textrm{incomplete}(\theta^{(t+1)}) - L_\textrm{incomplete}(\theta^{(t)})|}{ \min\left\{ |L_\textrm{incomplete}(\theta^{(t+1)})|, |L_\textrm{incomplete}(\theta^{(t)}) | \right\}} < \epsilon
$$

for some $\epsilon > 0$ (by default $\epsilon = 0.5 \cdot 10^{-4}$). We set the final parameter estimates $\hat{\pi}$ and $\hat{\gamma}$ to $\pi^{(t+1)}$ and $\gamma^{(t+1)}$. Additionally, we use the final membership probabilities $T^{(t+1)}_1, \dots, T^{(t+1)}_n$ to assign the gRNA to cells.

As is standard, we run the EM algorithm several times over random starting estimates for $\pi$ and $\gamma$ to improve chances of converging to the global maximizer of the incomplete-data likelihood. We take the run whose estimates yield the greatest incomplete-data log-likelihood as the final run.

## Treatment group and control group

To test for association between a given gRNA (or gRNA target) and a response, `sceptre` divides the cells into two groups: the "treatment group" and the "control group." `sceptre` tests for differential expression of the response across these two groups of cells, yielding a p-value for the test of association. The definitions of treatment group and control group are somewhat subtle and depend on the analysis parameters of gRNA integration strategy (i.e., union, singleton, or Bonferroni), and control group (i.e., complement set or NT cells), analysis type (i.e., discovery analysis or calibration check). (See @sec-set_analysis_parameters for a discussion of these parameters.) This section aims to carefully define "treatment group" and "control group," in particular as a function of the aforementioned factors.

We first introduce some notation. Let $\mathcal{S} =\{1, \dots, n\}$ denote the set of cells. Let $X \in \{0,1\}^{r \times n}$ denote the matrix of imputed gRNA presences and absences (as determined in the gRNA assignment step; @sec-methods_assign_grnas). For $i \in \{1, \dots, r\}$, let $G_i$ denote the set of cells that gRNA $i$ has infected, i.e. $G_i := \{ j: x_{ij} = 1 \}.$ Let $\mathcal{N} \subset \{1, \dots, r\}$ denote the set of non-targeting gRNAs, and let $\mathcal{T} = \{1,\dots,r\} \setminus \mathcal{N}$ denote the set of targeting gRNAs. (Typically, $\mathcal{T}$ consists of both discovery gRNAs and positive control gRNAs.) Note that in low MOI, after applying quality control, each cell contains a single gRNA, implying that the sets $G_1, \dots, G_r$ are disjoint, i.e.

$$
\bigcap_{i=1}^r G_i = \emptyset.
$$

We proceed by taking cases on gRNA integration strategy, first considering the union integration strategy and then considering the singleton and Bonferroni integration strategies.

**Union gRNA integration strategy.** We first consider the "union" gRNA integration strategy. The union integration strategy involves combining multiple distinct gRNAs into a single "combined" gRNA and then testing this combined gRNA against responses as if it were a singleton gRNA. Suppose that we are running a discovery analysis, and let $\mathcal{I} \subset \mathcal{T}$ be a given set of gRNAs that target the same site. The table below defines the treatment group, the complement set control group, and the NT cells control group relative to $\mathcal{I}$.

|                                |                                                      |                                |
|:------------------:|:-------------------------:|:------------------------:|
|        Treatment group         |             Complement set control group             |     NT cells control group     |
| $\cup_{i \in \mathcal{I}} G_i$ | $\mathcal{S} \setminus \cup_{i \in \mathcal{I}} G_i$ | $\cup_{i \in \mathcal{N}} G_i$ |

: Union gRNA integration strategy, discovery analysis.

Next, suppose that we are running a calibration check analysis (again using the union gRNA integration strategy). Let $\mathcal{L} \subset \mathcal{N}$ be a set of non-targeting gRNAs that have been combined into a "negative control" gRNA target. (By default, $|\mathcal{L}| = |\mathcal{I}|$, i.e., the discovery target and negative control target contain the same number of gRNAs.) The treatment group, complement set control group, and NT cells control group are defined relative to $\mathcal{L}$ as follows.

|                                |                                                      |                                                        |
|:------------------:|:-------------------------:|:------------------------:|
|        Treatment group         |             Complement set control group             |                 NT cells control group                 |
| $\cup_{l \in \mathcal{L}} G_l$ | $\mathcal{S} \setminus \cup_{l \in \mathcal{L}} G_l$ | $\cup_{l \in (\mathcal{N} \setminus \mathcal{L})} G_l$ |

: Union gRNA integration strategy, calibration check.

**Singleton and Bonferroni gRNA integration strategies**. Next, we consider the "singleton" and "Bonferroni" gRNA integration strategies. Both strategies involve testing singleton gRNAs for association against responses. Suppose that we are running a discovery analysis, and let $i \in \mathcal{T}$ be a given targeting gRNA. The table below defines the treatment group, complement set control group, and NT cells control group relative to $i$.

|                 |                              |                                |
|:------------------:|:-------------------------:|:------------------------:|
| Treatment group | Complement set control group |     NT cells control group     |
|      $G_i$      | $\mathcal{S} \setminus G_i$  | $\cup_{i \in \mathcal{N}} G_i$ |

: Singleton/Bonferroni gRNA integration strategy, discovery analysis.

Finally, suppose that we are running a calibration check using the singleton or Bonferroni gRNA integration strategy. Let $l \in \mathcal{N}$ be a non-targeting gRNA. The treatment group, complement set control group, and NT cells control group are defined relative to $l$ as follows.

|                 |                              |                                                    |
|:------------------:|:-------------------------:|:------------------------:|
| Treatment group | Complement set control group |               NT cells control group               |
|      $G_l$      | $\mathcal{S} \setminus G_l$  | $\cup_{i \in (\mathcal{N}\setminus \{ l \} )} G_i$ |

: Singleton/Bonferroni gRNA integration strategy, calibration check.

Note that the Bonferroni gRNA integration strategy combines p-values across gRNAs that target the same site into a single "target-wide" p-value via a Bonferroni correction (discussed below). Note also that the complement set is available as a control group in both low- and high-MOI settings, while the NT cells are available as a control group only in the low-MOI setting.

## Differential expression testing and estimation

## Integrating information across (possibly variably effective) gRNAs

Suppose that gRNAs $1, \dots, k$ target the same site. Testing each of these gRNAs individually against a given response yields p-values $p_1, \dots, p_k$.

**Theorem**: Suppose that $p_1, \dots, p_k$ are superuniform, i.e. $\mathbb{P}(p_i \leq \alpha) \leq \alpha$ for all $i \in \{1, \dots, k\}$ and all $\alpha \in [0,1]$. Then $k \cdot \min\{p_1, \dots, p_k\}$ also is superuniform.

**Proof**:

$$
\begin{multline}
\mathbb{P}( k \cdot \min\{p_1, \dots, p_k\} \leq \alpha) = \mathbb{P}( \min\{p_1, \dots, p_k\} \leq \alpha/k )\\ = \mathbb{P}\left( p_1 \leq \alpha/k \textrm{ or } \dots \textrm{ or } p_k \leq \alpha /k  \right) \leq \sum_{i=1}^k \mathbb{P}(p_i \leq \alpha/k) \leq \sum_{i=1}^k \alpha/k = \alpha.
\end{multline}
$$

The penultimate inequality follows from the union bound, and the final inequality follows from the superuniformity of $p_i$. $\square$
