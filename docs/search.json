[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hands-On Single-Cell CRISPR Screen Analysis",
    "section": "",
    "text": "Welcome\nSingle-cell CRISPR screens (e.g., perturb-seq) combine CRISPR genome engineering and single-cell sequencing to survey the effects of genetic perturbations on individual cells. Single-cell CRISPR screens pose enormous potential for unraveling mechanisms underlying disease and accelerating drug discovery. However, the analysis of these screens presents considerable statistical and computational challenges. Hands-On Single-Cell CRISPR Screen Analysis is a step-by-step guide to carrying out statistically rigorous and computationally efficient single-cell CRISPR screen data analysis using the sceptre R package. sceptre was developed by Timothy Barry, Joseph Deutsch, and Eugene Katsevich.\nsceptre is compatible with a broad range of single-cell CRISPR screen experimental designs. In particular, datasets can vary along the following axes: multiplicity of infection (low or high), genomic element targeted (gene or noncoding regulatory element), CRISPR modality (CRISPRko, CRISPRi, CRISPRa, or CRISPR prime or base editing), and molecular readout (gene expression, protein expression, or chromatin accessibility). This book uses two real datasets to illustrate use of sceptre: a high-MOI CRISPRi screen of noncoding regulatory elements and a low-MOI CRISPRko screen of gene transcription start sites.\n\n\nNavigating this Book\nUsers should begin by reading the The whole game (link below), which provides a high-level overview of sceptre. Users who wish to learn more about individual steps of the sceptre pipeline should read the subsequent chapters (i.e., Import data to Run power check and discovery analysis) in order."
  },
  {
    "objectID": "sceptre.html#sec-whole_game_import_data",
    "href": "sceptre.html#sec-whole_game_import_data",
    "title": "The whole game",
    "section": "1. Import data",
    "text": "1. Import data\nThe first step is to import the data. Data can be imported into sceptre from 10X Cell Ranger or Parse outputs, as well as from R matrices. The simplest way to import the data is to read the output of one or more calls to cellranger_count() into sceptre via the function import_data_from_cellranger(). import_data_from_cellranger() requires three arguments: directories, grna_target_data_frame, and moi.\n\n\ndirectories is a character vector specifying the locations of the directories outputted by one or more calls to cellranger_count(). Below, we set the variable directories to the (machine-dependent) location of the example CRISPRi data on disk.\n\ndirectories &lt;- paste0(\n  system.file(\"extdata\", package = \"sceptre\"), \n  \"/highmoi_example/gem_group_\", 1:2\n)\ndirectories # file paths to the example data on your computer\n\n[1] \"/Library/Frameworks/R.framework/Versions/4.2/Resources/library/sceptre/extdata/highmoi_example/gem_group_1\"\n[2] \"/Library/Frameworks/R.framework/Versions/4.2/Resources/library/sceptre/extdata/highmoi_example/gem_group_2\"\n\n\ndirectories points to two directories, both of which store the expression data in matrix market format and contain the files barcodes.tsv.gz, features.tsv.gz, and matrix.mtx.gz.\n\nlist.files(directories[1])\n\n[1] \"barcodes.tsv.gz\" \"features.tsv.gz\" \"matrix.mtx.gz\"  \n\nlist.files(directories[2])\n\n[1] \"barcodes.tsv.gz\" \"features.tsv.gz\" \"matrix.mtx.gz\"  \n\n\n\n\ngrna_target_data_frame is a data frame mapping each individual gRNA to the genomic element that the gRNA targets. grna_target_data_frame contains two required columns: grna_id and grna_target. grna_id is the ID of an individual gRNA, while grna_target is a label specifying the genomic element that the gRNA targets. (Typically, multiple gRNAs are designed to target a given genomic element in a single-cell CRISPR screen.) Non-targeting (NT) gRNAs are assigned a gRNA target label of “non-targeting”. grna_target_data_frame optionally contains the columns chr, start, and end, which give the chromosome, start coordinate, and end coordinate, respectively, of the genomic region that each gRNA targets. We load and examine the grna_target_data_frame corresponding to the example data.\n\ndata(grna_target_data_frame_highmoi)\ngrna_target_data_frame_highmoi[c(1:4, 21:24, 80:83),]\n\n        grna_id      grna_target   chr     start       end\n1  grna_CCGGGCG  ENSG00000069482 chr11  68451943  68451958\n2  grna_TGGCGGC  ENSG00000069482 chr11  68451958  68451974\n3  grna_AAGGCCG  ENSG00000100316 chr22  39715775  39715790\n4  grna_GACGCCG  ENSG00000100316 chr22  39715790  39715806\n21 grna_TCTTGAC  candidate_enh_1  chr1 205720419 205720623\n22 grna_TGATCGC  candidate_enh_1  chr1 205720623 205720828\n23 grna_ATAGGAG candidate_enh_10 chr19  19475680  19475878\n24 grna_GCAGGCA candidate_enh_10 chr19  19475878  19476077\n80 grna_TATTCGT    non-targeting  &lt;NA&gt;        NA        NA\n81 grna_GACCTCC    non-targeting  &lt;NA&gt;        NA        NA\n82 grna_TTTCTCT    non-targeting  &lt;NA&gt;        NA        NA\n83 grna_AATGAGG    non-targeting  &lt;NA&gt;        NA        NA\n\n\nSome gRNAs (e.g., grna_CCGGGCG and grna_TGGCGGC) target gene transcription start sites and serve as positive controls; other gRNAs (e.g., grna_TCTTGAC and grna_TGATCGC) target candidate enhancers, while others still (e.g., grna_TATTCGT and grna_GACCTCC) are non-targeting. Each gene and candidate enhancer in this dataset is targeted by exactly two gRNAs.\n\n\nmoi is a string specifying the multiplicity-of-infection (MOI) of the data, taking values “high” or “low”. A high-MOI (respectively, low-MOI) dataset is one in which the experimenter has aimed to insert multiple gRNAs (respectively, a single gRNA) into each cell. (If a given cell is determined to contain multiple gRNAs in a low-MOI screen, that cell is removed as part of the quality control step, as discussed below.) The example dataset is a high MOI dataset, and so we set moi to “high”.\n\nmoi &lt;- \"high\"\n\n\n\nFinally, we call the function import_data_from_cellranger(), passing directories, grna_target_data_frame, and moi as arguments.\n\nsceptre_object &lt;- import_data_from_cellranger(\n  directories = directories,\n  grna_target_data_frame = grna_target_data_frame_highmoi,\n  moi = moi\n)\n\nimport_data_from_cellranger() returns a sceptre_object, which is an object-based representation of the single-cell CRISPR screen data. Evaluating sceptre_object in the console prints a helpful summary of the data.\n\nsceptre_object\n\nAn object of class sceptre_object.\n\nAttributes of the data:\n    • 45919 cells\n    • 526 responses\n    • High multiplicity-of-infection \n    • 70 targeting gRNAs (distributed across 35 targets) \n    • 25 non-targeting gRNAs \n    • 6 covariates (batch, grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito)\n\n\nSeveral metrics are displayed, including the number of cells, the number of genes (or “responses”), and the number of gRNAs present in the data. sceptre also automatically computes the following cell-specific covariates: grna_n_nonzero (i.e., the number of gRNAs expressed in the cell), grna_n_umis (i.e., the number of gRNA UMIs sequenced in the cell), response_n_nonzero (i.e., the number of responses expressed in the cell), response_n_umis (i.e., the number of response UMIs sequenced in the cell), response_p_mito (i.e., the fraction of transcripts mapping to mitochondrial genes), and batch. (Cells loaded from different directories are assumed to come from different batches.)\nSee Chapter 1 for more details about data import."
  },
  {
    "objectID": "sceptre.html#set-analysis-parameters",
    "href": "sceptre.html#set-analysis-parameters",
    "title": "The whole game",
    "section": "2. Set analysis parameters",
    "text": "2. Set analysis parameters\nThe second step is to set the analysis parameters. The most important analysis parameters are the discovery pairs, positive control pairs, sidedness, and gRNA grouping strategy.\n\n\nDiscovery pairs and positive control pairs. The primary goal of sceptre is to determine whether perturbation of a gRNA target (such as an enhancer) leads to a change in expression of a response (such as gene). We use the term target-response pair to refer to a given gRNA target and response that we seek to test for association (upon perturbation of the gRNA target). A discovery target-response pair is a target-response pair whose association status we do not know but would like to learn. For example, in an experiment in which we aim to link putative enhancers to genes, the discovery target-response pairs might consist of the set of putative enhancers and genes in close physical proximity to one another.\nA positive control (resp., negative control) target-response pair is a target-response pair for which we know that there is (resp., is not) a relationship between the target and the response. Positive control target-response pairs often are formed by coupling a transcription start site to the gene known to be regulated by that transcription start site. Negative control target-response pairs, meanwhile, typically are constructed by pairing negative control gRNAs to one or more responses. (We defer a detailed discussion of negative control pairs to a later section of this vignette.) Discovery pairs are of primary scientific interest, while positive control and negative control pairs serve a mainly technial purpose, helping us verify that the biological assay and statistical methodology are in working order.\nsceptre offers several helper functions to facilitate the construction of positive control and discovery pairs. The function construct_positive_control_pairs() takes as argument a sceptre_object and outputs the set of positive control pairs formed by matching gRNA targets (as contained in the grna_target_data_frame) to response IDs. Positive control pairs are optional and need not be computed.\n\npositive_control_pairs &lt;- construct_positive_control_pairs(sceptre_object)\nhead(positive_control_pairs)\n\n      grna_target     response_id\n1 ENSG00000069482 ENSG00000069482\n2 ENSG00000100316 ENSG00000100316\n3 ENSG00000104131 ENSG00000104131\n4 ENSG00000122026 ENSG00000122026\n5 ENSG00000135821 ENSG00000135821\n6 ENSG00000147669 ENSG00000147669\n\n\nNext, the functions construct_cis_pairs() and construct_trans_pairs() facilitate the construction of cis and trans discovery sets, respectively. construct_cis_pairs() takes as arguments a sceptre_object and an integer distance_threshold and returns the set of response-target pairs located on the same chromosome within distance_threshold bases of one another. positive_control_pairs optionally can be passed to this function, in which case positive control gRNA targets are excluded from the cis pairs. (Note that construct_cis_pairs() assumes that the responses are genes rather than, say, proteins or chromatin-derived features.)\n\ndiscovery_pairs &lt;- construct_cis_pairs(\n  sceptre_object = sceptre_object,\n  positive_control_pairs = positive_control_pairs,\n  distance_threshold = 5e6\n)\ndiscovery_pairs[c(1:4, 101:104),]\n\n         grna_target     response_id\n1    candidate_enh_1 ENSG00000174529\n2    candidate_enh_1 ENSG00000117222\n3    candidate_enh_1 ENSG00000133059\n4    candidate_enh_1 ENSG00000133069\n101 candidate_enh_10 ENSG00000064490\n102 candidate_enh_10 ENSG00000254901\n103 candidate_enh_10 ENSG00000184162\n104 candidate_enh_10 ENSG00000105705\n\n\nconstruct_trans_pairs() constructs the entire set of possible target-response pairs. See the Set Analysis Parameters vignette (vignette(\"set-analysis-parameters\")) for more information about these functions.\n\n\nSidedness. The parameter side controls whether to run a left-tailed (\"left\"), right-tailed (\"right\"), or two-tailed (\"both\"; default) test. A left-tailed (resp., right-tailed) test is appropriate when testing for a decrease (resp., increase) in expression; a two-tailed test, by contrast, is appropriate when testing for an increase or decrease in expression. A left-tailed test is the most appropriate choice for a CRISPRi screen of enhancers, and so we set side to \"left\".\n\nside &lt;- \"left\"\n\n\ngRNA grouping strategy. Typically, multiple gRNAs are designed to target a given genomic element. The parameter grna_grouping_strategy controls if and how gRNAs that target the same genomic element are grouped. The default option, \"union\", combines gRNAs that target the same element into a single “grouped gRNA;” this “grouped gRNA” is tested for association against the responses to which the element is paired. grna_grouping_strategy also can be set to “singleton,” in which case each gRNA targeting a given element is tested individually against the responses paired to that element. In our analysis we use the default “union” strategy.\n\nFinally, we set the analysis parameters by calling the function set_analysis_parameters(), passing sceptre_object, discovery_pairs, positive_control_pairs, and side as arguments. Note that sceptre_object and discovery_pairs are the only required arguments to this function.\n\nsceptre_object &lt;- set_analysis_parameters(\n  sceptre_object = sceptre_object,\n  discovery_pairs = discovery_pairs,\n  positive_control_pairs = positive_control_pairs,\n  side = side\n)\nprint(sceptre_object) # output suppressed for brevity\n\nSee Chapter 2 for more information about setting the analysis parameters."
  },
  {
    "objectID": "sceptre.html#sec-sceptre_assign_grnas",
    "href": "sceptre.html#sec-sceptre_assign_grnas",
    "title": "The whole game",
    "section": "3. Assign gRNAs to cells (optional)",
    "text": "3. Assign gRNAs to cells (optional)\nThe third step is to assign gRNAs to cells. This step can be skipped, in which case gRNAs are assigned to cells automatically using default options. The gRNA assignment step involves using the gRNA UMI counts to determine which cells contain which gRNAs. We begin by plotting the UMI count distribution of several randomly selected gRNAs via a call to the function plot_grna_count_distributions().\n\nplot_grna_count_distributions(sceptre_object)\n\n\n\n\n\nHistograms of the gRNA count distributions\n\n\n\nThe gRNAs display fairly bimodal count distributions. Consider, for example, gRNA_CCTGACA (top left corner). This gRNA exhibits a UMI count of \\(\\leq 1\\) or \\(\\geq 5\\) in most cells and a UMI count of 2, 3, or 4 in only a handful of cells. The vast majority of cells with a UMI count of 1 likely do not actually contain gRNA_CCTGACA. This is an example of “background contamination,” the phenomenon by which gRNA transcripts sometimes map to cells that do not contain the corresponding gRNA.\nsceptre provides three methods for assigning gRNAs to cells (the “mixture method,” the “maximum method,” and the “thresholding method”), all of which account for background contamination. The default method for high-MOI data is the “mixture method.” The gRNA counts are regressed onto the (unobserved) gRNA presence/absence indicator and the cell-specific covariates (e.g., grna_n_umis, batch) via a latent variable Poisson GLM. The fitted model yields the probability that each cell contains the gRNA, and these probabilities are thresholded to assign the gRNA to cells. The default method in low-MOI is the simpler “maximum” approach: the gRNA that accounts for the greatest number of UMIs in a given cell is assigned to that cell. A backup option in both low- and high-MOI is the “thresholding” approach: a given gRNA is assigned to a given cell if the UMI count of that gRNA in that cell exceeds some integer threshold.\nWe carry out the gRNA assignment step via a call to the function assign_grnas(). assign_grnas() takes arguments sceptre_object (required) and method (optional); the latter argument can be set to \"mixture\", \"maximum\", or \"thresholding\". We parallelize execution of assign_grnas() by setting parallel to TRUE. (Windows users should remove the parallel = TRUE argument, as parallel execution is not yet configured for Windows.)\n\nsceptre_object &lt;- assign_grnas(sceptre_object = sceptre_object, parallel = TRUE)\nprint(sceptre_object) # output suppressed for brevity\n\nWe can call plot() on the resulting sceptre_object to render a plot summarizing the output of the gRNA-to-cell assignment step.\n\nplot(sceptre_object)\n\n\n\n\n\ngRNA-to-cell assignments\n\n\n\nThe top panel plots the gRNA-to-cell assignments of three randomly selected gRNAs. In each plot the points represent cells; the vertical axis indicates the UMI count of the gRNA in a given cell, and the horizontal axis indicates whether the cell has been classified as “perturbed” (i.e., it contains the gRNA) or unperturbed (i.e., it does not contain the gRNA). Perturbed (resp., unperturbed) cells are shown in the left (resp., right) column. The bottom left panel is a barplot of the number of cells to which each gRNA has been mapped. Finally, the bottom right panel is a histogram of the number of gRNAs contained in each cell. The mean number of gRNAs per cell — i.e., the MOI — is displayed in purple text.\nSee Chapter 3 for more information about assigning gRNAs to cells."
  },
  {
    "objectID": "sceptre.html#sec-sceptre_qc",
    "href": "sceptre.html#sec-sceptre_qc",
    "title": "The whole game",
    "section": "4. Run quality control (optional)",
    "text": "4. Run quality control (optional)\nThe fourth step is to run quality control (QC). This step likewise can be skipped, in which case QC is applied automatically using default options. sceptre implements two kinds of QC: cellwise QC and pairwise QC. The former aims to remove low-quality cells, while the latter aims to remove low-quality target-response pairs.\nThe cellwise QC that sceptre implements is standard in single-cell analysis. Cells for which response_n_nonzero (i.e., the number of expressed responses) or response_n_umis (i.e., the number of response UMIs) is extremely high or extremely low are removed. Likewise, cells for which response_p_mito (i.e., the fraction of UMIs mapping to mitochondrial genes) is excessively high are removed. Additionally, in low-MOI, cells that contain multiple gRNAs (as determined during the RNA-to-cell assignment step) are removed. Finally, users optionally can provide a list of additional cells to remove.\nsceptre also implements QC at the level of the target-response pair. For a given pair we define the “treatment cells” as those that contain a gRNA targeting the given target. Next, we define the “control cells” as the cells against which the treatment cells are compared to carry out the differential expression test. We define the “number of nonzero treatment cells” (n_nonzero_trt) as the number of treatment cells with nonzero expression of the response; similarly, we define the “number of nonzero control cells” (n_nonzero_cntrl) as the number of control cells with nonzero expression of the response. sceptre filters out pairs for which n_nonzero_trt or n_nonzero_cntrl falls below some threshold (by default 7).\nWe call the function run_qc() on the sceptre_object to carry out cellwise and pairwise QC. run_qc() has several optional arguments that control the stringency of the various QC thresholds. For example, we set p_mito_threshold = 0.075, which filters out cells whose response_p_mito value exceeds 0.075. (The optional arguments are set to reasonable defaults; the default for p_mito_threshold is 0.2, for instance).\n\nsceptre_object &lt;- run_qc(sceptre_object, p_mito_threshold = 0.075)\nprint(sceptre_object) # output suppressed for brevity\n\nWe can visualize the output of the QC step by calling plot() on the updated sceptre_object.\n\nplot(sceptre_object)\n\n\n\n\n\nCellwise and pairwise quality control\n\n\n\nThe top panel depicts the outcome of the cellwise QC. The various cellwise QC filters (e.g., “N nonzero responses,” “N response UMIs,” “Percent mito”, etc.) are shown on the horizontal axis, and the percentage of cells removed due application of a given QC filter is shown on the vertical axis. Note that a cell can be flagged by multiple QC filters; for example, a cell might have an extremely high response_n_umi value and an extremely high response_n_nonzero value. Thus, the height of the “any filter” bar (which indicates the percentage of cells removed due to application of any filter) need not be equal to the sum of the heights of the other bars. The bottom panel depicts the outcome of the pairwise QC. Each point corresponds to a target-response pair; the vertical axis (resp., horizontal axis) indicates the n_nonzero_trt (resp., n_nonzero_cntrl) value of that pair. Pairs for which n_nonzero_trt or n_nonzero_cntrl fall below the threshold are removed (red), while the remaining pairs are retained (green).\nSee Chapter 4 for more information about QC."
  },
  {
    "objectID": "sceptre.html#sec-sceptre_calibration_check",
    "href": "sceptre.html#sec-sceptre_calibration_check",
    "title": "The whole game",
    "section": "5. Run calibration check",
    "text": "5. Run calibration check\nThe fifth step is to run the calibration check. The calibration check is an analysis that verifies that sceptre controls the rate of false discoveries on the dataset under analysis. The calibration check proceeds as follows. First, negative control target-response pairs are constructed (automatically) by coupling subsets of NT gRNAs to randomly selected responses. Importantly, the negative control pairs are constructed in such a way that they are similar to the discovery pairs, the difference being that the negative control pairs are devoid of biological signal. Next, sceptre is applied to analyze the negative control pairs. Given that the negative control pairs are absent of signal, sceptre should produce approximately uniformly distributed p-values on the negative control pairs. Moreover, after an appropriate multiple testing correction, sceptre should make zero (or very few) discoveries on the negative control pairs. Verifying calibration via the calibration check increases our confidence that the discovery set that sceptre ultimately produces is uncontaminated by excess false positives.\nWe run the calibration check by calling the function run_calibration_check() on the sceptre_object.\n\nsceptre_object &lt;- run_calibration_check(sceptre_object, parallel = TRUE)\nprint(sceptre_object) # output suppressed for brevity\n\nWe can assess the outcome of the calibration check by calling plot() on the resulting sceptre_object.\n\nplot(sceptre_object)\n\n\n\n\n\nCalibration check results\n\n\n\nThe visualization consists of four panels, which we describe below.\n\nThe upper left panel is a QQ plot of the p-values plotted on an untransformed scale. The p-values should lie along the diagonal line, indicating uniformity of the p-values in the bulk of the distribution.\nThe upper right panel is a QQ plot of the p-values plotted on a negative log-10 transformed scale. The p-values again should lie along the diagonal line (with the majority of the p-values falling within the gray confidence band), indicating uniformity of the p-values in the tail of the distribution.\nThe lower left panel is a histogram of the estimated log-2 fold changes. The histogram should be roughly symmetric and centered around zero.\nFinally, the bottom right panel is a text box displaying (i) the number of false discoveries that sceptre has made on the negative control data and (ii) the mean estimated log-fold change. The number of false discoveries should be a small integer like zero, one, two, or three, with zero being ideal. The mean estimated log-fold change, meanwhile, should be a numeric value close to zero; a number in the range [-0.1, 0.1] is adequate.\n\nsceptre may not exhibit good calibration initially, which is OK. See Chapter 5 for more information about the calibration check analysis, including concrete strategies for improving calibration."
  },
  {
    "objectID": "sceptre.html#run-power-check-optional",
    "href": "sceptre.html#run-power-check-optional",
    "title": "The whole game",
    "section": "6. Run power check (optional)",
    "text": "6. Run power check (optional)\nThe sixth step — which is optional — is to run the power check. The power check involves applying sceptre to analyze the positive control pairs. Given that the positive control pairs are known to contain signal, sceptre should produce significant (i.e., small) p-values on the positive control pairs. The power check enables us to assess sceptre’s power (i.e., its ability to detect true associations) on the dataset under analysis. We run the power check by calling the function run_power_check() on the sceptre_object.\n\nsceptre_object &lt;- run_power_check(sceptre_object, parallel = TRUE)\nprint(sceptre_object) # output suppressed for brevity\n\nWe can visualize the outcome of the power check by calling plot() on the resulting sceptre_object.\n\nplot(sceptre_object)\n\n\n\n\n\nPower check results\n\n\n\nEach point in the plot corresponds to a target-response pair, with positive control pairs in the left column and negative control pairs in the right column. The vertical axis indicates the p-value of a given pair; smaller (i.e., more significant) p-values are positioned higher along this axis (p-values truncated at \\(10^{-20}\\) for visualization). The positive control p-values should be small, and in particular, smaller than the negative control p-values."
  },
  {
    "objectID": "sceptre.html#run-discovery-analysis",
    "href": "sceptre.html#run-discovery-analysis",
    "title": "The whole game",
    "section": "7. Run discovery analysis",
    "text": "7. Run discovery analysis\nThe seventh and penultimate step is to run the discovery analysis. The discovery analysis entails applying sceptre to analyze the discovery pairs. We run the discovery analysis by calling the function run_discovery_analysis().\n\nsceptre_object &lt;- run_discovery_analysis(sceptre_object, parallel = TRUE)\nprint(sceptre_object) # output suppressed for brevity\n\nWe can visualize the outcome of the discovery analysis by calling plot() on the resulting sceptre_object.\n\nplot(sceptre_object)\n\n\n\n\n\nDiscovery analysis results\n\n\n\nThe visualization consists of four panels.\n\nThe upper left plot superimposes the discovery p-values (blue) on top of the negative control p-values (red) on an untransformed scale.\nThe upper right plot is the same as the upper left plot, but the scale is negative log-10 transformed. The discovery p-values should trend above the diagonal line, indicating the presence of signal in the discovery set. The horizontal dashed line indicates the multiple testing threshold; discovery pairs whose p-value falls above this line are called as significant.\nThe bottom left panel is a volcano plot of the p-values and log fold changes of the discovery pairs. Each point corresponds to a pair; the estimated log-2 fold change of the pair is plotted on the horizontal axis, and the (negative log-10 transformed) p-value is plotted on the vertical axis. The horizontal dashed line again indicates the multiple testing threshold. Points above the dashed line (colored in purple) are called as discoveries, while points below (colored in blue) are called as insignificant.\nThe bottom right panel is a text box displaying the number of discovery pairs called as significant."
  },
  {
    "objectID": "sceptre.html#write-outputs-to-directory",
    "href": "sceptre.html#write-outputs-to-directory",
    "title": "The whole game",
    "section": "8. Write outputs to directory",
    "text": "8. Write outputs to directory\nThe eighth and final step is to write the outputs of the analysis to a directory on disk. We call the function write_outputs_to_directory(), which takes as arguments a sceptre_object and directory; directory is a string indicating the location of the directory in which to write the results contained within the sceptre_object.\n\nwrite_outputs_to_directory(\n  sceptre_object = sceptre_object, \n  directory = \"~/sceptre_outputs\"\n)\n\nwrite_outputs_to_directory() writes several files to the specified directory: a text-based summary of the analysis (“analysis_summary.txt”), the various plots (“*.png”), and the calibration check, power check, and discovery analysis results (“results_run_calibration_check.rds,” “results_run_power_check.rds,” and “results_run_discovery_analysis.rds,” respectively).\n\nlist.files(\"~/sceptre_outputs\")\n\n [1] \"analysis_summary.txt\"               \"plot_assign_grnas.png\"             \n [3] \"plot_grna_count_distributions.png\"  \"plot_run_calibration_check.png\"    \n [5] \"plot_run_discovery_analysis.png\"    \"plot_run_power_check.png\"          \n [7] \"plot_run_qc.png\"                    \"results_run_calibration_check.rds\" \n [9] \"results_run_discovery_analysis.rds\" \"results_run_power_check.rds\"       \n\n\nWe also can obtain the calibration check, power check, and discovery analysis results in R via a call to the function get_result(), passing as arguments sceptre_object and analysis, where the latter is a string indicating the function whose results we are querying.\n\nresult &lt;- get_result(sceptre_object, analysis = \"run_discovery_analysis\")\n\nThe variable result is a data frame, the rows of which correspond to target-response pairs, and the columns of which are as follows: response_id, grna_target, n_nonzero_trt, n_nonzero_cntrl, pass_qc (a TRUE/FALSE value indicating whether the pair passes pairwise QC), p_value, log_2_fold_change, and significant (a TRUE/FALSE value indicating whether the pair is called as significant).\n\nhead(result)\n\n       response_id      grna_target n_nonzero_trt n_nonzero_cntrl pass_qc\n1: ENSG00000147454 candidate_enh_19           987           38763    TRUE\n2: ENSG00000136938 candidate_enh_20           829           43056    TRUE\n3: ENSG00000165702 candidate_enh_23           421           17129    TRUE\n4: ENSG00000136929 candidate_enh_20           507           30997    TRUE\n5: ENSG00000135046 candidate_enh_25           438           32903    TRUE\n6: ENSG00000106992 candidate_enh_22           693           30172    TRUE\n        p_value log_2_fold_change significant\n1: 4.132597e-39        -0.7299781        TRUE\n2: 3.674875e-37        -0.3377841        TRUE\n3: 2.743547e-31        -0.7788056        TRUE\n4: 7.498748e-24        -0.6062542        TRUE\n5: 1.112902e-18        -0.8483076        TRUE\n6: 1.142874e-14        -0.3438875        TRUE"
  },
  {
    "objectID": "sceptre.html#further-reading",
    "href": "sceptre.html#further-reading",
    "title": "The whole game",
    "section": "Further reading",
    "text": "Further reading\nEach step of the pipeline has its own dedicated chapter. We encourage interested users to read these additional chapters one-by-one to learn more about the various options available at each step of the pipeline, starting with Chapter 1."
  },
  {
    "objectID": "import-data.html#import-data-from-an-existing-software-package",
    "href": "import-data.html#import-data-from-an-existing-software-package",
    "title": "1  Import data",
    "section": "\n1.1 Import data from an existing software package",
    "text": "1.1 Import data from an existing software package\nsceptre links up with two programs for upstream processing of single-cell CRISPR screen data: 10X Cellranger and the analogous software tool developed by Parse Biosciences. (We refer to the latter program as the “Parse program.”) We describe how to import data from each of these tools below.\n\n1.1.1 Import from 10X CellRanger\nSection 1 of The whole game describes how to import data from 10X CellRanger. We include a minimal working example here.\n\ndirectories &lt;- paste0(system.file(\"extdata\", package = \"sceptre\"), \"/highmoi_example/gem_group_\", 1:2)\ndata(grna_target_data_frame_highmoi)\nsceptre_object &lt;- import_data_from_cellranger(directories = directories,\n                                              moi = \"high\",\n                                              grna_target_data_frame = grna_target_data_frame_highmoi)\n\n\n1.1.2 Import from the Parse program\nA function to import data from the Parse program is coming soon.\n\n1.1.3 Add extra covariates\nimport_data_from_cellranger() and input_data_from_parse() compute the covariates grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito, and batch. Users may wish to supply additional covariates (e.g., cell cycle or cell type) to sceptre. To do so, users can pass a data frame extra_covariates containing additional covariates to import_data_from_cellranger() or input_data_from_parse(). Below, we simulate an additional covariate cell_type and pass this covariate as an argument to the data import function.\n\n# simulate an extra covariate, namely cell type\ncell_type &lt;- sample(x = paste0(\"type_\", 1:3), size = 45919, replace = TRUE) |&gt; factor()\nextra_covariates &lt;- data.frame(cell_type = cell_type)\n\n# import data, passing the the extra covariates as an argument\nsceptre_object &lt;- import_data_from_cellranger(directories = directories,\n                                              moi = \"high\",\n                                              grna_target_data_frame = grna_target_data_frame_highmoi,\n                                              extra_covariates = extra_covariates)\n\nThe additional covariate of cell_type is printed in the “covariates” field when we evaluate sceptre_object in the console.\n\nsceptre_object\n\nAn object of class sceptre_object.\n\nAttributes of the data:\n    • 45919 cells\n    • 526 responses\n    • High multiplicity-of-infection \n    • 70 targeting gRNAs (distributed across 35 targets) \n    • 25 non-targeting gRNAs \n    • 7 covariates (batch, cell_type, grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito)"
  },
  {
    "objectID": "import-data.html#import-data-from-a-collection-of-r-objects",
    "href": "import-data.html#import-data-from-a-collection-of-r-objects",
    "title": "1  Import data",
    "section": "\n1.2 Import data from a collection of R objects",
    "text": "1.2 Import data from a collection of R objects\nUsers also can import data into sceptre from a specified set of R objects. This data import strategy is most appropriate for users employing less standard data preprocessing pipelines to generate the response and gRNA count matrices. We use the high MOI-CRISPRi data as a working example. We can obtain these data in R matrix and data frame format as follows.\n\ndata(highmoi_example_data)\nresponse_matrix &lt;- highmoi_example_data$response_matrix # response matrix\ngrna_matrix &lt;- highmoi_example_data$grna_matrix # grna matrix\nextra_covariates &lt;- highmoi_example_data$extra_covariates # batch information\nresponse_names &lt;- highmoi_example_data$gene_names # response names\ngrna_target_data_frame &lt;- grna_target_data_frame_highmoi # gRNA target data frame\n\nWe call the function import_data() to import the data from a collection of R objects. import_data() takes several arguments: response_matrix, grna_matrix, grna_target_data_frame, moi, extra_covariates, and response_names. The following figure summarizes the main inputs to this function.\n\n\n\n\nThe main data objects involved in a single-cell CRISPR screen analysis: a response matrix, a gRNA matrix, a data frame of extra covariates (optional), and a gRNA target data frame.\n\n\n\nWe describe the inputs below.\n\n\nresponse_matrix is the matrix of response UMI counts. The responses should be in the rows and the cells in the columns. The row names of the response_matrix should be the response IDs. The first ten rows and columns of the example response_matrix are as follows.\n\nresponse_matrix[1:10,1:10]\n\n10 x 10 sparse Matrix of class \"dgTMatrix\"\n\nENSG00000069275 4 6 10 9 4 13 8 8 10 8\nENSG00000117222 2 1  . 1 1  . . .  . 1\nENSG00000117266 . .  . . .  . . .  . .\nENSG00000117280 . .  . 1 .  . . .  . 1\nENSG00000133059 . .  . . .  1 . 2  . 1\nENSG00000133065 . .  . . .  . . 2  . 1\nENSG00000133069 . .  . . .  . . .  . .\nENSG00000158711 . .  . . .  . . 1  . .\nENSG00000158715 . .  . . .  . . .  . .\nENSG00000162873 . .  . . .  . . .  . .\n\n\n\n\ngrna_matrix is the matrix of gRNA UMI counts. The gRNAs should be in the rows and the cells in the columns. The row names of grna_matrix should be the gRNA IDs. The first ten rows and columns of the example grna_matrix are as follows.\n\ngrna_matrix[1:10,1:10]\n\n10 x 10 sparse Matrix of class \"dgTMatrix\"\n\ngrna_CCGGGCG . 8 . . .  . . . . .\ngrna_TGGCGGC . . . . .  . . . . .\ngrna_AAGGCCG . . . . .  . . . . .\ngrna_GACGCCG . . . . .  . . . . .\ngrna_CACACCC . . . . . 25 . . . .\ngrna_GCTCACA . . . . .  . . . . .\ngrna_CTCTGAG . . . . .  . . . . .\ngrna_GCGCCCG . . . . .  . . . . .\ngrna_GAGCGTG . . . . .  . . . . .\ngrna_GCTCTGC . . . . .  . . . . .\n\n\n\n\nresponse_matrix and grna_matrix should be stored in one of the following formats: matrix, dgTMatrix, dgCMatrix, or dgRMatrix.\n\n\ngrna_target_data_frame is the data frame mapping each gRNA to its target. The grna_target_data_frame that we pass to import_data() is exactly the same as the one that we pass to import_data_from_cellranger(). See Section 1 of The whole game for more information about this argument.\n\ngrna_target_data_frame[c(1:4, 21:24, 80:83),]\n\n        grna_id      grna_target   chr     start       end\n1  grna_CCGGGCG  ENSG00000069482 chr11  68451943  68451958\n2  grna_TGGCGGC  ENSG00000069482 chr11  68451958  68451974\n3  grna_AAGGCCG  ENSG00000100316 chr22  39715775  39715790\n4  grna_GACGCCG  ENSG00000100316 chr22  39715790  39715806\n21 grna_TCTTGAC  candidate_enh_1  chr1 205720419 205720623\n22 grna_TGATCGC  candidate_enh_1  chr1 205720623 205720828\n23 grna_ATAGGAG candidate_enh_10 chr19  19475680  19475878\n24 grna_GCAGGCA candidate_enh_10 chr19  19475878  19476077\n80 grna_TATTCGT    non-targeting  &lt;NA&gt;        NA        NA\n81 grna_GACCTCC    non-targeting  &lt;NA&gt;        NA        NA\n82 grna_TTTCTCT    non-targeting  &lt;NA&gt;        NA        NA\n83 grna_AATGAGG    non-targeting  &lt;NA&gt;        NA        NA\n\n\n\n\nmoi is a string specifying the MOI of the dataset, either “high” or “low”. This argument serves the same function as it does in import_data_from_cellranger(). See Section 1 of The whole game for more information.\n\nmoi &lt;- \"high\"\n\n\n\nextra_covariates (optional) is a data frame specifying cell-specific covariates beyond those that sceptre can compute. import_data() computes the covariates grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, and response_p_mito. import_data() does not compute batch, as import_data() does not have access to batch information. Thus, batch — alongside any other relevant covariates, such as cell type — should be included in the extra_covariates data frame.\n\nextra_covariates[c(1:3, 30001:30003),,drop = FALSE]\n\n      batch\n1        b1\n2        b1\n3        b1\n30001    b2\n30002    b2\n30003    b2\n\n\n\n\nresponse_names (optional) is a vector of human-readable response names. response_names is used to determine which of the responses (if any) are mitochondrial genes for the purpose of computing the response_p_mito covariate.\n\nhead(response_names)\n\n[1] \"NUCKS1\"  \"RBBP5\"   \"CDK18\"   \"RAB29\"   \"DSTYK\"   \"SLC41A1\"\n\n\n\n\nWe pass the arguments response_matrix, grna_matrix, grna_target_data_frame, moi, extra_covariates, and response_names to import_data(), which initializes a sceptre_object.\n\nsceptre_object &lt;- import_data(response_matrix = response_matrix,\n                              grna_matrix = grna_matrix,\n                              grna_target_data_frame = grna_target_data_frame,\n                              moi = moi,\n                              extra_covariates = extra_covariates,\n                              response_names = response_names)"
  },
  {
    "objectID": "set-analysis-parameters.html#positive-control-pairs",
    "href": "set-analysis-parameters.html#positive-control-pairs",
    "title": "2  Set analysis parameters",
    "section": "\n2.1 Positive control pairs",
    "text": "2.1 Positive control pairs\nPositive control pairs are target-response pairs for which we know (or have strong reason to believe) that there is a regulatory relationship between the target and the response. We can use positive control pairs to verify that sceptre (or any association testing method for that matter) is sensitive (i.e., capable of detecting true associations) on the dataset under analysis. We use the function construct_positive_control_pairs() to construct the positive control pairs. construct_positive_control_pairs() takes as an argument a sceptre_object and returns a data frame with columns grna_target and response_id, where gRNA targets and response IDs with matching names are paired. We call construct_positive_control_pairs() on the high-MOI CRISPRi dataset and the low-MOI CRISPRko dataset. In both cases the positive control set consists of transcription start sites paired to the gene regulated by those transcription start sites.\n\npositive_control_pairs_highmoi &lt;- construct_positive_control_pairs(sceptre_object_highmoi)\nhead(positive_control_pairs_highmoi) # high MOI CRISPRi dataset\n\n      grna_target     response_id\n1 ENSG00000069482 ENSG00000069482\n2 ENSG00000100316 ENSG00000100316\n3 ENSG00000104131 ENSG00000104131\n4 ENSG00000122026 ENSG00000122026\n5 ENSG00000135821 ENSG00000135821\n6 ENSG00000147669 ENSG00000147669\n\n\n\npositive_control_pairs_lowmoi &lt;- construct_positive_control_pairs(sceptre_object_lowmoi)\nhead(positive_control_pairs_lowmoi) # low MOI CRISPRko dataset\n\n  grna_target response_id\n1       CMTM6       CMTM6\n2      IFNGR2      IFNGR2\n3        JAK2        JAK2\n4      NFKBIA      NFKBIA\n5       STAT1       STAT1\n6       STAT2       STAT2\n\n\nPositive control pairs need not consist exclusively of gene transcription start sites paired to target genes. For example, enhancer-gene links that have been validated previously (through, e.g., arrayed CRISPR screens) also can serve as positive control pairs. Users manually can append additional positive control pairs to the positive control pair data frame via a call to rbind(). For example, suppose we know on the high-MOI CRISPRi data that candidate_enh_1 regulates gene ENSG00000069482 and that candidate_enh_10 regulates gene ENSG00000135821. We can add these enhancer-gene links to the positive control pair data frame as follows.\n\n# construct data frame of additional positive control pairs\nadditional_positive_control_pairs &lt;-\n  data.frame(grna_target = c(\"candidate_enh_1\", \"candidate_enh_10\"),\n             response_id = c(\"ENSG00000069482\", \"ENSG00000135821\"))\n\n# append additional pairs to positive control data frame\npositive_control_pairs_highmoi_updated &lt;- rbind(positive_control_pairs_highmoi,\n                                                additional_positive_control_pairs)\npositive_control_pairs_highmoi_updated\n\n        grna_target     response_id\n1   ENSG00000069482 ENSG00000069482\n2   ENSG00000100316 ENSG00000100316\n3   ENSG00000104131 ENSG00000104131\n4   ENSG00000122026 ENSG00000122026\n5   ENSG00000135821 ENSG00000135821\n6   ENSG00000147669 ENSG00000147669\n7   ENSG00000155380 ENSG00000155380\n8   ENSG00000176890 ENSG00000176890\n9   ENSG00000187840 ENSG00000187840\n10  ENSG00000196683 ENSG00000196683\n11  candidate_enh_1 ENSG00000069482\n12 candidate_enh_10 ENSG00000135821\n\n\nWe then could supply positive_control_pairs_highmoi_updated instead of positive_control_pairs_highmoi to set_analysis_parameters()."
  },
  {
    "objectID": "set-analysis-parameters.html#discovery-pairs",
    "href": "set-analysis-parameters.html#discovery-pairs",
    "title": "2  Set analysis parameters",
    "section": "\n2.2 Discovery pairs",
    "text": "2.2 Discovery pairs\nDiscovery pairs are target-response pairs whose association status we do not know but seek to learn. Unlike positive control and negative control pairs, which serve a mainly technical purpose, discovery pairs are of primary scientific interest. Discovery pairs must be supplied to set_analysis_parameters(); all other arguments (aside from sceptre_object) are optional. sceptre provides two helper functions for constructing discovery pairs: construct_cis_pairs() and construct_trans_pairs().\n\n2.2.1 Construct cis pairs\nconstruct_cis_pairs() returns the set of target-response pairs for which the target and response are located on the same chromosome and in close physical proximity to one another. construct_cis_pairs() assumes that the columns chr, start, and stop are present within the grna_target_data_frame. construct_cis_pairs() also assumes that the responses are genes as opposed to, say, proteins. construct_cis_pairs() is a useful pair constructor function for screens that aim to map noncoding regulatory elements (e.g., enhancers, silencers, or noncoding GWAS variants) to target genes in cis. construct_cis_pairs() takes several arguments: sceptre_object (required) distance_threshold (optional), positive_control_pairs (optional), and ref_genome (optional). Each target is paired to the set of genes within distance_threshold bases of that target. (The default value of distance_threshold is 500,000 bases, or half a megabase.) The positive_control_pairs data frame optionally can be passed to construct_cis_pairs(), in which case the positive control targets (i.e., the entries within the grna_target column of positive_control_pairs) are excluded from the cis pairs. Finally, ref_genome is a string indicating the reference genome that chr, start, and stop are defined with respect to. (The only reference genome currently available is “10X_GRCh38_2020,” which is the GRCh38 reference genome that has shipped with CellRanger since 2020.)\nWe use construct_cis_pairs() to construct the discovery pairs for the high-MOI CRISPRi dataset. We set distance_threshold to 5e6 (i.e., 5 megabases) so as to increase the number of pairs in the discovery set for illustration purposes.\n\ndiscovery_pairs_highmoi &lt;- construct_cis_pairs(sceptre_object = sceptre_object_highmoi,\n                                               positive_control_pairs = positive_control_pairs_highmoi,\n                                               distance_threshold = 5e6)\n\ndiscovery_pairs_highmoi is a data frame with columns grna_target and response_id; each candidate enhancer is mapped to the set of genes in close proximity to that candidate enhancer.\n\ndiscovery_pairs_highmoi[c(1, 10, 20, 30, 40, 50),]\n\n       grna_target     response_id\n1  candidate_enh_1 ENSG00000174529\n10 candidate_enh_1 ENSG00000117280\n20 candidate_enh_2 ENSG00000143493\n30 candidate_enh_2 ENSG00000136643\n40 candidate_enh_3 ENSG00000142733\n50 candidate_enh_3 ENSG00000117748\n\n\n\n2.2.2 Construct trans pairs\nconstruct_trans_pairs() returns the entire set of possible target-response pairs. construct_trans_pairs() is a useful pair constructor function for analyses in which we seek to conduct a trans analysis, testing each target against each response. construct_trans_pairs() takes as arguments sceptre_object (required), positive_control_pairs (optional), exclude_positive_control_pairs (optional), and exclude_positive_control_targets (optional). By default construct_trans_pairs() returns a data frame with columns grna_target and response_id, where each gRNA target is mapped to each response ID. If the positive_control_pairs data frame is passed and exclude_positive_control_pairs is set to TRUE, then the positive control target-response pairs are excluded from the trans pairs. Next, if positive_control_pairs is passed and exclude_positive_control_targets is set to TRUE, then all pairs containing a positive control gRNA target are excluded from the trans pairs. (In this sense setting exclude_positive_control_targets to TRUE is stronger than setting exclude_positive_control_pairs to TRUE.)\nWe use construct_trans_pairs() to construct the discovery set for the low-MOI CRISPRko dataset, excluding the positive control pairs. The discovery set consists of the set of genes targeted by one or more gRNAs paired to the set of all other genes.\n\ndiscovery_pairs_lowmoi &lt;- construct_trans_pairs(sceptre_object = sceptre_object_lowmoi,\n                                                positive_control_pairs = positive_control_pairs_lowmoi,\n                                                exclude_positive_control_pairs = TRUE)\nhead(discovery_pairs_lowmoi)\n\n  grna_target response_id\n1        ATF2       PCBP3\n2        BRD4       PCBP3\n3        CAV1       PCBP3\n4       CD274       PCBP3\n5        CD86       PCBP3\n6       CMTM6       PCBP3\n\n\nWe also can use construct_trans_pairs() to construct a trans discovery set for the high-MOI, enhancer-targeting CRISPRi dataset. To this end we call construct_trans_pairs(), setting exclude_positive_control_targets to TRUE so as to exclude all positive control gRNA targets from the trans pairs.\n\ndiscovery_pairs_highmoi_trans &lt;- construct_trans_pairs(sceptre_object = sceptre_object_highmoi,\n                                                       positive_control_pairs = positive_control_pairs_highmoi,\n                                                       exclude_positive_control_targets = TRUE)\n\nThe resulting data frame, discovery_pairs_highmoi_trans, maps each candidate enhancer to the entire set of genes.\n\nhead(discovery_pairs_highmoi_trans)\n\n       grna_target     response_id\n1  candidate_enh_1 ENSG00000069275\n2 candidate_enh_10 ENSG00000069275\n3 candidate_enh_11 ENSG00000069275\n4 candidate_enh_12 ENSG00000069275\n5 candidate_enh_13 ENSG00000069275\n6 candidate_enh_14 ENSG00000069275\n\n\nSome users may wish to run both cis and trans analyses on their data. We recommend that such users carry out the sceptre pipeline twice: once using a cis discovery set and once using a trans discovery set.\n\n2.2.3 Reducing the multiplicity burden\nsceptre computes a p-value for each target-response pair in the discovery set. These p-values are subjected to a multiple testing correction procedure (by default, the Benjamini-Hochberg method) to produce a discovery set that controls some notion of aggregate type-I error (by default, the false discovery rate). In general it is good to restrict one’s attention to pairs that are promising or scientifically interesting. Including a large number of uninteresting or “null” pairs (i.e., pairs for which there is no relationship between the target and response) in the discovery set causes the power of the multiple testing correction procedure to decrease, resulting in fewer discoveries."
  },
  {
    "objectID": "set-analysis-parameters.html#side",
    "href": "set-analysis-parameters.html#side",
    "title": "2  Set analysis parameters",
    "section": "\n2.3 Side",
    "text": "2.3 Side\nsceptre can run left-tailed, right-tailed, and two-tailed tests of association. Left-tailed tests assess a decrease in expression, right-tailed tests assess an increase in expression, and two-tailed tests assess an increase or decrease in expression. The parameter side controls the sidedness of the test and can take values \"left\", \"right\", or \"both\". (\"both\" indicates a two-tailed test.) Two-tailed tests typically are the best choice for trans analyses, as the direction of trans relationships generally is uncertain. For cis analyses, on the other hand, the sidedness of the test should be chosen on the basis of the type of genomic element targeted and the CRISPR perturbation modality. The following table summarizes whether a left- or right-tailed test is appropriate for a cis analysis as a function of these variables.\n\nRecommended sidedness of the test as a function of target element and CRISPR modality for cis analyses.\n\n\n\n\n\n\n\nTarget element\nCRISPR modality\nTesting for\nSidedness\n\n\n\nEnhancer\nCRISPRi or CRISPRko\nDecrease in expression\nLeft\n\n\nEnhancer\nCRISPRa\nIncrease in expression\nRight\n\n\nSilencer\nCRISPRi or CRISPRko\nIncrease in expression\nRight\n\n\nSilencer\nCRISPRa\nDecrease in expression\nLeft"
  },
  {
    "objectID": "set-analysis-parameters.html#grna-grouping-strategy",
    "href": "set-analysis-parameters.html#grna-grouping-strategy",
    "title": "2  Set analysis parameters",
    "section": "\n2.4 gRNA grouping strategy",
    "text": "2.4 gRNA grouping strategy\nMultiple gRNAs typically are designed to target a given genomic element. The parameter grna_grouping_strategy controls if and how gRNAs that target the same genomic element are combined. The default gRNA grouping strategy is \"union\". \"union\" constructs a “grouped gRNA” by combining all gRNAs that target a given genomic element via a union operation; this “grouped gRNA” is then tested for association against the responses to which the element is paired. We illustrate this grouping strategy using an example. Suppose that “gRNA 1” and “gRNA 2” target the same genomic element. Suppose that “gRNA 1” is present in the cells indexed 3, 6, 9 and that “gRNA 2” is present in the cells indexed 1, 4, 6, 10. The “grouped gRNA” formed combining “gRNA 1” and “gRNA 2” via the union operation is defined to be present in the cells indexed 1, 3, 4, 6, 9, 10. (See schematic below.) This “grouped gRNA” is then tested against responses as if it were a single gRNA.\n\n\n\n\nSchematic of the \"union\" gRNA grouping strategy. Blue (resp., white) squares indicate cells in which the gRNA is present (resp., absent).\n\n\n\nThe other available gRNA grouping strategy is \"singleton\". The \"singleton\" strategy involves individually testing each gRNA targeting a given element against the responses to which that element is paired. \"singleton\" may be more appropriate than \"union\" for experiments in which gRNA effectiveness is expected to vary considerably across gRNAs. However, \"union\" is the default rather than \"singleton\" because \"union\" tends to yield more powerful results."
  },
  {
    "objectID": "set-analysis-parameters.html#sec-set_analysis_parameters_control_group",
    "href": "set-analysis-parameters.html#sec-set_analysis_parameters_control_group",
    "title": "2  Set analysis parameters",
    "section": "\n2.5 Control group",
    "text": "2.5 Control group\nThe primary goal of sceptre is to test for association between a given gRNA target and response. control_group is a parameter that controls the set of cells used to carry out the test of association. Suppose for simplicity that we are carrying out a singleton analysis, i.e. suppose that we are testing for association between an individual targeting gRNA and a response. We define the “treatment group” as the set of cells that contain the given targeting gRNA, and we define the “control group” as the set of cells against which the treatment group is compared to conduct the association test. There are two choices for the control group: the “complement set” and the “non-targeting (NT) cells.” The complement set consists of the cells that do not contain the given targeting gRNA; the NT cells, by contrast, consist of the cells that contain a non-targeting gRNA. (See schematic below.) sceptre tests for association between the given targeting gRNA and the response by testing for differential expression of the response across the treatment group and the control group. Users can select the control group to use by passing either \"complement\" or \"nt_cells\" to control_group.\n\n\n\n\nA schematic illustrating the difference between the “complement set” and “NT cells” control groups. The single-cell CRISPR screen experiment produces a pool of cells containing both targeting and non-targeting gRNAs (top). Suppose that we seek to test for association between a given targeting gRNA (e.g., gRNA \\(T_2\\)) and a given response. We first divide the cells into two groups: the treatment group (i.e., the cells containing gRNA \\(T_2\\)) and the control group. The control group either can consist of the cells not containing gRNA \\(T_2\\) (the “complement set”) or the cells containing a non-targeting gRNA (the “NT cells”). sceptre tests for differential expression of the given response across the treatment and control groups, yielding a p-value for the test of association between the given targeting gRNA and the given response.\n\n\n\nThe choice of the control group should be made on the basis of the MOI of the dataset and the type of genomic element being targeted. In high-MOI screens each cell contains multiple gRNAs. Very few (if any) cells contain exclusively NT gRNAs, and so the complement set is the only choice for the control group. In low-MOI screens there is more flexibility. The default choice for the control group is the NT cells, as we seek to compare the effect of the targeting gRNA to that of a “null” gRNA rather than to the average of the effects of all other gRNAs introduced in the pooled screen. However, the complement set is a reasonable choice for low-MOI enhancer-targeting screens, as gRNAs in enhancer-targeting screens tend to exert small and local effects, rendering the average effect over gRNAs in the complement set similar to that of a “null” gRNA. Thus, we recommend trying both the complement set and the NT cells for the control group in low-MOI enhancer-targeting screens and selecting between these options on the basis of their performance on the negative control and positive control data. The decision tree below summarizes the control group that we recommend selecting as a function of MOI and genomic element targeted.\n\n\n\n\nA decision tree summarizing the control group to select as a function of the MOI of the data and the genomic element targeted. The only option in high-MOI is the complement set. In low-MOI the NT cells are the default option; however, we recommend trying both the complement set and the NT cells for low-MOI enhancer-targeting screens."
  },
  {
    "objectID": "set-analysis-parameters.html#formula",
    "href": "set-analysis-parameters.html#formula",
    "title": "2  Set analysis parameters",
    "section": "\n2.6 Formula",
    "text": "2.6 Formula\nThe parameter formula_object specifies how sceptre is to adjust for the cell-specific covariates. formula_object is optional; if not provided, set_analysis_parameters() constructs a default formula_object. The default formula_object is formed by summing over all covariates and log-transforming the count-based covariates. For example, the high-MOI CRISPRi data contain the cell-specific covariates response_n_nonzero, response_n_umis, grna_n_nonzero, grna_n_umis, response_p_mito, and batch. The first four of these covariates are count-based. Thus, the default formula object for this dataset is as follows:\n\nformula(~ log(response_n_nonzero) + log(response_n_umis) +\n          log(grna_n_nonzero) + log(grna_n_umis) + response_p_mito + batch)\n\nSimilarly, the low-MOI CRISPRko data contain the covariates response_n_nonzero, response_n_umis, grna_n_nonzero, grna_n_umis, response_p_mito, and bio_rep. The default formula object for the CRISPRko dataset is as follows:\n\nformula(~ log(response_n_nonzero) + log(response_n_umis) +\n          response_p_mito + batch)\n\n(The covariates grna_n_nonzero and grna_n_umis by default are not included in the formula object, as grna_n_nonzero and grna_n_umis typically do not contain substantial information in low MOI after quality control.)\nUsers can specify a custom formula by passing a formula object to the argument formula_object in set_analysis_parameters(). User-specified formulas should be defined in terms of the cell-specific covariates, which can be viewed by evaluating the sceptre_object in the console."
  },
  {
    "objectID": "set-analysis-parameters.html#sec-set_analysis_parameters_resampling_mech",
    "href": "set-analysis-parameters.html#sec-set_analysis_parameters_resampling_mech",
    "title": "2  Set analysis parameters",
    "section": "\n2.7 Resampling mechanism",
    "text": "2.7 Resampling mechanism\nThe parameter resampling_mechanism controls the inferential procedure that sceptre uses to compute a p-value for a target-response pair. Suppose for simplicity that we are carrying out a singleton gRNA analysis. There are three pieces of information relevant to testing for association between a given gRNA and response: (1) the vector of UMI counts of the response; (2) the “gRNA indicator vector,” where a given entry of the vector is set to “1” if the corresponding cell is part of the treatment group (i.e., it contains the gRNA) and “0” if it is part of the control group; and (3) the matrix of cell-specific covariates. First, sceptre regresses the response vector onto the gRNA indicator vector and covariate matrix via a negative binomial (NB) GLM. sceptre computes the z-score \\(z_\\textrm{obs}\\) corresponding to a test of the null hypothesis that the coefficient corresponding to the gRNA indicator vector in the fitted GLM is zero. Next, sceptre resamples the gRNA indicator vector B times, where B is some large integer (e.g., B = 5000). (We discuss exactly how the gRNA indicator vector is resampled below.) Finally, for each of the resampled gRNA indicator vectors, sceptre recomputes the z-score, producing B “null” z-scores \\(\\tilde{z_1}, \\dots, \\tilde{z_B}\\). The observed z-score \\(z_\\textrm{obs}\\) is compared to the null z-scores \\(\\tilde{z_1}, \\dots, \\tilde{z_B}\\) to compute a p-value.\n\n\n\n\n\n\n\n\nsceptre provides two procedures for resampling the gRNA indicator vector: permutations and conditional resampling (also known as the conditional randomization test). The permutation procedure involves randomly permuting the gRNA indicator vector B times. The conditional resampling procedure is slightly more complex. Briefly, the gRNA indicator vector is regressed onto the covariate matrix via logistic regression, yielding an estimate for the probability that each cell contains the gRNA as a function of the covariates. B synthetic gRNA indicator vectors are then sampled according to these estimated probabilities. The resampling mechanism can be specified by passing either permutations or crt (for conditional resampling) to the argument resampling_mechanism in set_analysis_parameters().\nPermutations and conditional resampling offer distinct advantages and disadvantages, although the differences can be subtle. The permutation approach is faster and slightly better at handling sparsity, while the conditional resampling approach is slightly better at handling confounding due to cell-specific covariates (see table below). In practice the two approaches often produce similar results; we recommend that users try both, provided that they have the bandwidth and compute to do so. The permutation (resp., conditional resampling) procedure is the default option in low-MOI (resp., high-MOI). (Note that both options are available in both MOI settings.)\n\n\n\n\n\n\n\nResampling procedure\nAdvantages\nDisadvantages\n\n\n\nPermutations\n\nFaster\nBetter at handling sparsity\n\n\nWorse at handling confounding\n\n\n\nConditional resampling\n\nBetter at handling confounding\n\n\nSlower\nWorse at handling sparsity\n\n\n\n\nResampling forms the foundation of statistical inference within the sceptre framework. In fact, “sceptre” is a loose acronym for “single cell perturbation analysis via resampling.” The resampling machinery of sceptre is reasonably fast due to several algorithmic advances, including the technique of resampling score statistics and a novel sparsity-exploiting algorithm for computing GLM score tests."
  },
  {
    "objectID": "set-analysis-parameters.html#sec-set_analysis_parameters_parametric_curve",
    "href": "set-analysis-parameters.html#sec-set_analysis_parameters_parametric_curve",
    "title": "2  Set analysis parameters",
    "section": "\n2.8 Fit parametric curve",
    "text": "2.8 Fit parametric curve\nAs described above, for a given gRNA-response pair, sceptre computes an “observed” z-score \\(z_\\textrm{obs}\\) and a set of “null” z-scores \\(\\tilde{z_1}, \\dots, \\tilde{z_B}\\) (regardless of whether resampling_mechanism is set to permutations or crt). By default, sceptre fits a parametric density (specifically, a skew-normal density) to the distribution of null z-scores and then computes a p-value by evaluating the tail probability of the fitted density at the observed z-score \\(z_\\textrm{obs}\\) (see figure below). The parametric density functionality can be deactivated by setting fit_parametric_curve to FALSE in set_analysis_parameters(), in which case a p-value is computed by directly comparing the observed z-score to the null z-scores.\n\n\n\n\n\n\n\n\nWhen fit_parametric_curve is set to FALSE, sceptre must compute a greater number of “null” test statistics to maintain p-value precision. Thus, setting fit_parametric_curve to FALSE increases compute (in some cases substantially). We recommend setting fit_parametric_curve to FALSE only when the negative control p-values exhibit miscalibration."
  },
  {
    "objectID": "set-analysis-parameters.html#multiple-testing-method-and-multiple-testing-alpha",
    "href": "set-analysis-parameters.html#multiple-testing-method-and-multiple-testing-alpha",
    "title": "2  Set analysis parameters",
    "section": "\n2.9 Multiple testing method and multiple testing \\(\\alpha\\)\n",
    "text": "2.9 Multiple testing method and multiple testing \\(\\alpha\\)\n\nAfter sceptre is deployed to analyze the discovery pairs and negative control pairs, the resulting p-values are subjected to a multiplicity adjustment. The adjusted p-values are thresholded to call each pair as “significant” or “not significant.” The parameter multiple_testing_method controls the multiple testing method that is used to adjust the p-values. The default option is Benjamini-Hochberg (\"BH\"); other available methods can be viewed via a call to p.adjust.methods.\nThe parameter multiple_testing_alpha (default value 0.1) controls the level of the multiple testing procedure. If multiple_testing_method is set to a method that controls that false discovery rate (e.g., \"BH\" or \"BY\"), then multiple_testing_alpha is the nominal false discovery rate. If, on the other hand, multiple_testing_method is set to a method that controls the family-wise error rate (e.g., \"bonferroni\" or \"holm\"), then multiple_testing_alpha is the nominal family-wise error rate."
  },
  {
    "objectID": "set-analysis-parameters.html#setting-the-analysis-parameters",
    "href": "set-analysis-parameters.html#setting-the-analysis-parameters",
    "title": "2  Set analysis parameters",
    "section": "\n2.10 Setting the analysis parameters",
    "text": "2.10 Setting the analysis parameters\nWe set the analysis parameters by calling set_analysis_parameters() on the sceptre_objects, passing discovery_pairs and positive_control_pairs (and, on the high-MOI CRISPRi data, side). We allow all other arguments to take default values.\n\n# high-MOI CRISPRi data\nsceptre_object_highmoi &lt;- set_analysis_parameters(sceptre_object = sceptre_object_highmoi, \n                                                  discovery_pairs = discovery_pairs_highmoi, \n                                                  positive_control_pairs = positive_control_pairs_highmoi,\n                                                  side = \"left\")\n\n# low-MOI CRISPRko data\nsceptre_object_lowmoi &lt;- set_analysis_parameters(sceptre_object = sceptre_object_lowmoi,\n                                                 discovery_pairs = discovery_pairs_lowmoi,\n                                                 positive_control_pairs = positive_control_pairs_lowmoi)\n\nWe can call print() on the resulting sceptre_object, which prints to the console a summary tracking the status of the analysis. Notice that the “Analysis parameters” field of the output contains information about the analysis parameters that we have selected (or that have been set by default).\n\nprint(sceptre_object_highmoi)\n\nAn object of class sceptre_object.\n\nAttributes of the data:\n    • 45919 cells\n    • 526 responses\n    • High multiplicity-of-infection \n    • 70 targeting gRNAs (distributed across 35 targets) \n    • 25 non-targeting gRNAs \n    • 6 covariates (batch, grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito)\n\nAnalysis status:\n    ✓ import_data()\n    ✓ set_analysis_parameters()\n    ✗ assign_grnas()\n    ✗ run_qc()\n    ✗ run_calibration_check()\n    ✗ run_power_check()\n    ✗ run_discovery_analysis()\n\nAnalysis parameters: \n    • Discovery pairs: data frame with 610 pairs\n    • Positive control pairs: data frame with 10 pairs\n    • Sidedness of test: left\n    • N nonzero treatment cells threshold: not specified\n    • N nonzero control cells threshold: not specified\n    • Resampling mechanism: conditional resampling\n    • gRNA grouping strategy: union\n    • Formula object: log(response_n_nonzero) + log(response_n_umis) + log(grna_n_nonzero) + log(grna_n_umis) + batch"
  },
  {
    "objectID": "assign-grnas.html#initialize-the-crispri-and-crisprko-sceptre_objects",
    "href": "assign-grnas.html#initialize-the-crispri-and-crisprko-sceptre_objects",
    "title": "3  Assign gRNAs",
    "section": "\n3.1 Initialize the CRISPRi and CRISPRko sceptre_objects",
    "text": "3.1 Initialize the CRISPRi and CRISPRko sceptre_objects\nWe use the high-MOI CRISPRi and low-MOI CRISPRko data as running examples. We call import_data() and set_analysis_parameters() on the low-MOI CRISPRko data to initialize a sceptre_object called sceptre_object_lowmoi.\n\n# low-MOI CRISPRko data setup\n# 1. import data\nsceptre_object_lowmoi &lt;- import_data(response_matrix = lowmoi_example_data$response_matrix,\n                                     grna_matrix = lowmoi_example_data$grna_matrix,\n                                     extra_covariates = lowmoi_example_data$extra_covariates,\n                                     grna_target_data_frame = lowmoi_example_data$grna_target_data_frame,\n                                     moi = \"low\")\n\n# 2. set analysis parameters\npositive_control_pairs &lt;- construct_positive_control_pairs(sceptre_object_lowmoi)\ndiscovery_pairs &lt;- construct_trans_pairs(sceptre_object = sceptre_object_lowmoi,\n                                         positive_control_pairs = positive_control_pairs)\nsceptre_object_lowmoi &lt;- set_analysis_parameters(sceptre_object = sceptre_object_lowmoi,\n                                                 discovery_pairs = discovery_pairs,\n                                                 positive_control_pairs = positive_control_pairs)\n\nWe do the same for the high-MOI CRISPRi data, creating sceptre_object_highmoi.\n\n# high-MOI CRISPRi setup\n# 1. import data\nsceptre_object_highmoi &lt;- import_data(response_matrix = highmoi_example_data$response_matrix,\n                                      grna_matrix = highmoi_example_data$grna_matrix,\n                                      grna_target_data_frame = grna_target_data_frame_highmoi,\n                                      moi = \"high\",\n                                      extra_covariates = highmoi_example_data$extra_covariates,\n                                      response_names = highmoi_example_data$gene_names)\n# 2. set analysis parameters\npositive_control_pairs &lt;- construct_positive_control_pairs(sceptre_object_highmoi)\ndiscovery_pairs &lt;- construct_cis_pairs(sceptre_object_highmoi,\n                                       positive_control_pairs = positive_control_pairs,\n                                       distance_threshold = 5e6)\nsceptre_object_highmoi &lt;- set_analysis_parameters(sceptre_object = sceptre_object_highmoi,\n                                                  discovery_pairs = discovery_pairs,\n                                                  positive_control_pairs = positive_control_pairs,\n                                                  side = \"left\")\n\nWe are now ready to carry out the gRNA assignment step on both datasets."
  },
  {
    "objectID": "assign-grnas.html#visualize-the-grna-count-distributions",
    "href": "assign-grnas.html#visualize-the-grna-count-distributions",
    "title": "3  Assign gRNAs",
    "section": "\n3.2 Visualize the gRNA count distributions",
    "text": "3.2 Visualize the gRNA count distributions\nA helpful first step in assigning gRNAs to cells is to visualize the gRNA UMI count distributions. As discussed in Section 3 of The whole game, we can use the function plot_grna_count_distributions() to plot the empirical UMI count distribution of one or more gRNAs. plot_grna_count_distributions() takes several arguments: sceptre_object (required), n_grnas_to_plot (optional), grnas_to_plot (optional), and threshold (optional). n_grnas_to_plot is an integer specifying the number of randomly-selected gRNAs to plot. grnas_to_plot is a character vector specifying (by name) one or more specific gRNAs to plot. Finally, threshold is an integer specifying the location at which to draw a dotted vertical line. We call plot_grna_count_distributions() on the low-MOI CRISPRko data, plotting nine random gRNAs.\n\nplot_grna_count_distributions(sceptre_object = sceptre_object_lowmoi,\n                              n_grnas_to_plot = 9)\n\n\n\n\n\nHistograms of the gRNA count distributions for the low-MOI CRISPRko data.\n\n\n\nWe see that the gRNA count distributions exhibit generally bimodal behavior. As discussed in The whole game, this bimodality is due to the phenomenon of background contamination: gRNA reads sometimes map to cells that do not contain the corresponding gRNA. sceptre provides three methods for assigning gRNAs to cells, all of which account for background contamination."
  },
  {
    "objectID": "assign-grnas.html#assign-grnas-to-cells",
    "href": "assign-grnas.html#assign-grnas-to-cells",
    "title": "3  Assign gRNAs",
    "section": "\n3.3 Assign gRNAs to cells",
    "text": "3.3 Assign gRNAs to cells\nWe assign gRNAs to cells to cells by calling the function assign_grnas(). assign_grnas() takes the arguments sceptre_object (required), method (optional), print_progress (optional), and parallel (optional). method is the gRNA assignment method and should be set to \"mixture\", \"maximum\", or \"thresholding\". print_progress (default TRUE) and parallel (default FALSE) are logical values specifying whether to print progress updates and run the function in parallel, respectively. Note that parallel computation is not yet configured for Windows; thus, Windows users either should omit the parallel argument or set parallel to FALSE. Below, we describe the three gRNA assignment strategies in detail.\n\n3.3.1 Mixture method\nThe first gRNA assignment strategy is the \"mixture\" method, which involves assigning gRNAs to cells using a mixture model. The mixture method is the default method for high-MOI screens and is an optional method for low-MOI screens. The method works as follows. First, we fit a latent variable Poisson GLM to the data, regressing the gRNA UMI count vector onto the (latent) gRNA indicator vector and cell-specific covariate matrix. (A given entry of the gRNA indicator vector is defined to be “1” if the gRNA is present in the corresponding cell and “0” otherwise.) We fit the latent variable Poisson GLM using a novel variant of the EM algorithm. The fitted model yields the probability that each cell contains the gRNA; we threshold these probabilities to assign the gRNA to cells. An advantage of the GLM-based mixture modeling approach is that it accounts for cell-specific covariates, such as sequencing depth and batch. For example, cells that are sequenced deeply (and have a large value for grna_n_umis or response_n_umis) generally exhibit higher levels of ambient background contamination; sceptre controls for heterogeneity across cells due to sequencing depth and other factors.\nWe use the mixture assignment method to assign gRNAs to cells on both the high-MOI CRISPRi data and low-MOI CRISPRko data, saving the resulting outputs as sceptre_object_lowmoi_mixture and sceptre_object_highmoi_mixture, respectively.\n\n# high-MOI CRISPRi data\nsceptre_object_highmoi_mixture &lt;- assign_grnas(sceptre_object = sceptre_object_highmoi,\n                                               method = \"mixture\", parallel = TRUE)\n\n\n# low-MOI CRISPRko data\nsceptre_object_lowmoi_mixture &lt;- assign_grnas(sceptre_object = sceptre_object_lowmoi,\n                                              method = \"mixture\", parallel = TRUE)\n\nWe can pass optional, method-specific parameters to assign_grnas() to control precisely how the assignment method is deployed. The relevant parameters for the mixture method include formula_object, n_em_rep, n_nonzero_cells_cutoff, backup_threshold, and probability_threshold. formula_object is a formula object that specifies how sceptre is to adjust for the cell-specific covariates in the latent-variable gRNA count model. The default formula object is constructed by summing over all covariates and then log-transforming the count-based covariates. It is sometimes helpful to exclude covariates from the formula object so as to improve the speed of the gRNA assignment step. For example, we define a reduced formula object formula_object_reduced that includes only grna_n_nonzero and grna_n_umis, the two most important covariates for assigning gRNAs to cells.\n\nformula_object_reduced &lt;- formula(~log(grna_n_nonzero) + log(grna_n_umis))\n\nn_em_rep is the number of times to run the EM algorithm using random starting estimates (default: n_em_rep = 5). Setting n_em_rep to a larger integer can improve the accuracy of the gRNA assignments at the cost of increasing compute. n_nonzero_cells_cutoff is the minimum number of cells that must exhibit nonzero expression of the gRNA to attempt fitting a mixture model to the gRNA count distribution (default: n_nonzero_cells_cutoff = 10). If the gRNA is expressed in fewer than n_nonzero_cells_cutoff cells, the gRNA instead is assigned to cells via the thresholding method, where the threshold used is backup_threshold (default: backup_threshold = 5). (See below for a detailed discussion of the thresholding method.) Finally, cells whose estimated probability of having received a gRNA exceeds probability_threshold are called as containing the gRNA (default: probability_threshold = 0.8). In practice probability_threshold typically does not impact the results considerably.\nTo illustrate use of these method-specific parameters, we again call assign_grnas() to assign gRNAs to cells on the high-MOI CRISPRi data, this time setting formula_object to formula_object_reduced.\n\nsceptre_object_highmoi_mixture &lt;- assign_grnas(sceptre_object = sceptre_object_highmoi,\n                                               formula_object = formula_object_reduced,\n                                               parallel = TRUE)\n\n\n3.3.2 Maximum method\nThe second gRNA assignment strategy is the \"maximum\" method. The maximum method is the default assignment method for low-MOI screens and is not available as an option for high-MOI screens. The maximum method assigns the gRNA that accounts for the greatest number of UMIs in a given cell to that cell. We apply the maximum method to the low-MOI CRISPRko data below.\n\nsceptre_object_lowmoi_maximum &lt;- assign_grnas(sceptre_object_lowmoi, method = \"maximum\")\n\nThe maximum method allows for one optional argument: umi_fraction_threshold (default: umi_fraction_threshold = 0.8). Cells for which the maximally expressed gRNA constitutes fewer than umi_fraction_threshold of the UMIs in that cell are flagged as containing multiple gRNAs. (Cells containing multiple gRNAs are removed as part of low-MOI quality control step, as discussed later). For example, if the maximally expressed gRNA in a given cell makes up 0.64 (or 64\\(\\%\\)) of the UMIs in that cell, then that cell is flagged as containing multiple gRNAs and is removed during quality control (assuming that umi_fraction_threshold = 0.8).\n\n3.3.3 Thresholding method\nThe third method for assigning gRNAs to cells is the \"thresholding\" method; this method is available in both low- and high-MOI settings. The thresholding method assigns a gRNA to a cell if the UMI count of the gRNA in the cell is greater than or equal to some integer threshold (by default 5). We apply the \"thresholding\" method to both CRISPRi and CRISPRko datasets as follows.\n\n# high-MOI CRISPRi data\nsceptre_object_highmoi_thresholding &lt;- assign_grnas(sceptre_object = sceptre_object_highmoi,\n                                                    method = \"thresholding\")\n# low-MOI CRISPRko data\nsceptre_object_lowmoi_thresholding &lt;- assign_grnas(sceptre_object = sceptre_object_lowmoi,\n                                                   method = \"thresholding\")\n\nThe thresholding method allows for one optional argument, namely the integer threshold threshold. An important special case is to set threshold to 1, which causes any gRNA expressed in a given cell to be assigned to that cell. We assign gRNAs to cells on the CRISPRi data using a threshold of 1 below.\n\nsceptre_object_highmoi_thresholding &lt;- assign_grnas(sceptre_object = sceptre_object_highmoi,\n                                                    method = \"thresholding\",\n                                                    threshold = 1)\n\nNote that setting threshold to 1 causes background contamination to be ignored."
  },
  {
    "objectID": "assign-grnas.html#plotting-and-printing-the-outcome-of-the-grna-to-cell-assignment-step",
    "href": "assign-grnas.html#plotting-and-printing-the-outcome-of-the-grna-to-cell-assignment-step",
    "title": "3  Assign gRNAs",
    "section": "\n3.4 Plotting and printing the outcome of the gRNA-to-cell assignment step",
    "text": "3.4 Plotting and printing the outcome of the gRNA-to-cell assignment step\nWe can call plot() on the sceptre_object to render a plot summarizing the outcome of the gRNA-to-cell assignment step. plot() takes the arguments sceptre_object (required) n_grnas_to_plot (optional), grnas_to_plot (optional), and return_indiv_plots (optional). n_grnas_to_plot is the number of (randomly-selected) gRNAs to plot; grnas_to_plot is a vector of names of one or more gRNAs to plot; and return_indiv_plots is a logical value indicating whether to return the constituent panels of the plot individually (TRUE) or combined into a single figure (FALSE; default).\nWe visualize the outcome of the gRNA-to-cell assignment step on the low-MOI CRISPRko data based on the maximum assignment strategy. We specifically plot the gRNAs “IFNGR2g2”, “STAT1g2”, and “STAT5Ag4”. (These gRNAs were selected arbitrarily for the purpose of illustrating the grnas_to_plot argument.)\n\ngrnas_to_plot &lt;- c(\"IFNGR2g2\", \"STAT1g2\", \"STAT5Ag4\")\nplot(sceptre_object_lowmoi_maximum, grnas_to_plot = grnas_to_plot)\n\n\n\n\n\nMaximum assignment method on the low-MOI CRISPRko data.\n\n\n\nSection 3 of The whole game describes how to interpret this plot. Briefly, the top panel displays the gRNA-to-cell assignments of several individual gRNAS, and the bottom left panel shows the number of cells per gRNA. Typically, the bottom right panel plots the number of gRNAs per cell, but the bottom right panel is not meaningful under the maximum assignment strategy and is thus omitted.\nIt is informative to compare the output of multiple gRNA assignment methods and check for consistency across methods. To this end we render a visualization of the gRNA-to-cell assignments on the same dataset, this time based on the mixture method.\n\nplot(sceptre_object_lowmoi_mixture, grnas_to_plot = grnas_to_plot)\n\n\n\n\n\nMixture assignment method on the low-MOI CRISPRko data.\n\n\n\nEncouragingly, the gRNA assignments appear to be highly concordant across the maximum and mixture methods. Suppose that we ultimately choose to use the mixture strategy to assign gRNAs to cells on the low-MOI CRISPRko dataset. We update sceptre_object_lowmoi as follows.\n\nsceptre_object_lowmoi &lt;- sceptre_object_lowmoi_mixture\n\nWe can call print() on sceptre_object_lowmoi to print a summary tracking the progress of the analysis. The field “gRNA-to-cell assignment information” presents information about the gRNA assignment step, including the selected assignment method, the mean number of cells per gRNA, and the mean number of gRNAs per cell.\n\nprint(sceptre_object_lowmoi_mixture)\n\nAn object of class sceptre_object.\n\nAttributes of the data:\n    • 20729 cells\n    • 299 responses\n    • Low multiplicity-of-infection \n    • 101 targeting gRNAs (distributed across 26 targets) \n    • 9 non-targeting gRNAs \n    • 6 covariates (bio_rep, grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito)\n\nAnalysis status:\n    ✓ import_data()\n    ✓ set_analysis_parameters()\n    ✓ assign_grnas()\n    ✗ run_qc()\n    ✗ run_calibration_check()\n    ✗ run_power_check()\n    ✗ run_discovery_analysis()\n\nAnalysis parameters: \n    • Discovery pairs: data frame with 7765 pairs\n    • Positive control pairs: data frame with 9 pairs\n    • Sidedness of test: both\n    • N nonzero treatment cells threshold: not specified\n    • N nonzero control cells threshold: not specified\n    • Control group: non-targeting cells\n    • Resampling mechanism: permutations\n    • gRNA grouping strategy: union\n    • Formula object: log(response_n_nonzero) + log(response_n_umis) + bio_rep\n\ngRNA-to-cell assignment information:\n    • Assignment method: mixture\n    • Mean N cells per gRNA: 205.07\n    • Mean N gRNAs per cell (MOI): 1.09"
  },
  {
    "objectID": "run-qc.html#plot-the-cell-specific-covariates",
    "href": "run-qc.html#plot-the-cell-specific-covariates",
    "title": "4  Run quality control",
    "section": "\n4.1 Plot the cell-specific covariates",
    "text": "4.1 Plot the cell-specific covariates\nA helpful initial step in applying QC is to visualize the distribution of the cell-specific covariates. To this end we call the function plot_covariates(), which creates a histogram of the covariates response_n_nonzero, response_n_umis, and (if applicable) response_p_mito. Cellwise QC removes cells that lie in the extreme right tail of the response_p_mito distribution or that lie in the extreme left or right tail of the response_n_nonzero or response_n_umis distribution. To help guide the selection of QC thresholds, plot_covariates() plots candidate QC thresholds as vertical lines on the histograms. The optional arguments response_n_nonzero_range, response_n_umis_range, and p_mito_threshold control the location of these candidate QC thresholds. response_n_nonzero_range (resp., response_n_umis_range) is a length-two vector of quantiles (default: c(0.01, 0.99)) indicating the location at which to draw candidate QC thresholds on the response_n_nonzero (resp., response_n_umis) histogram. Next, p_mito_threshold is a single numeric value in the interval [0,1] specifying the location at which to draw a candidate QC threshold on the response_p_mito plot. We call plot_covariates() on the high-MOI CRISPRi sceptre_object (i.e., sceptre_object_highmoi), setting p_mito_threshold to 0.075.\n\nplot_covariates(sceptre_object_highmoi, p_mito_threshold = 0.075)\n\n\n\n\n\nPlot of covariates for high-MOI CRISPRi data.\n\n\n\nInspecting these plots (and tinkering with response_n_nonzero_range, response_n_umis_range, and p_mito_threshold as necessary) helps guide the selection of reasonable QC thresholds. In general it is good to clip long, asymmetric tails so as to remove outlier cells. The QC thresholds appear to be drawn at sensible locations on these data.\nWe also call plot_covariates() low-MOI CRISPRko data, again setting p_mito_threshold to 0.075.\n\nplot_covariates(sceptre_object_lowmoi, p_mito_threshold = 0.075)\n\n\n\n\n\nOutcome of QC on low-MOI CRISPRko data.\n\n\n\nThe low-MOI plot is broadly similar to its high-MOI counterpart. In particular, the QC thresholds appear to be drawn at sensible locations."
  },
  {
    "objectID": "run-qc.html#qc-parameters",
    "href": "run-qc.html#qc-parameters",
    "title": "4  Run quality control",
    "section": "\n4.2 QC parameters",
    "text": "4.2 QC parameters\nWe apply QC to a sceptre_object by calling the function run_qc(). run_qc() takes the arguments sceptre_object, response_n_umis_range, response_n_nonzero_range, p_mito_threshold, additional_cells_to_remove, n_nonzero_trt_thresh, and n_nonzero_cntrl_thresh. The only required argument among these is sceptre_object; the rest are set to reasonable defaults.\n\n4.2.1 Cellwise QC parameters\nThe parameters response_n_umis_range, response_n_nonzero_range, p_mito_threshold, and additional_cells_to_remove control cellwise QC. response_n_umis_range (resp., response_n_nonzero_range) is a length-two vector of quantiles (default c(0.01, 0.99)); cells whose response_n_umis (resp., response_n_nonzero) quantile falls outside this range are excluded. Next, p_mito_threshold is a number in the interval [0,1]; cells whose value for response_p_mito falls above this threshold likewise are excluded. (Note that p_mito_threshold is not a quantile but rather an absolute number). Finally, additional_cells_to_remove is an integer vector specifying the (1-based) indices of additional cells to remove. Cells flagged by additional_cells_to_remove are removed before applying any other cellwise QC filer.\n\n4.2.2 Pairwise QC parameters\nThe parameters n_nonzero_trt_thresh and n_nonzero_cntrl_thresh control pairwise QC (i.e., QC at the level of the target-response pair). Recall that for a given target-response pair, we divide the cells into treatment and control groups. The treatment group consists of the cells that contain a gRNA targeting the given target, and the control group consists of the cells against which the treatment cells are compared. (The control group can be either the complement set or NT cells; this choice is governed by the control_group parameter.) We define the “number of nonzero treatment cells” (resp., the “number of nonzero control cells”) as the number of cells in the treatment group (resp., control group) that contain nonzero expression of the response. (We sometimes use the shorthand n_nonzero_trt and n_nonzero_cntrl to refer to the number of nonzero treatment cells and control cells, respectively.) n_nonzero_trt and n_nonzero_cntrl are reasonable metrics of pair quality, with higher quality pairs exhibiting larger values for n_nonzero_trt and n_nonzero_cntrl. The schematic below illustrates the definition of n_nonzero_trt and n_nonzero_cntrl.\n\n\n\n\nDefinition of n_nonzero_trt and n_nonzero_cntrl. Each square represents a cell, and the integer within a square represents the UMI count of the response in the corresponding cell. Some cells belong to the treatment group (blue), and others belong to the control group (red). n_nonzero_trt (resp., n_nonzero_cntrl) is the number of cells in the treatment group (resp., control group) with nonzero expression of the response.\n\n\n\nsceptre tabulates n_nonzero_trt and n_nonzero_cntrl for each target-response pair. Pairs for which n_nonzero_trt is less than n_nonzero_trt_thresh or n_nonzero_cntrl is less than n_nonzero_cntrl_thresh are excluded. Both n_nonzero_trt_thresh and n_nonzero_cntrl_thresh are set to 7 by default."
  },
  {
    "objectID": "run-qc.html#run-qc",
    "href": "run-qc.html#run-qc",
    "title": "4  Run quality control",
    "section": "\n4.3 Run QC",
    "text": "4.3 Run QC\nWe call run_qc() on sceptre_object_highmoi and sceptre_object_lowmoi to run QC on the high-MOI CRISPRi and low-MOI CRISPRko data. In both cases we set p_mito_threshold to 0.075 but otherwise fall back on the default parameter values.\n\nsceptre_object_highmoi &lt;- run_qc(sceptre_object = sceptre_object_highmoi,\n                                 p_mito_threshold = 0.075)\nsceptre_object_lowmoi &lt;- run_qc(sceptre_object = sceptre_object_lowmoi,\n                                 p_mito_threshold = 0.075)\n\nWe can call the function plot() on the resulting sceptre_object to render a visualization of the outcome of the QC step. We call plot() on sceptre_object_lowmoi as an example.\n\nplot(sceptre_object_lowmoi)\n\n\n\n\n\nOutcome of applying cellwise (top) and pairwise (bottom) QC to the low-MOI CRISPRko data.\n\n\n\nWe described in Section 4 of The whole game how to interpret this figure. The top panel displays the percentage of cells removed (vertical axis) as a result of applying the different cellwise QC filters (horizontal axis). For example, over 20\\(\\%\\) of cells were removed because they contain multiple gRNAs, and about 2\\(\\%\\) of cells were removed because they exhibit extremely high or extremely values for response_n_nonzero. Note that the “multiple gRNAs” filter in general is applied only to low-MOI data. Next, the bottom panel plots the set of discovery target-response pairs, where the vertical (resp., horizontal) position of a given pair indicates its n_nonzero_cntrl (resp., n_nonzero_trt) value. Pairs with a sufficiently large value for n_nonzero_cntrl and n_nonzero_trt (colored in green) pass pairwise QC; all other pairs are removed.\nFinally, we call print() on sceptre_object_lowmoi to print a summary of the status of the analysis. The summary contains information about cellwise and pairwise QC; see the first entry under the “Attributes of the data” field and the second two entries under the “Analysis parameters” field.\n\nprint(sceptre_object_lowmoi)\n\nAn object of class sceptre_object.\n\nAttributes of the data:\n    • 20729 cells (15348 after cellwise QC)\n    • 299 responses\n    • Low multiplicity-of-infection \n    • 101 targeting gRNAs (distributed across 26 targets) \n    • 9 non-targeting gRNAs \n    • 6 covariates (bio_rep, grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito)\n\nAnalysis status:\n    ✓ import_data()\n    ✓ set_analysis_parameters()\n    ✓ assign_grnas()\n    ✓ run_qc()\n    ✗ run_calibration_check()\n    ✗ run_power_check()\n    ✗ run_discovery_analysis()\n\nAnalysis parameters: \n    • Discovery pairs: data frame with 7765 pairs (6205 after pairwise QC)\n    • Positive control pairs: data frame with 9 pairs (9 after pairwise QC)\n    • Sidedness of test: both\n    • N nonzero treatment cells threshold: 7\n    • N nonzero control cells threshold: 7\n    • Control group: non-targeting cells\n    • Resampling mechanism: permutations\n    • gRNA grouping strategy: union\n    • Formula object: log(response_n_nonzero) + log(response_n_umis) + bio_rep\n\ngRNA-to-cell assignment information:\n    • Assignment method: maximum\n    • Mean N cells per gRNA: 188.45\n    • Mean N gRNAs per cell (MOI): not computed when using \"maximum\" assignment method\n\n\nUsers may wonder why sceptre does not implement response-wise QC (e.g., filtering out lowly expressed responses). The reason is that pairwise QC is in some sense stronger than response-wise QC. Suppose for example that a given response exhibits zero expression across cells. Target-response pairs containing this response will have an n_nonzero_trt and n_nonzero_cntrl value of zero and thus be filtered out, in effect filtering out the response as well."
  },
  {
    "objectID": "run-calibration-check.html#calibration-check-methodology",
    "href": "run-calibration-check.html#calibration-check-methodology",
    "title": "5  Run calibration check",
    "section": "\n5.1 Calibration check methodology",
    "text": "5.1 Calibration check methodology\nWe begin by describing the methodology underlying the calibration check.\n\n5.1.1 Differential expression paradigm\nThe goal of the calibration check is to test for association between subsets of negative control gRNAs and responses. Suppose for simplicity that we are conducting a singleton analysis, i.e. suppose that we seek to test for association between an individual negative control gRNA and a response. The “treatment group” is the set of cells containing the given non-targeting gRNA, and the “control group” is the set of cells against which the treatment group is compared to carry out the test of association. The control group can be either the complement set or the NT cells. Within the context of the calibration check analysis, the complement set consists of the cells that do not contain the given non-targeting gRNA; the NT cells, on the other hand, consist of the cells that contain any non-targeting gRNA excluding the given non-targeting gRNA that we are testing for association against the response (see schematic below.) sceptre carries out the test of association by testing for differential expression of the response across the treatment and control groups, yielding a p-value.\n\n\n\n\nFigure 1: A schematic illustrating the differential expression paradigm of the calibration check analysis. The single-cell CRISPR screen experiment produces a pool of cells; in this example the cells contain targeting gRNAs and three non-targeting gRNAs (labeled NT\\(_1\\), NT\\(_2\\), and NT\\(_3\\)). Suppose that we seek to test for association between a given non-targeting gRNA (e.g., NT\\(_2\\)) and a response. First, we divide the cells into treatment and control groups, where the treatment group consists of the cells that contain NT\\(_2\\), and the control group can be either the complement set or the NT cells. Within the context of the calibration check analysis, the complement set consists of all cells that do not contain NT\\(_2\\); the NT cells, on the other hand, consist of cells that contain a non-targeting gRNA excluding NT\\(_2\\). (Thus, in this example, the NT cells consist of cells that contain NT\\(_1\\) or NT\\(_3\\).) sceptre tests for differential expression of the given response across the treatment and control groups, yielding a p-value for the test of association bewteen the given non-targeting gRNA and the response.\n\n\n\n\n5.1.2 Constructing the negative control pairs\nThe calibration check involves forming a set of negative control target-response pairs and then testing these pairs for association to ensure control of the false discovery rate. sceptre automatically constructs the negative control pairs, and it does so in such a way that the negative control pairs are highly similar to the discovery pairs, the difference being that the negative control pairs are devoid of biological signal. sceptre builds the negative control pairs as follows. First, sceptre forms “negative control groups” by randomly grouping together distinct sets of negative control gRNAs. For example, in a screen containing nine negative control gRNAs (labeled NT1- NT9), gRNAs NT2, NT5, and NT7 might be assigned randomly to one group, gRNAs NT3, NT6, and NT9 might be assigned randomly to another group, and so on. (See schematic below). The number of negative control gRNAs per group (by default) is set equal to the average number of gRNAs per discovery target. For example, in a screen in which each discovery target is targeted by three gRNAs, each negative control group is formed by randomly putting together three negative control gRNAs. The negative control gRNA groups can (and often do) overlap; for example, a given NT gRNA (e.g., NT2) could be a part of multiple negative control groups.\n\n\n\n\nA schematic illustrating how the negative control target response pairs are constructed. First, negative control gRNA groups are formed by randomly assembling negative control gRNAs into groups of size one or more. Next, the negative control gRNA groups are randomly paired to responses.\n\n\n\nIn a singleton analysis (i.e., an analysis in which we seek to test for association between individual gRNAs and responses), each negative control gRNA is placed into its own negative control group of size one. (Recall that we can prompt sceptre to run a singleton analysis by setting grna_grouping_strategy to \"singleton\" in set_analysis_parameters()). We often use the term “negative control target” interchangeably with “negative control gRNA group.”\nAfter forming the negative control targets, sceptre constructs the set of negative control pairs by randomly pairing the negative control targets to the responses. The number of negative control pairs that sceptre constructs is set equal to the number of pairs in the discovery set (after QC is applied to the discovery pairs). Moreover, the negative control pairs are subjected to the same pairwise QC as the discovery pairs. In this sense the negative control pairs are “matched” to the discovery pairs in three respects: (1) the number of gRNAs contained within each target is the same across the negative control and discovery pairs; (2) the negative control pairs are subjected to the same pairwise QC as the discovery pairs; (3) the number of negative control pairs is equal to the number of discovery pairs.\n\n5.1.3 Analyzing the negative control pairs\nThe calibration check entails testing for association between the negative control targets and the responses to which the negative control targets have been paired. If grna_grouping_strategy is set to \"singleton\", the analysis proceeds as described in the section “Differential expression paradigm.” If grna_grouping_strategy is set to \"union\" (the default), negative control gRNAs contained within a given negative control target are combined via the union operation; this combined gRNA is then tested for association against the responses as if it were a singleton gRNA. Consider again Figure 1 (section “Differential expression paradigm”). Suppose that NT1 and NT2 constitute a given negative control target, and suppose we seek to test for association between this negative control target and a given response. The “treatment group” would be the cells containing either NT1 or NT2. Meanwhile, the “complement set” would consist of cells that do not contain NT1 or NT2. Finally, the “NT cells” would consist of cells containing NT3."
  },
  {
    "objectID": "run-calibration-check.html#running-the-calibration-check",
    "href": "run-calibration-check.html#running-the-calibration-check",
    "title": "5  Run calibration check",
    "section": "\n5.2 Running the calibration check",
    "text": "5.2 Running the calibration check\nWe carry out the calibration check by calling the function run_calibration_check() on the sceptre_object. run_calibration_check() takes the arguments sceptre_object (required), n_calibration_pairs (optional), calibration_group_size (optional), print_progress (optional), and parallel (optional), and output_amount (optional). n_calibration_pairs is the number of negative control target-response pairs to test for association. By default n_calibration_pairs is set to the number of discovery target-response pairs that passes pairwise QC. Next, calibration_group_size is the number of negative control gRNAs to put together to construct each negative control target. By default calibration_group_size is set to the median number of gRNAs per discovery target. Finally, print_progress and parallel control whether to print updates to the console and run the computation in parallel, respectively. We describe the output_amount argument in a subsequent section. Below, we run the calibration check on the high-MOI CRISPRi and low-MOI CRISPRko data, setting parallel to TRUE.\n\nsceptre_object_highmoi &lt;- run_calibration_check(sceptre_object_highmoi, parallel = TRUE)\nsceptre_object_lowmoi &lt;- run_calibration_check(sceptre_object_lowmoi, parallel = TRUE)\n\nWe can plot the outcome of the calibration check by calling plot() on the resulting sceptre_object. We plot the outcome of the calibration check on the low-MOI CRISPRko data.\n\nplot(sceptre_object_lowmoi)\n\n\n\n\n\nOutcome of the calibration check on the low-MOI CRISPRko data.\n\n\n\nWe described Section 5 of The whole game how to interpret this figure. Briefly, the upper left (resp., right) plot is a QQ plot of the negative control p-values on an untransformed (resp., transformed) scale; the p-values should lie predominantly along the diagonal line. The lower left plot is a histogram of the estimated (log-2) fold changes; the histogram should be symmetric and centered about zero. Finally, the lower right panel is a text box displaying the number of false discoveries made on the negative control pairs (after applying the multiple testing adjustment) and the mean estimated (log-2) fold change. Both of these numbers ideally should be close to zero. (It is OK if the number of false discoveries is nonzero; see next section.)\nWe can obtain a data frame containing the results by calling get_result on the sceptre_object, setting analysis to \"run_calibration_check\".\n\ncalibration_result &lt;- get_result(sceptre_object = sceptre_object_lowmoi,\n                                 analysis = \"run_calibration_check\")\nhead(calibration_result)\n\n    response_id          grna_target n_nonzero_trt n_nonzero_cntrl pass_qc\n1:       SLC8B1  NTg4&NTg7&NTg8&NTg9           236             162    TRUE\n2:       UBE2L6 NTg1&NTg5&NTg7&NTg10           982             812    TRUE\n3:       TMEM37  NTg3&NTg4&NTg5&NTg9            46              18    TRUE\n4:       PARPBP NTg3&NTg8&NTg9&NTg10            51              61    TRUE\n5:       MTMR10 NTg1&NTg3&NTg8&NTg10            87             250    TRUE\n6: RP11-799D4.4  NTg2&NTg3&NTg4&NTg7            25              44    TRUE\n        p_value log_2_fold_change significant\n1: 0.0000955005        0.23780413       FALSE\n2: 0.0003396914        0.05625781       FALSE\n3: 0.0004477911        0.56398692       FALSE\n4: 0.0010338764        0.53570790       FALSE\n5: 0.0010732514       -0.39425294       FALSE\n6: 0.0011500039       -0.64984993       FALSE\n\n\nEach row of this data frame corresponds to a negative control target-response pair. The columns response_id and grna_target indicate the response and target that make up a given negative control target-response pair. The individual non-targeting gRNAs that form a negative control target are listed, concatenated into a string via the ampersand (“&”) separator. (For example, the negative control gRNA target “NTg4&NTg7&NTg8&NTg9” was formed by combining the negative control gRNAs NTg4, NTg7, NTg8, and NTg9.) The remaining columns of the data frame are as follows: n_nonzero_trt (the number of nonzero treatment cells of a given pair), n_nonzero_cntrl (the number of nonzero control cells of a given pair), pass_qc (whether a given pair passes pairwise QC), p_value (the p-value of a given pair), log_2_fold_change (the estimated log-2 fold change of a given pair), and significant (whether a given pair is called as significant after applying the multiple testing correction adjustment)."
  },
  {
    "objectID": "run-calibration-check.html#diagnosing-miscalibration",
    "href": "run-calibration-check.html#diagnosing-miscalibration",
    "title": "5  Run calibration check",
    "section": "\n5.3 Diagnosing miscalibration",
    "text": "5.3 Diagnosing miscalibration\nThe negative control p-values may demonstrate miscalibration, which is a deviation of the p-values from the expected uniform distribution under the null hypothesis. Indicators of miscalibration include (i) the presence of points that lie considerably above or below the diagonal line on the negative control QQ plots and (ii) a large number of false discoveries on the negative control data. Miscalibration is problematic because it suggests that sceptre is not controlling the rate of false discoveries on the dataset under analysis. Miscalibration can be more or less severe; the table below provides a rough guideline for interpreting miscalibration severity as a function of the number of false discoveries made on the negative control data.\n\n\nTable 5.1: Calibration quality as a (rough) function of the number of false discoveries made on the negative control data in the calibration check analysis.\n\nNumber of false discoveries\nCalibration quality\n\n\n\n0-1\nExcellent calibration\n\n\n2-6\nMild miscalibration\n\n\n7-14\nModerate miscalibration\n\n\n15+\nSevere miscalibration\n\n\n\n\nThere are three main reasons that sceptre might be miscalibrated on a single-cell CRISPR screen dataset: sparsity, the absence of relevant covariates, and model misspecification (Barry et al., 2023). First, sparsity — which refers to the presence of a large proportion of zeros in the response UMI count vector — can cause the skew-normal approximation to the distribution of the null test statistics to break down, which in turn can result in p-value miscalibration. Second, the absence of important covariates (such as batch) from the model likewise can result in miscalibrated p-values. A final possible cause of miscalibration is misspecification of the negative binomial GLM underlying sceptre (due, for example, to the presence of outlier cells). Pairwise and cellwise QC (Chapter 4) provide the first line of defense against sparsity and model misspecification. Additionally, the resampling methodology of sceptre protects against misspecification of the negative binomial GLM. In spite of these safeguards, sceptre may exhibit miscalibration on some datasets.\nTo illustrate the phenomenon of miscalibration, we again run the calibration check on the high-MOI CRISPRi data, this time excluding several important covariates from the formula object. In particular, we set formula_object to formula(~log(grna_n_umis)) in set_analysis_parameters(), thereby excluding batch, response_n_umis, and other covariates.\n\nsceptre_object_highmoi &lt;- sceptre_object_highmoi |&gt;\n  set_analysis_parameters(discovery_pairs = discovery_pairs,\n                          positive_control_pairs = positive_control_pairs,\n                          side = \"left\",\n                          formula_object = formula(~log(grna_n_umis))) |&gt;\n  run_qc()\n\nsceptre_object_highmoi &lt;- run_calibration_check(sceptre_object_highmoi,\n                                                parallel = TRUE)\n\nWe create a plot to visualize the outcome of the calibration check analysis.\n\nplot(sceptre_object_highmoi)\n\n\n\n\n\nRemoving several covariates results in mild miscalibration on the high-MOI CRISPRi data.\n\n\n\nThe negative control p-values no longer lie along the diagonal line in the QQ plots; a handful of p-values in the tail of the distribution, for example, trends markedly above the diagonal. Moreover, there are five false discoveries. This is an example of mild miscalibration, per Table 5.1.\nWhat should one do if sceptre exhibits miscalibration on one’s dataset?"
  },
  {
    "objectID": "run-calibration-check.html#improving-calibration",
    "href": "run-calibration-check.html#improving-calibration",
    "title": "5  Run calibration check",
    "section": "\n5.4 Improving calibration",
    "text": "5.4 Improving calibration\nThere are several concrete steps that users can take to improve the calibration of sceptre. We list five of the most important strategies here, ordered roughly from most to least promising. These strategies need not be applied one-at-a-time and instead can be mixed and matched.\n\n\nDeactivate the parametric curve fitting functionality. sceptre by default computes the p-value for a given target-response pair by fitting a parametric curve (specifically, a skew-normal density) to the distribution of null test statistics and then evaluating the tail probability of the fitted curve at the observed test statistic. (See Section 2.8.) If the parametric curve provides a poor fit to the distribution of the null test statistics, the resulting p-value can be miscalibrated. Users can deactivate the parametric curve fitting functionality of sceptre and instead return an exact p-value by setting fit_parametric_curve to FALSE in set_analysis_parameters(), as follows.\n\nsceptre_object_highmoi &lt;- sceptre_object_highmoi |&gt;\n  set_analysis_parameters(discovery_pairs = discovery_pairs,\n                          positive_control_pairs = positive_control_pairs,\n                          side = \"left\",\n                          fit_parametric_curve = FALSE) # fit_parametric_curve set to FALSE\n\nThe calibration check, power check, and discovery analyses all run more slowly when fit_parametric_curve is set to FALSE, as sceptre must compute a greater number of null test statistics to preserve adequate precision of the p-values. Thus, setting fit_parametric_curve to FALSE may not be a feasible strategy for users seeking to test a large number (e.g., 10,000+) of pairs. Users should consider using the permutation test (resampling_mechaism = \"permutations\") rather than the conditional randomization test (resampling_mechanism = \"crt\") when setting fit_parametric_curve to FALSE to improve speed.\n\nsceptre_object_highmoi &lt;- sceptre_object_highmoi |&gt;\n  set_analysis_parameters(discovery_pairs = discovery_pairs,\n                          positive_control_pairs = positive_control_pairs,\n                          side = \"left\",\n                          fit_parametric_curve = FALSE, # slows down the code\n                          resampling_mechanism = \"permutations\") # speeds up the code\n\n\nAdd additional covariates. sceptre may be miscalibrated because important covariates are missing. Users should consider whether any additional covariates are relevant and, if so, add these covariates to the sceptre_object via import_data() or import_data_from_cellranger(). For example, cell type should be included as a covariate if the data contain multiple cell types. Batch, biological replicate, and cell cycle also may be relevant. (sceptre does not currently provide functionality for imputing cell type or cycle.)\n\nTighten the QC thresholds. Users can tighten the cellwise and pairwise QC thresholds to remove outlier cells and target-response pairs with a low effective sample size, respectively, thereby ameliorating challenges to calibration due to sparsity and model misspecification. Below, we increase n_nonzero_trt_thresh and n_nonzero_cntrl_thresh to 15; the default value for these parameters is 10. We additionally set response_n_umis_range to c(0.05, 0.95), which clips the response_n_umis distribution at the fifth and ninety-fifth percentiles (as opposed the the first and ninety-ninth percentiles, which is the default).\n\nsceptre_object_highmoi &lt;- sceptre_object_highmoi |&gt;\n  run_qc(n_nonzero_trt_thresh = 10L,\n         n_nonzero_cntrl_thresh = 10L,\n         response_n_umis_range = c(0.05, 0.95))\n\n\n\nChange the resampling mechanism or the control group. sceptre provides two options for the resampling mechanism (namely, \"permutations\" or \"crt\"; see Section 2.7) and two options for the control group (namely, \"complement_set\" or \"nt_cells\"; see Section 2.5). (Note that \"nt_cells\" is available as an option only in low-MOI screens.) Switching the resampling mechanism and/or control group may improve calibration. Below, we set the resampling mechanism to \"crt\" and the control group to \"complement_set\" on the low-MOI CRISPRko data; these choices are the opposite of the defaults.\n\nsceptre_object_lowmoi &lt;- sceptre_object_lowmoi |&gt;\n set_analysis_parameters(sceptre_object = sceptre_object_lowmoi,\n                         discovery_pairs = discovery_pairs_lowmoi,\n                         positive_control_pairs = positive_control_pairs_lowmoi,\n                         resampling_mechanism = \"crt\",\n                         control_group = \"complement_set\")\n\n\n\nTest fewer pairs. Obtaining good calibration becomes increasingly challenging as the number of target-response pairs in the discovery set grows. This is because the p-values must maintain a uniform distribution further and further into the tail of the distribution. A simple strategy to improve calibration is to reduce the number of target-response pairs by more aggressively filtering pairs for inclusion in the discovery set. For example, we could construct the discovery set for the high-MOI CRISPRi data by coupling each candidate enhancer to the set of genes within one megabase of that candidate enhancer (as opposed to five megabases, as we have done previously). This change reduces the number of pairs in the discovery set (before applying QC) from 610 to 353, which makes obtaining good calibration considerably easier.\n\ndiscovery_pairs &lt;- construct_cis_pairs(sceptre_object_highmoi,\n                                       positive_control_pairs = positive_control_pairs,\n                                       distance_threshold = 1e6) # previous value: 5e6\nsceptre_object_highmoi &lt;- sceptre_object_highmoi |&gt;\n  set_analysis_parameters(discovery_pairs = discovery_pairs,\n                          positive_control_pairs = positive_control_pairs,\n                          side = \"left\") \n\nUsers also could more aggressively prioritize pairs for inclusion in the discovery set by leveraging orthogonal information, such as (single-cell) ATAC-seq or ChIP-seq data."
  },
  {
    "objectID": "acknowledgements.html",
    "href": "acknowledgements.html",
    "title": "6  Acknowledgements",
    "section": "",
    "text": "sceptre was developed by Timothy Barry, Joseph Deutsch, and Eugene Katsevich.\nWe enthusiastically acknowledge Kathryn Roeder, John Morris, Kaishu Mason, Xuran Wang, and Ziang Niu for contributing to the research and development underlying sceptre. We additionally thank the many sceptre users who have provided valuable feedback on early versions of the package."
  }
]