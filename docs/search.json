[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hands-On Single-Cell CRISPR Screen Analysis",
    "section": "",
    "text": "Welcome\nSingle-cell CRISPR screens (e.g., perturb-seq) combine CRISPR genome engineering and single-cell sequencing to survey the effects of genetic perturbations on individual cells. Single-cell CRISPR screens pose enormous potential for unraveling mechanisms underlying disease and accelerating drug discovery. However, the analysis of these screens presents considerable statistical and computational challenges. Hands-On Single-Cell CRISPR Screen Analysis is a step-by-step guide to carrying out statistically rigorous and computationally efficient single-cell CRISPR screen data analysis using the sceptre R package. sceptre was developed by Timothy Barry, Joseph Deutsch, and Eugene Katsevich.\nsceptre is compatible with a broad range of single-cell CRISPR screen experimental designs. In particular, datasets can vary along the following axes: multiplicity of infection (low or high), genomic element targeted (gene or noncoding regulatory element), CRISPR modality (CRISPRko, CRISPRi, CRISPRa, or CRISPR prime or base editing), and molecular readout (gene expression, protein expression, or chromatin accessibility). This book uses two real datasets to illustrate use of sceptre: a high-MOI CRISPRi screen of noncoding regulatory elements and a low-MOI CRISPRko screen of gene transcription start sites.\n\n\nNavigating this book\nUsers should start by reading The whole game, which provides a high-level overview of sceptre. Users who wish to learn more about individual steps of the sceptre pipeline should read the subsequent chapters in order. Finally, we recommend that users consult the Glossary throughout to keep track of the terminology used in this book.\n\n\nAcknowledgments\nWe gratefully acknowledge Kathryn Roeder, John Morris, Kaishu Mason, Xuran Wang, and Ziang Niu for contributing to the research and development underlying sceptre. We additionally thank the many sceptre users who have provided and continue to provide valuable feedback on the package."
  },
  {
    "objectID": "sceptre.html#sec-whole_game_import_data",
    "href": "sceptre.html#sec-whole_game_import_data",
    "title": "The whole game",
    "section": "1. Import data",
    "text": "1. Import data\nThe first step is to import the data. Data can be imported into sceptre from 10X Cell Ranger or Parse outputs, as well as from R matrices. The simplest way to import the data is to read the output of one or more calls to cellranger_count() into sceptre via the function import_data_from_cellranger(). import_data_from_cellranger() requires three arguments: directories, grna_target_data_frame, and moi.\n\n\ndirectories is a character vector specifying the locations of the directories outputted by one or more calls to cellranger_count(). Below, we set the variable directories to the (machine-dependent) location of the example CRISPRi data on disk.\n\ndirectories &lt;- paste0(\n  system.file(\"extdata\", package = \"sceptre\"), \n  \"/highmoi_example/gem_group_\", 1:2\n)\ndirectories # file paths to the example data on your computer\n\n[1] \"/Library/Frameworks/R.framework/Versions/4.2/Resources/library/sceptre/extdata/highmoi_example/gem_group_1\"\n[2] \"/Library/Frameworks/R.framework/Versions/4.2/Resources/library/sceptre/extdata/highmoi_example/gem_group_2\"\n\n\ndirectories points to two directories, both of which store the expression data in matrix market format and contain the files barcodes.tsv.gz, features.tsv.gz, and matrix.mtx.gz.\n\nlist.files(directories[1])\n\n[1] \"barcodes.tsv.gz\" \"features.tsv.gz\" \"matrix.mtx.gz\"  \n\nlist.files(directories[2])\n\n[1] \"barcodes.tsv.gz\" \"features.tsv.gz\" \"matrix.mtx.gz\"  \n\n\n\n\ngrna_target_data_frame is a data frame mapping each individual gRNA to the genomic element that the gRNA targets. grna_target_data_frame contains two required columns: grna_id and grna_target. grna_id is the ID of an individual gRNA, while grna_target is a label specifying the genomic element that the gRNA targets. (Typically, multiple gRNAs are designed to target a given genomic element in a single-cell CRISPR screen.) Non-targeting (NT) gRNAs are assigned a gRNA target label of “non-targeting”. grna_target_data_frame optionally contains the columns chr, start, and end, which give the chromosome, start coordinate, and end coordinate, respectively, of the genomic region that each gRNA targets. We load and examine the grna_target_data_frame corresponding to the example data.\n\ndata(grna_target_data_frame_highmoi)\ngrna_target_data_frame_highmoi[c(1:4, 21:24, 80:83),]\n\n        grna_id      grna_target   chr     start       end\n1  grna_CCGGGCG  ENSG00000069482 chr11  68451943  68451958\n2  grna_TGGCGGC  ENSG00000069482 chr11  68451958  68451974\n3  grna_AAGGCCG  ENSG00000100316 chr22  39715775  39715790\n4  grna_GACGCCG  ENSG00000100316 chr22  39715790  39715806\n21 grna_TCTTGAC  candidate_enh_1  chr1 205720419 205720623\n22 grna_TGATCGC  candidate_enh_1  chr1 205720623 205720828\n23 grna_ATAGGAG candidate_enh_10 chr19  19475680  19475878\n24 grna_GCAGGCA candidate_enh_10 chr19  19475878  19476077\n80 grna_TATTCGT    non-targeting  &lt;NA&gt;        NA        NA\n81 grna_GACCTCC    non-targeting  &lt;NA&gt;        NA        NA\n82 grna_TTTCTCT    non-targeting  &lt;NA&gt;        NA        NA\n83 grna_AATGAGG    non-targeting  &lt;NA&gt;        NA        NA\n\n\nSome gRNAs (e.g., grna_CCGGGCG and grna_TGGCGGC) target gene transcription start sites and serve as positive controls; other gRNAs (e.g., grna_TCTTGAC and grna_TGATCGC) target candidate enhancers, while others still (e.g., grna_TATTCGT and grna_GACCTCC) are non-targeting. Each gene and candidate enhancer in this dataset is targeted by exactly two gRNAs.\n\n\nmoi is a string specifying the multiplicity-of-infection (MOI) of the data, taking values “high” or “low”. A high-MOI (respectively, low-MOI) dataset is one in which the experimenter has aimed to insert multiple gRNAs (respectively, a single gRNA) into each cell. (If a given cell is determined to contain multiple gRNAs in a low-MOI screen, that cell is removed as part of the quality control step, as discussed below.) The example dataset is a high MOI dataset, and so we set moi to “high”.\n\nmoi &lt;- \"high\"\n\n\n\nFinally, we call the function import_data_from_cellranger(), passing directories, grna_target_data_frame, and moi as arguments.\n\nsceptre_object &lt;- import_data_from_cellranger(\n  directories = directories,\n  grna_target_data_frame = grna_target_data_frame_highmoi,\n  moi = moi\n)\n\nimport_data_from_cellranger() returns a sceptre_object, which is an object-based representation of the single-cell CRISPR screen data. Evaluating sceptre_object in the console prints a helpful summary of the data.\n\nsceptre_object\n\nAn object of class sceptre_object.\n\nAttributes of the data:\n    • 45919 cells\n    • 526 responses\n    • High multiplicity-of-infection \n    • 70 targeting gRNAs (distributed across 35 targets) \n    • 25 non-targeting gRNAs \n    • 6 covariates (batch, grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito)\n\n\nSeveral metrics are displayed, including the number of cells, the number of genes (or “responses”), and the number of gRNAs present in the data. sceptre also automatically computes the following cell-specific covariates: grna_n_nonzero (i.e., the number of gRNAs expressed in the cell), grna_n_umis (i.e., the number of gRNA UMIs sequenced in the cell), response_n_nonzero (i.e., the number of responses expressed in the cell), response_n_umis (i.e., the number of response UMIs sequenced in the cell), response_p_mito (i.e., the fraction of transcripts mapping to mitochondrial genes), and batch. (Cells loaded from different directories are assumed to come from different batches.)\nSee Chapter 1 for more details about data import."
  },
  {
    "objectID": "sceptre.html#set-analysis-parameters",
    "href": "sceptre.html#set-analysis-parameters",
    "title": "The whole game",
    "section": "2. Set analysis parameters",
    "text": "2. Set analysis parameters\nThe second step is to set the analysis parameters. The most important analysis parameters are the discovery pairs, positive control pairs, sidedness, and gRNA grouping strategy.\n\n\nDiscovery pairs and positive control pairs. The primary goal of sceptre is to determine whether perturbation of a gRNA target (such as an enhancer) leads to a change in expression of a response (such as gene). We use the term target-response pair to refer to a given gRNA target and response that we seek to test for association (upon perturbation of the gRNA target). A discovery target-response pair is a target-response pair whose association status we do not know but would like to learn. For example, in an experiment in which we aim to link putative enhancers to genes, the discovery target-response pairs might consist of the set of putative enhancers and genes in close physical proximity to one another.\nA positive control (resp., negative control) target-response pair is a target-response pair for which we know that there is (resp., is not) a relationship between the target and the response. Positive control target-response pairs often are formed by coupling a transcription start site to the gene known to be regulated by that transcription start site. Negative control target-response pairs, meanwhile, typically are constructed by pairing negative control gRNAs to one or more responses. (We defer a detailed discussion of negative control pairs to a later section of this chapter.) Discovery pairs are of primary scientific interest, while positive control and negative control pairs serve a mainly technial purpose, helping us verify that the biological assay and statistical methodology are in working order.\nsceptre offers several helper functions to facilitate the construction of positive control and discovery pairs. The function construct_positive_control_pairs() takes as argument a sceptre_object and outputs the set of positive control pairs formed by matching gRNA targets (as contained in the grna_target_data_frame) to response IDs. Positive control pairs are optional and need not be computed.\n\npositive_control_pairs &lt;- construct_positive_control_pairs(sceptre_object)\nhead(positive_control_pairs)\n\n      grna_target     response_id\n1 ENSG00000069482 ENSG00000069482\n2 ENSG00000100316 ENSG00000100316\n3 ENSG00000104131 ENSG00000104131\n4 ENSG00000122026 ENSG00000122026\n5 ENSG00000135821 ENSG00000135821\n6 ENSG00000147669 ENSG00000147669\n\n\nNext, the functions construct_cis_pairs() and construct_trans_pairs() facilitate the construction of cis and trans discovery sets, respectively. construct_cis_pairs() takes as arguments a sceptre_object and an integer distance_threshold and returns the set of response-target pairs located on the same chromosome within distance_threshold bases of one another. positive_control_pairs optionally can be passed to this function, in which case positive control gRNA targets are excluded from the cis pairs. (Note that construct_cis_pairs() assumes that the responses are genes rather than, say, proteins or chromatin-derived features.)\n\ndiscovery_pairs &lt;- construct_cis_pairs(\n  sceptre_object = sceptre_object,\n  positive_control_pairs = positive_control_pairs,\n  distance_threshold = 5e6\n)\ndiscovery_pairs[c(1:4, 101:104),]\n\n         grna_target     response_id\n1    candidate_enh_1 ENSG00000174529\n2    candidate_enh_1 ENSG00000117222\n3    candidate_enh_1 ENSG00000133059\n4    candidate_enh_1 ENSG00000133069\n101 candidate_enh_10 ENSG00000064490\n102 candidate_enh_10 ENSG00000254901\n103 candidate_enh_10 ENSG00000184162\n104 candidate_enh_10 ENSG00000105705\n\n\nconstruct_trans_pairs() constructs the entire set of possible target-response pairs. See Section 2.2.1 and Section 2.2.2 of Set analysis parameters for more information about these functions.\n\n\nSidedness. The parameter side controls whether to run a left-tailed (\"left\"), right-tailed (\"right\"), or two-tailed (\"both\"; default) test. A left-tailed (resp., right-tailed) test is appropriate when testing for a decrease (resp., increase) in expression; a two-tailed test, by contrast, is appropriate when testing for an increase or decrease in expression. A left-tailed test is the most appropriate choice for a CRISPRi screen of enhancers, and so we set side to \"left\".\n\nside &lt;- \"left\"\n\n\ngRNA integration strategy. Typically, multiple gRNAs are designed to target a given genomic element. The parameter grna_integration_strategy controls if and how gRNAs that target the same genomic element are integrated. The default option, \"union\", combines gRNAs that target the same element into a single “grouped gRNA;” this “grouped gRNA” is tested for association against the responses to which the element is paired. grna_integration_strategy also can be set to “singleton,” in which case each gRNA targeting a given element is tested individually against the responses paired to that element. In our analysis we use the default “union” strategy.\n\nFinally, we set the analysis parameters by calling the function set_analysis_parameters(), passing sceptre_object, discovery_pairs, positive_control_pairs, and side as arguments. Note that sceptre_object and discovery_pairs are the only required arguments to this function.\n\nsceptre_object &lt;- set_analysis_parameters(\n  sceptre_object = sceptre_object,\n  discovery_pairs = discovery_pairs,\n  positive_control_pairs = positive_control_pairs,\n  side = side\n)\nprint(sceptre_object) # output suppressed for brevity\n\nSee Chapter 2 for more information about setting the analysis parameters."
  },
  {
    "objectID": "sceptre.html#sec-sceptre_assign_grnas",
    "href": "sceptre.html#sec-sceptre_assign_grnas",
    "title": "The whole game",
    "section": "3. Assign gRNAs to cells (optional)",
    "text": "3. Assign gRNAs to cells (optional)\nThe third step is to assign gRNAs to cells. This step can be skipped, in which case gRNAs are assigned to cells automatically using default options. The gRNA assignment step involves using the gRNA UMI counts to determine which cells contain which gRNAs. We begin by plotting the UMI count distribution of several randomly selected gRNAs via a call to the function plot_grna_count_distributions().\n\nplot_grna_count_distributions(sceptre_object)\n\n\n\n\n\nHistograms of the gRNA count distributions\n\n\n\nThe gRNAs display fairly bimodal count distributions. Consider, for example, gRNA_CCTGACA (top left corner). This gRNA exhibits a UMI count of \\(\\leq 1\\) or \\(\\geq 5\\) in most cells and a UMI count of 2, 3, or 4 in only a handful of cells. The vast majority of cells with a UMI count of 1 likely do not actually contain gRNA_CCTGACA. This is an example of “background contamination,” the phenomenon by which gRNA transcripts sometimes map to cells that do not contain the corresponding gRNA.\nsceptre provides three methods for assigning gRNAs to cells (the “mixture method,” the “maximum method,” and the “thresholding method”), all of which account for background contamination. The default method for high-MOI data is the “mixture method.” The gRNA counts are regressed onto the (unobserved) gRNA presence/absence indicator and the cell-specific covariates (e.g., grna_n_umis, batch) via a latent variable Poisson GLM. The fitted model yields the probability that each cell contains the gRNA, and these probabilities are thresholded to assign the gRNA to cells. The default method in low-MOI is the simpler “maximum” approach: the gRNA that accounts for the greatest number of UMIs in a given cell is assigned to that cell. A backup option in both low- and high-MOI is the “thresholding” approach: a given gRNA is assigned to a given cell if the UMI count of that gRNA in that cell exceeds some integer threshold.\nWe carry out the gRNA assignment step via a call to the function assign_grnas(). assign_grnas() takes arguments sceptre_object (required) and method (optional); the latter argument can be set to \"mixture\", \"maximum\", or \"thresholding\". We parallelize execution of assign_grnas() by setting parallel to TRUE. (Windows users should remove the parallel = TRUE argument, as parallel execution is not yet configured for Windows.)\n\nsceptre_object &lt;- assign_grnas(sceptre_object = sceptre_object, parallel = TRUE)\nprint(sceptre_object) # output suppressed for brevity\n\nWe can call plot() on the resulting sceptre_object to render a plot summarizing the output of the gRNA-to-cell assignment step.\n\nplot(sceptre_object)\n\n\n\n\n\ngRNA-to-cell assignments\n\n\n\nThe top panel plots the gRNA-to-cell assignments of three randomly selected gRNAs. In each plot the points represent cells; the vertical axis indicates the UMI count of the gRNA in a given cell, and the horizontal axis indicates whether the cell has been classified as “perturbed” (i.e., it contains the gRNA) or unperturbed (i.e., it does not contain the gRNA). Perturbed (resp., unperturbed) cells are shown in the left (resp., right) column. The bottom left panel is a barplot of the number of cells to which each gRNA has been mapped. Finally, the bottom right panel is a histogram of the number of gRNAs contained in each cell. The mean number of gRNAs per cell — i.e., the MOI — is displayed in purple text.\nSee Chapter 3 for more information about assigning gRNAs to cells."
  },
  {
    "objectID": "sceptre.html#sec-sceptre_qc",
    "href": "sceptre.html#sec-sceptre_qc",
    "title": "The whole game",
    "section": "4. Run quality control (optional)",
    "text": "4. Run quality control (optional)\nThe fourth step is to run quality control (QC). This step likewise can be skipped, in which case QC is applied automatically using default options. sceptre implements two kinds of QC: cellwise QC and pairwise QC. The former aims to remove low-quality cells, while the latter aims to remove low-quality target-response pairs.\nThe cellwise QC that sceptre implements is standard in single-cell analysis. Cells for which response_n_nonzero (i.e., the number of expressed responses) or response_n_umis (i.e., the number of response UMIs) is extremely high or extremely low are removed. Likewise, cells for which response_p_mito (i.e., the fraction of UMIs mapping to mitochondrial genes) is excessively high are removed. Additionally, in low-MOI, cells that contain multiple gRNAs (as determined during the RNA-to-cell assignment step) are removed. Finally, users optionally can provide a list of additional cells to remove.\nsceptre also implements QC at the level of the target-response pair. For a given pair we define the “treatment cells” as those that contain a gRNA targeting the given target. Next, we define the “control cells” as the cells against which the treatment cells are compared to carry out the differential expression test. We define the “number of nonzero treatment cells” (n_nonzero_trt) as the number of treatment cells with nonzero expression of the response; similarly, we define the “number of nonzero control cells” (n_nonzero_cntrl) as the number of control cells with nonzero expression of the response. sceptre filters out pairs for which n_nonzero_trt or n_nonzero_cntrl falls below some threshold (by default 7).\nWe call the function run_qc() on the sceptre_object to carry out cellwise and pairwise QC. run_qc() has several optional arguments that control the stringency of the various QC thresholds. For example, we set p_mito_threshold = 0.075, which filters out cells whose response_p_mito value exceeds 0.075. (The optional arguments are set to reasonable defaults; the default for p_mito_threshold is 0.2, for instance).\n\nsceptre_object &lt;- run_qc(sceptre_object, p_mito_threshold = 0.075)\nprint(sceptre_object) # output suppressed for brevity\n\nWe can visualize the output of the QC step by calling plot() on the updated sceptre_object.\n\nplot(sceptre_object)\n\n\n\n\n\nCellwise and pairwise quality control\n\n\n\nThe top panel depicts the outcome of the cellwise QC. The various cellwise QC filters (e.g., “N nonzero responses,” “N response UMIs,” “Percent mito”, etc.) are shown on the horizontal axis, and the percentage of cells removed due application of a given QC filter is shown on the vertical axis. Note that a cell can be flagged by multiple QC filters; for example, a cell might have an extremely high response_n_umi value and an extremely high response_n_nonzero value. Thus, the height of the “any filter” bar (which indicates the percentage of cells removed due to application of any filter) need not be equal to the sum of the heights of the other bars. The bottom panel depicts the outcome of the pairwise QC. Each point corresponds to a target-response pair; the vertical axis (resp., horizontal axis) indicates the n_nonzero_trt (resp., n_nonzero_cntrl) value of that pair. Pairs for which n_nonzero_trt or n_nonzero_cntrl fall below the threshold are removed (red), while the remaining pairs are retained (green).\nSee Chapter 4 for more information about QC."
  },
  {
    "objectID": "sceptre.html#sec-sceptre_calibration_check",
    "href": "sceptre.html#sec-sceptre_calibration_check",
    "title": "The whole game",
    "section": "5. Run calibration check",
    "text": "5. Run calibration check\nThe fifth step is to run the calibration check. The calibration check is an analysis that verifies that sceptre controls the rate of false discoveries on the dataset under analysis. The calibration check proceeds as follows. First, negative control target-response pairs are constructed (automatically) by coupling subsets of NT gRNAs to randomly selected responses. Importantly, the negative control pairs are constructed in such a way that they are similar to the discovery pairs, the difference being that the negative control pairs are devoid of biological signal. Next, sceptre is applied to analyze the negative control pairs. Given that the negative control pairs are absent of signal, sceptre should produce approximately uniformly distributed p-values on the negative control pairs. Moreover, after an appropriate multiple testing correction, sceptre should make zero (or very few) discoveries on the negative control pairs. Verifying calibration via the calibration check increases our confidence that the discovery set that sceptre ultimately produces is uncontaminated by excess false positives.\nWe run the calibration check by calling the function run_calibration_check() on the sceptre_object.\n\nsceptre_object &lt;- run_calibration_check(sceptre_object, parallel = TRUE)\nprint(sceptre_object) # output suppressed for brevity\n\nWe can assess the outcome of the calibration check by calling plot() on the resulting sceptre_object.\n\nplot(sceptre_object)\n\n\n\n\n\nCalibration check results\n\n\n\nThe visualization consists of four panels, which we describe below.\n\nThe upper left panel is a QQ plot of the p-values plotted on an untransformed scale. The p-values should lie along the diagonal line, indicating uniformity of the p-values in the bulk of the distribution.\nThe upper right panel is a QQ plot of the p-values plotted on a negative log-10 transformed scale. The p-values again should lie along the diagonal line (with the majority of the p-values falling within the gray confidence band), indicating uniformity of the p-values in the tail of the distribution.\nThe lower left panel is a histogram of the estimated log-2 fold changes. The histogram should be roughly symmetric and centered around zero.\nFinally, the bottom right panel is a text box displaying (i) the number of false discoveries that sceptre has made on the negative control data and (ii) the mean estimated log-fold change. The number of false discoveries should be a small integer like zero, one, two, or three, with zero being ideal. The mean estimated log-fold change, meanwhile, should be a numeric value close to zero; a number in the range [-0.1, 0.1] is adequate.\n\nsceptre may not exhibit good calibration initially, which is OK. See Chapter 5 for more information about the calibration check analysis, including concrete strategies for improving calibration."
  },
  {
    "objectID": "sceptre.html#sec-sceptre_run_power_check",
    "href": "sceptre.html#sec-sceptre_run_power_check",
    "title": "The whole game",
    "section": "6. Run power check (optional)",
    "text": "6. Run power check (optional)\nThe sixth step — which is optional — is to run the power check. The power check involves applying sceptre to analyze the positive control pairs. Given that the positive control pairs are known to contain signal, sceptre should produce significant (i.e., small) p-values on the positive control pairs. The power check enables us to assess sceptre’s power (i.e., its ability to detect true associations) on the dataset under analysis. We run the power check by calling the function run_power_check() on the sceptre_object.\n\nsceptre_object &lt;- run_power_check(sceptre_object, parallel = TRUE)\nprint(sceptre_object) # output suppressed for brevity\n\nWe can visualize the outcome of the power check by calling plot() on the resulting sceptre_object.\n\nplot(sceptre_object)\n\n\n\n\n\nPower check results\n\n\n\nEach point in the plot corresponds to a target-response pair, with positive control pairs in the left column and negative control pairs in the right column. The vertical axis indicates the p-value of a given pair; smaller (i.e., more significant) p-values are positioned higher along this axis (p-values truncated at \\(10^{-20}\\) for visualization). The positive control p-values should be small, and in particular, smaller than the negative control p-values."
  },
  {
    "objectID": "sceptre.html#sec-sceptre_run_discovery_analysis",
    "href": "sceptre.html#sec-sceptre_run_discovery_analysis",
    "title": "The whole game",
    "section": "7. Run discovery analysis",
    "text": "7. Run discovery analysis\nThe seventh and penultimate step is to run the discovery analysis. The discovery analysis entails applying sceptre to analyze the discovery pairs. We run the discovery analysis by calling the function run_discovery_analysis().\n\nsceptre_object &lt;- run_discovery_analysis(sceptre_object, parallel = TRUE)\nprint(sceptre_object) # output suppressed for brevity\n\nWe can visualize the outcome of the discovery analysis by calling plot() on the resulting sceptre_object.\n\nplot(sceptre_object)\n\n\n\n\n\nDiscovery analysis results\n\n\n\nThe visualization consists of four panels.\n\nThe upper left plot superimposes the discovery p-values (blue) on top of the negative control p-values (red) on an untransformed scale.\nThe upper right plot is the same as the upper left plot, but the scale is negative log-10 transformed. The discovery p-values should trend above the diagonal line, indicating the presence of signal in the discovery set. The horizontal dashed line indicates the multiple testing threshold; discovery pairs whose p-value falls above this line are called as significant.\nThe bottom left panel is a volcano plot of the p-values and log fold changes of the discovery pairs. Each point corresponds to a pair; the estimated log-2 fold change of the pair is plotted on the horizontal axis, and the (negative log-10 transformed) p-value is plotted on the vertical axis. The horizontal dashed line again indicates the multiple testing threshold. Points above the dashed line (colored in purple) are called as discoveries, while points below (colored in blue) are called as insignificant.\nThe bottom right panel is a text box displaying the number of discovery pairs called as significant."
  },
  {
    "objectID": "sceptre.html#sec-sceptre_write_outputs_to_directory",
    "href": "sceptre.html#sec-sceptre_write_outputs_to_directory",
    "title": "The whole game",
    "section": "8. Write outputs to directory",
    "text": "8. Write outputs to directory\nThe eighth and final step is to write the outputs of the analysis to a directory on disk. We call the function write_outputs_to_directory(), which takes as arguments a sceptre_object and directory; directory is a string indicating the location of the directory in which to write the results contained within the sceptre_object.\n\nwrite_outputs_to_directory(\n  sceptre_object = sceptre_object, \n  directory = \"~/sceptre_outputs\"\n)\n\nwrite_outputs_to_directory() writes several files to the specified directory: a text-based summary of the analysis (“analysis_summary.txt”), the various plots (“*.png”), and the calibration check, power check, and discovery analysis results (“results_run_calibration_check.rds,” “results_run_power_check.rds,” and “results_run_discovery_analysis.rds,” respectively).\n\nlist.files(\"~/sceptre_outputs\")\n\n [1] \"analysis_summary.txt\"               \"plot_assign_grnas.png\"             \n [3] \"plot_grna_count_distributions.png\"  \"plot_run_calibration_check.png\"    \n [5] \"plot_run_discovery_analysis.png\"    \"plot_run_power_check.png\"          \n [7] \"plot_run_qc.png\"                    \"results_run_calibration_check.rds\" \n [9] \"results_run_discovery_analysis.rds\" \"results_run_power_check.rds\"       \n\n\nWe also can obtain the calibration check, power check, and discovery analysis results in R via a call to the function get_result(), passing as arguments sceptre_object and analysis, where the latter is a string indicating the function whose results we are querying.\n\nresult &lt;- get_result(sceptre_object, analysis = \"run_discovery_analysis\")\n\nThe variable result is a data frame, the rows of which correspond to target-response pairs, and the columns of which are as follows: response_id, grna_target, n_nonzero_trt, n_nonzero_cntrl, pass_qc (a TRUE/FALSE value indicating whether the pair passes pairwise QC), p_value, log_2_fold_change, and significant (a TRUE/FALSE value indicating whether the pair is called as significant).\n\nhead(result)\n\n       response_id      grna_target n_nonzero_trt n_nonzero_cntrl pass_qc\n1: ENSG00000147454 candidate_enh_19           987           38763    TRUE\n2: ENSG00000136938 candidate_enh_20           829           43056    TRUE\n3: ENSG00000165702 candidate_enh_23           421           17129    TRUE\n4: ENSG00000136929 candidate_enh_20           507           30997    TRUE\n5: ENSG00000135046 candidate_enh_25           438           32903    TRUE\n6: ENSG00000106992 candidate_enh_22           693           30172    TRUE\n        p_value log_2_fold_change significant\n1: 4.132597e-39        -0.7299781        TRUE\n2: 3.674875e-37        -0.3377841        TRUE\n3: 2.743547e-31        -0.7788056        TRUE\n4: 7.498748e-24        -0.6062542        TRUE\n5: 1.112902e-18        -0.8483076        TRUE\n6: 1.142874e-14        -0.3438875        TRUE"
  },
  {
    "objectID": "sceptre.html#further-reading",
    "href": "sceptre.html#further-reading",
    "title": "The whole game",
    "section": "Further reading",
    "text": "Further reading\nEach step of the pipeline has its own dedicated chapter. We encourage interested users to read these additional chapters one-by-one to learn more about the various options available at each step of the pipeline, starting with Chapter 1.\nAlso see complete worked examples for the low-MOI CRISPRko and high-MOI CRISPRi data by calling ?sceptre in the console.\n\n\n\n\nGasperini, Molly, Andrew J. Hill, José L. McFaline-Figueroa, Beth Martin, Seungsoo Kim, Melissa D. Zhang, Dana Jackson, et al. 2019. “A Genome-wide Framework for Mapping Gene Regulation via Cellular Genetic Screens.” Cell 176 (1): 377–90."
  },
  {
    "objectID": "import-data.html#import-data-from-an-existing-software-package",
    "href": "import-data.html#import-data-from-an-existing-software-package",
    "title": "1  Import data",
    "section": "\n1.1 Import data from an existing software package",
    "text": "1.1 Import data from an existing software package\nsceptre links up with two programs for upstream processing of single-cell CRISPR screen data: 10X Cell Ranger and the analogous software tool developed by Parse Biosciences. (We refer to the latter program as the “Parse program.”) We describe how to import data from each of these tools below.\n\n1.1.1 Import from 10X Cell Ranger\nSection 1 of The whole game describes how to import data from 10X Cell Ranger. We include a minimal working example here.\n\ndirectories &lt;- paste0(\n  system.file(\"extdata\", package = \"sceptre\"),\n  \"/highmoi_example/gem_group_\", 1:2)\ndata(grna_target_data_frame_highmoi)\nsceptre_object &lt;- import_data_from_cellranger(\n  directories = directories,\n  moi = \"high\",\n  grna_target_data_frame = grna_target_data_frame_highmoi\n)\n\n\n1.1.2 Import from the Parse program (experimental)\nUsers also can import data from the output of the Parse CRISPR Detect platform via the function import_data_from_parse(). import_data_from_parse() takes the arguments gene_mat_fp, grna_mat_fp, all_genes_fp, all_grnas_fp, moi, grna_target_data_frame, and extra_covariates. (Only the latter argument is optional; all others are required.) gene_mat_fp (resp., grna_mat_fp) is a file path to the .mtx file storing the gene (resp., gRNA) expression data. Next, all_genes_fp is a file path to the all_genes.csv file. all_genes.csv is assumed to have columns “gene_id,” “gene_name,” and “genome;” the first two columns are assumed to give the ID and human readable name, respectively, of each gene, and the last column (indicating the genome to which each gene belongs) is ignored. Additionally, all_grnas_fp is a file path to the all_grnas.csv file. all_grnas.csv is assumed to contain columns “gene_id,” “gene_name,” and “genome.” The column “gene_name” is assumed to give the ID of each gRNA; the remaining two columns are ignored. Furthermore, moi is a string indicating the MOI of the dataset and can take values \"low\" or \"high\". Finally, extra_covariates is an optional data frame of extra covariates to pass to sceptre (see below). It is assumed that the data are stored in a single set of files (as opposed to multiple sets of files corresponding to, e.g., different samples).\nimport_data_from_parse() is an experimental function, and the API of this function is subject to change. We expect the API of import_data_from_parse() to solidify as we learn more about the Parse CRISPR detect platform and the structure of the Parse program output. Furthermore, given that the Parse platform is fairly young, we anticipate that the format of the output of the Parse program itself might change.\n\n1.1.3 Add extra covariates\nimport_data_from_cellranger() and input_data_from_parse() compute the covariates grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito, and batch. Users may wish to supply additional covariates (e.g., cell cycle or cell type) to sceptre. To do so, users can pass a data frame extra_covariates containing additional covariates to import_data_from_cellranger() or input_data_from_parse(). Below, we simulate an additional covariate cell_type and pass this covariate as an argument to the data import function.\n\n# simulate an extra covariate, namely cell type\ncell_type &lt;- sample(x = paste0(\"type_\", 1:3), size = 45919, replace = TRUE) |&gt; \n  factor()\nextra_covariates &lt;- data.frame(cell_type = cell_type)\n\n# import data, passing the the extra covariates as an argument\nsceptre_object &lt;- import_data_from_cellranger(\n  directories = directories,\n  moi = \"high\",\n  grna_target_data_frame = grna_target_data_frame_highmoi,\n  extra_covariates = extra_covariates\n)\n\nThe additional covariate of cell_type is printed in the “covariates” field when we evaluate sceptre_object in the console.\n\nsceptre_object\n\nAn object of class sceptre_object.\n\nAttributes of the data:\n    • 45919 cells\n    • 526 responses\n    • High multiplicity-of-infection \n    • 70 targeting gRNAs (distributed across 35 targets) \n    • 25 non-targeting gRNAs \n    • 7 covariates (batch, cell_type, grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito)"
  },
  {
    "objectID": "import-data.html#import-data-from-a-collection-of-r-objects",
    "href": "import-data.html#import-data-from-a-collection-of-r-objects",
    "title": "1  Import data",
    "section": "\n1.2 Import data from a collection of R objects",
    "text": "1.2 Import data from a collection of R objects\nUsers also can import data into sceptre from a specified set of R objects. This data import strategy is most appropriate for users employing less standard data preprocessing pipelines to generate the response and gRNA count matrices. We use the high-MOI CRISPRi data as a working example. We can obtain these data in R matrix and data frame format as follows.\n\ndata(highmoi_example_data)\nresponse_matrix &lt;- highmoi_example_data$response_matrix   # response matrix\ngrna_matrix &lt;- highmoi_example_data$grna_matrix           # grna matrix\nextra_covariates &lt;- highmoi_example_data$extra_covariates # batch information\nresponse_names &lt;- highmoi_example_data$gene_names         # response names\ngrna_target_data_frame &lt;- grna_target_data_frame_highmoi  # gRNA target data frame\n\nWe call the function import_data() to import the data from a collection of R objects. import_data() takes several arguments: response_matrix, grna_matrix, grna_target_data_frame, moi, extra_covariates, and response_names. The following figure summarizes the main inputs to this function.\n\n\n\n\nThe main data objects involved in a single-cell CRISPR screen analysis: a response matrix, a gRNA matrix, a data frame of extra covariates (optional), and a gRNA target data frame.\n\n\n\nWe describe the inputs below.\n\n\nresponse_matrix is the matrix of response UMI counts. The responses should be in the rows and the cells in the columns. The row names of the response_matrix should be the response IDs. The first ten rows and columns of the example response_matrix are as follows.\n\nresponse_matrix[1:10,1:10]\n\n10 x 10 sparse Matrix of class \"dgTMatrix\"\n\nENSG00000069275 4 6 10 9 4 13 8 8 10 8\nENSG00000117222 2 1  . 1 1  . . .  . 1\nENSG00000117266 . .  . . .  . . .  . .\nENSG00000117280 . .  . 1 .  . . .  . 1\nENSG00000133059 . .  . . .  1 . 2  . 1\nENSG00000133065 . .  . . .  . . 2  . 1\nENSG00000133069 . .  . . .  . . .  . .\nENSG00000158711 . .  . . .  . . 1  . .\nENSG00000158715 . .  . . .  . . .  . .\nENSG00000162873 . .  . . .  . . .  . .\n\n\n\n\ngrna_matrix is the matrix of gRNA UMI counts. The gRNAs should be in the rows and the cells in the columns. The row names of grna_matrix should be the gRNA IDs. The first ten rows and columns of the example grna_matrix are as follows.\n\ngrna_matrix[1:10,1:10]\n\n10 x 10 sparse Matrix of class \"dgTMatrix\"\n\ngrna_CCGGGCG . 8 . . .  . . . . .\ngrna_TGGCGGC . . . . .  . . . . .\ngrna_AAGGCCG . . . . .  . . . . .\ngrna_GACGCCG . . . . .  . . . . .\ngrna_CACACCC . . . . . 25 . . . .\ngrna_GCTCACA . . . . .  . . . . .\ngrna_CTCTGAG . . . . .  . . . . .\ngrna_GCGCCCG . . . . .  . . . . .\ngrna_GAGCGTG . . . . .  . . . . .\ngrna_GCTCTGC . . . . .  . . . . .\n\n\nresponse_matrix and grna_matrix should be stored in one of the following formats: matrix, dgTMatrix, dgCMatrix, or dgRMatrix. Note that the columns of response_matrix and grna_matrix are assumed to correspond to the same ordering of cells. Users should make sure to preserve the consistency of column ordering. We recommend that users add cell barcodes as column names for response_matrix and grna_matrix, in which case sceptre checks the consistency of cell ordering.\n\n\ngrna_target_data_frame is the data frame mapping each gRNA to its target. The grna_target_data_frame that we pass to import_data() is exactly the same as the one that we pass to import_data_from_cellranger. See Section 1 of The whole game for more information about this argument.\n\ngrna_target_data_frame[c(1:4, 21:24, 80:83),]\n\n        grna_id      grna_target   chr     start       end\n1  grna_CCGGGCG  ENSG00000069482 chr11  68451943  68451958\n2  grna_TGGCGGC  ENSG00000069482 chr11  68451958  68451974\n3  grna_AAGGCCG  ENSG00000100316 chr22  39715775  39715790\n4  grna_GACGCCG  ENSG00000100316 chr22  39715790  39715806\n21 grna_TCTTGAC  candidate_enh_1  chr1 205720419 205720623\n22 grna_TGATCGC  candidate_enh_1  chr1 205720623 205720828\n23 grna_ATAGGAG candidate_enh_10 chr19  19475680  19475878\n24 grna_GCAGGCA candidate_enh_10 chr19  19475878  19476077\n80 grna_TATTCGT    non-targeting  &lt;NA&gt;        NA        NA\n81 grna_GACCTCC    non-targeting  &lt;NA&gt;        NA        NA\n82 grna_TTTCTCT    non-targeting  &lt;NA&gt;        NA        NA\n83 grna_AATGAGG    non-targeting  &lt;NA&gt;        NA        NA\n\n\n\n\nmoi is a string specifying the MOI of the dataset, either “high” or “low”. This argument serves the same function as it does in import_data_from_cellranger. See Section 1 of The whole game for more information.\n\nmoi &lt;- \"high\"\n\n\n\nextra_covariates (optional) is a data frame specifying cell-specific covariates beyond those that sceptre can compute. import_data() computes the covariates grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, and response_p_mito. import_data() does not compute batch, as import_data() does not have access to batch information. Thus, batch — alongside any other relevant covariates, such as cell type — should be included in the extra_covariates data frame. Note: The rows of extra_covariates are assumed to be in the same order as the columns of response_matrix and grna_matrix. We recommend users add cell barcodes as row names of extra_covariates, in which case sceptre will check the consistency of cell ordering on their behalf.\n\nextra_covariates[c(1:3, 30001:30003),,drop = FALSE]\n\n      batch\n1        b1\n2        b1\n3        b1\n30001    b2\n30002    b2\n30003    b2\n\n\n\n\nresponse_names (optional) is a vector of human-readable response names. response_names is used to determine which of the responses (if any) are mitochondrial genes for the purpose of computing the response_p_mito covariate.\n\nhead(response_names)\n\n[1] \"NUCKS1\"  \"RBBP5\"   \"CDK18\"   \"RAB29\"   \"DSTYK\"   \"SLC41A1\"\n\n\n\n\nWe pass the arguments response_matrix, grna_matrix, grna_target_data_frame, moi, extra_covariates, and response_names to import_data(), which initializes a sceptre_object.\n\nsceptre_object &lt;- import_data(\n  response_matrix = response_matrix,\n  grna_matrix = grna_matrix,\n  grna_target_data_frame = grna_target_data_frame,\n  moi = moi,\n  extra_covariates = extra_covariates,\n  response_names = response_names\n)"
  },
  {
    "objectID": "import-data.html#accessing-the-fields-of-a-sceptre_object",
    "href": "import-data.html#accessing-the-fields-of-a-sceptre_object",
    "title": "1  Import data",
    "section": "\n1.3 Accessing the fields of a sceptre_object\n",
    "text": "1.3 Accessing the fields of a sceptre_object\n\nA sceptre_object is an S4 object. Like all S4 objects, a sceptre_object contains data, both raw data inputted by the user and processed data that sceptre generates by operating on the raw data. The data stored within a sceptre_object can be accessed via the @ operator (e.g., sceptre_object@foo). We recommend against accessing the data stored within a sceptre_object in this way. Instead, users should interact with a sceptre_object via the functions exported by the package. Unfortunately, we are unable"
  },
  {
    "objectID": "set-analysis-parameters.html#positive-control-pairs",
    "href": "set-analysis-parameters.html#positive-control-pairs",
    "title": "2  Set analysis parameters",
    "section": "\n2.1 Positive control pairs",
    "text": "2.1 Positive control pairs\nPositive control pairs are target-response pairs for which we know (or have strong reason to believe) that there is a regulatory relationship between the target and the response. We can use positive control pairs to verify that sceptre (or any association testing method for that matter) is sensitive (i.e., capable of detecting true associations) on the dataset under analysis. We use the function construct_positive_control_pairs() to construct the positive control pairs. construct_positive_control_pairs() takes as an argument a sceptre_object and returns a data frame with columns grna_target and response_id, where gRNA targets and response IDs with matching names are paired. We call construct_positive_control_pairs() on the high-MOI CRISPRi dataset and the low-MOI CRISPRko dataset. In both cases the positive control set consists of transcription start sites paired to the gene regulated by those transcription start sites.\n\npositive_control_pairs_highmoi &lt;- construct_positive_control_pairs(\n  sceptre_object = sceptre_object_highmoi\n)\nhead(positive_control_pairs_highmoi) # high MOI CRISPRi dataset\n\n      grna_target     response_id\n1 ENSG00000069482 ENSG00000069482\n2 ENSG00000100316 ENSG00000100316\n3 ENSG00000104131 ENSG00000104131\n4 ENSG00000122026 ENSG00000122026\n5 ENSG00000135821 ENSG00000135821\n6 ENSG00000147669 ENSG00000147669\n\n\n\npositive_control_pairs_lowmoi &lt;- construct_positive_control_pairs(\n  sceptre_object = sceptre_object_lowmoi\n)\nhead(positive_control_pairs_lowmoi) # low MOI CRISPRko dataset\n\n  grna_target response_id\n1       CMTM6       CMTM6\n2      IFNGR2      IFNGR2\n3        JAK2        JAK2\n4      NFKBIA      NFKBIA\n5       STAT1       STAT1\n6       STAT2       STAT2\n\n\nPositive control pairs need not consist exclusively of gene transcription start sites paired to target genes. For example, enhancer-gene links that have been validated previously (through, e.g., arrayed CRISPR screens) also can serve as positive control pairs. Users can manually append additional positive control pairs to the positive control pair data frame via a call to rbind(). For example, suppose we know on the high-MOI CRISPRi data that candidate_enh_1 regulates gene ENSG00000069482 and that candidate_enh_10 regulates gene ENSG00000135821. We can add these enhancer-gene links to the positive control pair data frame as follows.\n\n# construct data frame of additional positive control pairs\nadditional_positive_control_pairs &lt;-\n  data.frame(grna_target = c(\"candidate_enh_1\", \"candidate_enh_10\"),\n             response_id = c(\"ENSG00000069482\", \"ENSG00000135821\"))\n\n# append additional pairs to positive control data frame\npositive_control_pairs_highmoi_updated &lt;- rbind(positive_control_pairs_highmoi,\n                                                additional_positive_control_pairs)\npositive_control_pairs_highmoi_updated\n\n        grna_target     response_id\n1   ENSG00000069482 ENSG00000069482\n2   ENSG00000100316 ENSG00000100316\n3   ENSG00000104131 ENSG00000104131\n4   ENSG00000122026 ENSG00000122026\n5   ENSG00000135821 ENSG00000135821\n6   ENSG00000147669 ENSG00000147669\n7   ENSG00000155380 ENSG00000155380\n8   ENSG00000176890 ENSG00000176890\n9   ENSG00000187840 ENSG00000187840\n10  ENSG00000196683 ENSG00000196683\n11  candidate_enh_1 ENSG00000069482\n12 candidate_enh_10 ENSG00000135821\n\n\nWe then could supply positive_control_pairs_highmoi_updated instead of positive_control_pairs_highmoi to set_analysis_parameters()."
  },
  {
    "objectID": "set-analysis-parameters.html#discovery-pairs",
    "href": "set-analysis-parameters.html#discovery-pairs",
    "title": "2  Set analysis parameters",
    "section": "\n2.2 Discovery pairs",
    "text": "2.2 Discovery pairs\nDiscovery pairs are target-response pairs whose association status we do not know but seek to learn. Unlike positive control and negative control pairs, which serve a mainly technical purpose, discovery pairs are of primary scientific interest. sceptre provides two helper functions for constructing discovery pairs: construct_cis_pairs() and construct_trans_pairs().\n\n2.2.1 Construct cis pairs\nconstruct_cis_pairs() returns the set of target-response pairs for which the target and response are located on the same chromosome and in close physical proximity to one another. construct_cis_pairs() is a useful pair constructor function for screens that aim to map noncoding regulatory elements (e.g., enhancers or noncoding GWAS variants) to target genes or proteins in cis. construct_cis_pairs() assumes that the columns chr, start, and stop are present in the grna_target_data_frame, giving the chromosome, start position, and end position of the region that each gRNA targets. construct_cis_pairs() takes several arguments: sceptre_object (required) distance_threshold (optional), positive_control_pairs (optional), and response_position_data_frame (optional). By default, construct_cis_pairs() pairs each gRNA target to the set of responses on the same chromosome as that target and within distance_threshold bases of that target. (The default value of distance_threshold is 500,000 bases, or half a megabase.)The positive_control_pairs data frame optionally can be passed to construct_cis_pairs(), in which case the positive control targets (i.e., the entries within the grna_target column of positive_control_pairs) are excluded from the cis pairs. One may want to exclude these from the discovery analysis if these targets are intended for positive control purposes only.\nFinally, response_position_data_frame is an optional data frame containing the columns response_id, chr, and position, where chr and position give the genomic coordinate of each response_id. The default value of response_position_data_frame is gene_position_data_frame_grch38, which is a data frame that ships with sceptre that contains the genomic coordinate of the transcription start site of all genes in the human genome. We print several rows of gene_position_data_frame_grch38 below.\n\ngene_position_data_frame_grch38[c(1:4, 8001:8004),]\n\n       response_id   chr position\n1: ENSG00000243485  chr1    29554\n2: ENSG00000237613  chr1    36081\n3: ENSG00000186092  chr1    65419\n4: ENSG00000239945  chr1    91105\n5: ENSG00000127328 chr12 69738681\n6: ENSG00000166268 chr12 69825227\n7: ENSG00000257241 chr12 69947081\n8: ENSG00000257139 chr12 70180338\n\n\ngene_position_data_frame_grch38 was derived from the GrCh38 (hg19) reference genome, which is the reference genome that all versions of cellranger count released since 2021 have used for alignment. Users can pass their own response_position_data_frame to construct_cis_pairs() if the gene_position_data_frame_grch38 data frame included within sceptre is inadequate for their analysis. For example, some users may wish to map enhancers to proteins in cis. Such users could construct the discovery set by coupling each enhancer to the set of proteins whose corresponding gene is in close physical proximity to that enhancer. In such an analysis response_position_data_frame would be a data frame mapping each protein to the chromosomal position of the transcription start site of its corresponding gene. Note that response_position_data_frame and the chr, start, and stop columns of the grna_target_data_frame should be defined with respect to the same reference genome, as construct_cis_pairs() proceeds by intersecting response_position_data_frame with grna_target_data_frame.\nWe use construct_cis_pairs() to construct the discovery pairs for the high-MOI CRISPRi dataset. We set distance_threshold to 5e6 (i.e., 5 megabases) so as to increase the number of pairs in the discovery set for illustration purposes.\n\ndiscovery_pairs_highmoi &lt;- construct_cis_pairs(\n  sceptre_object = sceptre_object_highmoi,\n  positive_control_pairs = positive_control_pairs_highmoi,\n  distance_threshold = 5e6\n)\n\ndiscovery_pairs_highmoi is a data frame with columns grna_target and response_id; each candidate enhancer is mapped to the set of genes in close proximity to that candidate enhancer.\n\ndiscovery_pairs_highmoi[c(1, 10, 20, 30, 40, 50),]\n\n       grna_target     response_id\n1  candidate_enh_1 ENSG00000174529\n10 candidate_enh_1 ENSG00000117280\n20 candidate_enh_2 ENSG00000143493\n30 candidate_enh_2 ENSG00000136643\n40 candidate_enh_3 ENSG00000142733\n50 candidate_enh_3 ENSG00000117748\n\n\n\n2.2.2 Construct trans pairs\nconstruct_trans_pairs() returns the entire set of possible target-response pairs. construct_trans_pairs() is a useful pair constructor function for analyses in which we seek to conduct a trans analysis, testing each target against each response. construct_trans_pairs() takes as arguments sceptre_object (required), positive_control_pairs (optional), and pairs_to_exclude (optional). By default construct_trans_pairs() returns a data frame with columns grna_target and response_id, where each gRNA target is mapped to each response ID.\nThe optional argument pairs_to_exclude enables the user to remove specific pairs from the trans set and takes values \"none\", \"pc_pairs\", or \"pairs_containing_pc_targets\". If pairs_to_exclude is set to \"none\" (the default), then no pairs are removed from the trans set. Next, if pairs_to_exclude is set to \"pc_pairs\" (and the positive_control_pairs data frame is passed), then then the positive control target-response pairs are excluded from the trans set. Finally, if pairs_to_exclude is set to \"pairs_containing_pc_targets\" (and positive_control_pairs is passed), then all pairs containing a positive control gRNA target are excluded from the trans pairs. (In this sense setting pairs_to_exclude to \"pairs_containing_pc_targets\" is stronger than setting pairs_to_exclude to \"pc_pairs\".) Typically, in gene-targeting (resp., noncoding-regulatory-element-targeting) screens, we want to set pairs_to_exclude to \"pc_pairs\" (resp., \"pairs_containing_pc_targets\"). Below, we call construct_trans_pairs() to construct the discovery set for the low-MOI CRISPRko data.\n\ndiscovery_pairs_lowmoi &lt;- construct_trans_pairs(\n  sceptre_object = sceptre_object_lowmoi,\n  positive_control_pairs = positive_control_pairs_lowmoi,\n  pairs_to_exclude = \"pc_pairs\"\n)\nhead(discovery_pairs_lowmoi)\n\n  grna_target response_id\n1        ATF2       PCBP3\n2        BRD4       PCBP3\n3        CAV1       PCBP3\n4       CD274       PCBP3\n5        CD86       PCBP3\n6       CMTM6       PCBP3\n\n\nWe also can use construct_trans_pairs() to construct a trans discovery set for the high-MOI, enhancer-targeting CRISPRi dataset. To this end we call construct_trans_pairs(), setting pairs_to_exclude to \"pairs_containing_pc_targets\" so as to exclude all positive control gRNA targets from the trans pairs.\n\ndiscovery_pairs_highmoi_trans &lt;- construct_trans_pairs(\n  sceptre_object = sceptre_object_highmoi,\n  positive_control_pairs = positive_control_pairs_highmoi,\n  pairs_to_exclude = \"pairs_containing_pc_targets\"\n)\n\nThe resulting data frame, discovery_pairs_highmoi_trans, maps each candidate enhancer to the entire set of genes.\n\nhead(discovery_pairs_highmoi_trans)\n\n       grna_target     response_id\n1  candidate_enh_1 ENSG00000069275\n2 candidate_enh_10 ENSG00000069275\n3 candidate_enh_11 ENSG00000069275\n4 candidate_enh_12 ENSG00000069275\n5 candidate_enh_13 ENSG00000069275\n6 candidate_enh_14 ENSG00000069275\n\n\nSome users may wish to run both cis and trans analyses on their data. We recommend that such users carry out the sceptre pipeline twice: once using a cis discovery set and once using a trans discovery set. See Section B.5 for more details.\n\n2.2.3 Reducing the multiplicity burden\nsceptre computes a p-value for each target-response pair in the discovery set. These p-values are subjected to a multiple testing correction procedure (by default, the Benjamini-Hochberg method) to produce a discovery set that controls some notion of aggregate type-I error (by default, the false discovery rate). See Section 2.9 for more details on multiple testing. The more pairs that are tested, the more stringest this multiplicity correction is. Therefore, including a large number of uninteresting or “null” pairs (i.e., pairs for which there is no relationship between the target and response) in the discovery set causes the power of the multiple testing correction procedure to decrease, resulting in fewer discoveries. If possible, it is good to restrict one’s attention to pairs that are promising or scientifically interesting a priori."
  },
  {
    "objectID": "set-analysis-parameters.html#side",
    "href": "set-analysis-parameters.html#side",
    "title": "2  Set analysis parameters",
    "section": "\n2.3 Side",
    "text": "2.3 Side\nsceptre can run left-tailed, right-tailed, and two-tailed tests of association. Left-tailed tests assess a decrease in expression, right-tailed tests assess an increase in expression, and two-tailed tests assess an increase or decrease in expression. The parameter side controls the sidedness of the test and can take values \"left\", \"right\", or \"both\". (\"both\" indicates a two-tailed test.) Two-tailed tests typically are the best choice for trans analyses, as the direction of trans relationships generally is uncertain. For cis analyses, on the other hand, the sidedness of the test should be chosen on the basis of the type of genomic element targeted and the CRISPR perturbation modality. The following table summarizes whether a left- or right-tailed test is appropriate for a cis analysis as a function of these variables.\n\nRecommended sidedness of the test as a function of target element and CRISPR modality for cis analyses.\n\n\n\n\n\n\n\nTarget element\nCRISPR modality\nTesting for\nSidedness\n\n\n\nEnhancer\nCRISPRi or CRISPRko\nDecrease in expression\nLeft\n\n\nEnhancer\nCRISPRa\nIncrease in expression\nRight\n\n\nSilencer\nCRISPRi or CRISPRko\nIncrease in expression\nRight\n\n\nSilencer\nCRISPRa\nDecrease in expression\nLeft"
  },
  {
    "objectID": "set-analysis-parameters.html#sec-grna_integration_strategy",
    "href": "set-analysis-parameters.html#sec-grna_integration_strategy",
    "title": "2  Set analysis parameters",
    "section": "\n2.4 gRNA integration strategy",
    "text": "2.4 gRNA integration strategy\nMultiple gRNAs typically are designed to target a given genomic element. The parameter grna_integration_strategy controls if and how gRNAs that target the same genomic element are combined. In most cases, users wish to test whether perturbation of a target impacts the responses to which the target is paired. In these cases, users need to choose a strategy for integrating information across gRNAs that share a given target. If users expect that gRNAs sharing a target will have similar effects, then users should choose grna_integration_strategy = \"union\". If, on the other hand, users expect that gRNAs sharing a target will have substantially different effects (e.g. due to variable gRNA effectiveness), then users should choose grna_integration_strategy = \"bonferroni\". In some cases, users may wish to test each individual gRNA against the responses to which its target is paired. For example, users may wish to assess the variability in the effects of different gRNAs with the same target. In these cases, users should choose grna_integration_strategy = \"singleton\".\n\n\n\n\nSchematic of the choices for gRNA integration strategy.\n\n\n\nThe default option for grna_integration_strategy is \"union\". This strategy constructs a “grouped gRNA” by combining all gRNAs that target a given genomic element via a union operation; this “grouped gRNA” is then tested for association against the responses to which the element is paired. We illustrate this grouping strategy using an example. Suppose that “gRNA 1” and “gRNA 2” target the same genomic element. Suppose that “gRNA 1” is present in the cells indexed 3, 6, 9 and that “gRNA 2” is present in the cells indexed 1, 4, 6, 10. The “grouped gRNA” formed combining “gRNA 1” and “gRNA 2” via the union operation is defined to be present in the cells indexed 1, 3, 4, 6, 9, 10. (See schematic below.) This “grouped gRNA” is then tested against responses as if it were a single gRNA.\n\n\n\n\nSchematic of the \"union\" gRNA grouping strategy. Blue (resp., white) squares indicate cells in which the gRNA is present (resp., absent).\n\n\n\nUsers who wish to run both a singleton analysis and a grouped analysis should consult Section B.5."
  },
  {
    "objectID": "set-analysis-parameters.html#sec-set-analysis-parameters_control_group",
    "href": "set-analysis-parameters.html#sec-set-analysis-parameters_control_group",
    "title": "2  Set analysis parameters",
    "section": "\n2.5 Control group",
    "text": "2.5 Control group\nThe primary goal of sceptre is to test for association between a given gRNA target and response. control_group is a parameter related to the set of cells used to carry out this test of association. Suppose for simplicity that we are carrying out a singleton analysis, i.e. suppose that we are testing for association between an individual targeting gRNA and a response. We define the “treatment group” as the set of cells that contain the given targeting gRNA, and we define the “control group” as the set of cells against which the treatment group is compared to conduct the association test. There are two choices for the control group: the “complement set” and the “non-targeting (NT) cells.” The complement set consists of the cells that do not contain the given targeting gRNA; the NT cells, by contrast, consist of the cells that contain a non-targeting gRNA. (See schematic below.) sceptre tests for association between the given targeting gRNA and the response by testing for differential expression of the response across the treatment group and the control group. Users can select the control group to use by passing either \"complement\" or \"nt_cells\" to control_group.\n\n\n\n\nA schematic illustrating the difference between the “complement set” and “NT cells” control groups. The single-cell CRISPR screen experiment produces a pool of cells containing both targeting and non-targeting gRNAs (top). Suppose that we seek to test for association between a given targeting gRNA (e.g., gRNA \\(T_2\\)) and a given response. We first divide the cells into two groups: the treatment group (i.e., the cells containing gRNA \\(T_2\\)) and the control group. The control group either can consist of the cells not containing gRNA \\(T_2\\) (the “complement set”) or the cells containing a non-targeting gRNA (the “NT cells”). sceptre tests for differential expression of the given response across the treatment and control groups, yielding a p-value for the test of association between the given targeting gRNA and the given response.\n\n\n\nThe choice of the control group should be made on the basis of the MOI of the dataset and the type of genomic element being targeted. In high-MOI screens each cell contains multiple gRNAs. Very few (if any) cells contain exclusively NT gRNAs, and so the complement set is the only choice for the control group. In low-MOI screens there is more flexibility. The default choice for the control group is the NT cells, as we seek to compare the effect of the targeting gRNA to that of a “null” gRNA rather than to the average of the effects of all other gRNAs introduced in the pooled screen. However, the complement set is a reasonable choice for low-MOI enhancer-targeting screens, as gRNAs in enhancer-targeting screens tend to exert small and local effects, rendering the average effect over gRNAs in the complement set similar to that of a “null” gRNA. Thus, we recommend trying both the complement set and the NT cells for the control group in low-MOI enhancer-targeting screens and selecting between these options on the basis of their performance on the negative control and positive control data. The decision tree below summarizes the control group that we recommend selecting as a function of MOI and genomic element targeted.\n\n\n\n\nA decision tree summarizing the control group to select as a function of the MOI of the data and the genomic element targeted. The only option in high-MOI is the complement set. In low-MOI the NT cells are the default option; however, we recommend trying both the complement set and the NT cells for low-MOI enhancer-targeting screens."
  },
  {
    "objectID": "set-analysis-parameters.html#formula",
    "href": "set-analysis-parameters.html#formula",
    "title": "2  Set analysis parameters",
    "section": "\n2.6 Formula",
    "text": "2.6 Formula\nThe parameter formula_object specifies how sceptre is to adjust for the cell-specific covariates. formula_object is optional; if not provided, set_analysis_parameters() constructs a default formula_object. The default formula_object is formed by summing over all covariates and log-transforming the count-based covariates. For example, the high-MOI CRISPRi data contain the cell-specific covariates response_n_nonzero, response_n_umis, grna_n_nonzero, grna_n_umis, response_p_mito, and batch. The first four of these covariates are count-based. Thus, the default formula object for this dataset is as follows:\n\nformula(~ log(response_n_nonzero) + log(response_n_umis) +\n          log(grna_n_nonzero) + log(grna_n_umis) + response_p_mito + batch)\n\nSimilarly, the low-MOI CRISPRko data contain the covariates response_n_nonzero, response_n_umis, grna_n_nonzero, grna_n_umis, response_p_mito, and bio_rep. The default formula object for the CRISPRko dataset is as follows:\n\nformula(~ log(response_n_nonzero) + log(response_n_umis) +\n          response_p_mito + bio_rep)\n\n(The covariates grna_n_nonzero and grna_n_umis by default are not included in the formula object, as grna_n_nonzero and grna_n_umis typically do not contain substantial information in low MOI after quality control.)\nUsers can specify a custom formula by passing a formula object to the argument formula_object in set_analysis_parameters(). User-specified formulas should be defined in terms of the cell-specific covariates, which can be viewed by evaluating the sceptre_object in the console."
  },
  {
    "objectID": "set-analysis-parameters.html#sec-set_analysis_parameters_resampling_mech",
    "href": "set-analysis-parameters.html#sec-set_analysis_parameters_resampling_mech",
    "title": "2  Set analysis parameters",
    "section": "\n2.7 Resampling mechanism",
    "text": "2.7 Resampling mechanism\nThe parameter resampling_mechanism controls the inferential procedure that sceptre uses to compute a p-value for a target-response pair. Suppose for simplicity that we are carrying out a singleton gRNA analysis. There are three pieces of information relevant to testing for association between a given gRNA and response: (1) the vector of UMI counts of the response; (2) the “gRNA indicator vector,” where a given entry of the vector is set to “1” if the corresponding cell is part of the treatment group (i.e., it contains the gRNA) and “0” if it is part of the control group; and (3) the matrix of cell-specific covariates. First, sceptre regresses the response vector onto the gRNA indicator vector and covariate matrix via a negative binomial (NB) GLM. sceptre computes the z-score \\(z_\\textrm{obs}\\) corresponding to a test of the null hypothesis that the coefficient corresponding to the gRNA indicator vector in the fitted GLM is zero. Next, sceptre resamples the gRNA indicator vector B times, where B is some large integer (e.g., B = 5000). (We discuss exactly how the gRNA indicator vector is resampled below.) Finally, for each of the resampled gRNA indicator vectors, sceptre recomputes the z-score, producing B “null” z-scores \\(\\tilde z_1, \\dots, \\tilde z_B\\). The observed z-score \\(z_\\textrm{obs}\\) is compared to the null z-scores \\(\\tilde z_1, \\dots, \\tilde z_B\\) to compute a p-value.\n\n\n\n\n\n\n\n\nsceptre provides two procedures for resampling the gRNA indicator vector: permutations and conditional resampling (also known as the conditional randomization test). The permutation procedure involves randomly permuting the gRNA indicator vector B times. The conditional resampling procedure is slightly more complex (Barry et al. 2021). Briefly, the gRNA indicator vector is regressed onto the covariate matrix via logistic regression, yielding an estimate for the probability that each cell contains the gRNA as a function of the covariates. B synthetic gRNA indicator vectors are then sampled according to these estimated probabilities. The resampling mechanism can be specified by passing either permutations or crt (for conditional resampling) to the argument resampling_mechanism in set_analysis_parameters().\nPermutations and conditional resampling offer distinct advantages and disadvantages, although the differences can be subtle. The permutation approach is faster and slightly better at handling sparsity, while the conditional resampling approach is slightly better at handling confounding due to cell-specific covariates (see table below). In practice the two approaches often produce similar results; we recommend that users try both, provided that they have the bandwidth and compute to do so. The permutation (resp., conditional resampling) procedure is the default option in low-MOI (resp., high-MOI). (Note that both options are available in both MOI settings.)\n\n\n\n\n\n\n\nResampling procedure\nAdvantages\nDisadvantages\n\n\n\nPermutations\n\nFaster\nBetter at handling sparsity\n\n\nWorse at handling confounding\n\n\n\nConditional resampling\n\nBetter at handling confounding\n\n\nSlower\nWorse at handling sparsity\n\n\n\n\nResampling forms the foundation of statistical inference within the sceptre framework. In fact, “sceptre” is a loose acronym for “single cell perturbation analysis via resampling.” The resampling machinery of sceptre is reasonably fast due to several algorithmic advances, including the technique of resampling score statistics and a novel sparsity-exploiting algorithm for computing GLM score tests."
  },
  {
    "objectID": "set-analysis-parameters.html#sec-set_analysis_parameters_parametric_curve",
    "href": "set-analysis-parameters.html#sec-set_analysis_parameters_parametric_curve",
    "title": "2  Set analysis parameters",
    "section": "\n2.8 Fit parametric curve",
    "text": "2.8 Fit parametric curve\nAs described above, for a given gRNA-response pair, sceptre computes an “observed” z-score \\(z_\\textrm{obs}\\) and a set of “null” z-scores \\(\\tilde z_1, \\dots, \\tilde z_B\\) (regardless of whether resampling_mechanism is set to permutations or crt). By default, sceptre fits a parametric density (specifically, a skew-normal density) to the distribution of null z-scores and then computes a p-value by evaluating the tail probability of the fitted density at the observed z-score \\(z_\\textrm{obs}\\) (see figure below). The parametric density functionality can be deactivated by setting fit_parametric_curve to FALSE in set_analysis_parameters(), in which case a p-value is computed by directly comparing the observed z-score to the null z-scores.\n\n\n\n\n\n\n\n\nWhen fit_parametric_curve is set to FALSE, sceptre must compute a greater number of “null” test statistics to maintain p-value precision. Thus, setting fit_parametric_curve to FALSE increases compute (in some cases substantially). We recommend setting fit_parametric_curve to FALSE only when the negative control p-values exhibit miscalibration (see Section 5.4)."
  },
  {
    "objectID": "set-analysis-parameters.html#sec-multiple_testing",
    "href": "set-analysis-parameters.html#sec-multiple_testing",
    "title": "2  Set analysis parameters",
    "section": "\n2.9 Multiple testing method and multiple testing \\(\\alpha\\)\n",
    "text": "2.9 Multiple testing method and multiple testing \\(\\alpha\\)\n\nAfter sceptre is deployed to analyze the discovery pairs and negative control pairs, the resulting p-values are subjected to a multiplicity adjustment. The adjusted p-values are thresholded to call each pair as “significant” or “not significant.” The parameter multiple_testing_method controls the multiple testing method that is used to adjust the p-values. The default option is Benjamini-Hochberg (\"BH\"); other available methods can be viewed via a call to p.adjust.methods.\nThe parameter multiple_testing_alpha (default value 0.1) controls the level of the multiple testing procedure. If multiple_testing_method is set to a method that controls that false discovery rate (e.g., \"BH\" or \"BY\"), then multiple_testing_alpha is the nominal false discovery rate. If, on the other hand, multiple_testing_method is set to a method that controls the family-wise error rate (e.g., \"bonferroni\" or \"holm\"), then multiple_testing_alpha is the nominal family-wise error rate."
  },
  {
    "objectID": "set-analysis-parameters.html#setting-the-analysis-parameters",
    "href": "set-analysis-parameters.html#setting-the-analysis-parameters",
    "title": "2  Set analysis parameters",
    "section": "\n2.10 Setting the analysis parameters",
    "text": "2.10 Setting the analysis parameters\nWe set the analysis parameters by calling set_analysis_parameters() on the sceptre_objects, passing discovery_pairs and positive_control_pairs (and, on the high-MOI CRISPRi data, side). We allow all other arguments to take default values.\n\n# high-MOI CRISPRi data\nsceptre_object_highmoi &lt;- set_analysis_parameters(\n  sceptre_object = sceptre_object_highmoi,\n  discovery_pairs = discovery_pairs_highmoi,\n  positive_control_pairs = positive_control_pairs_highmoi,\n  side = \"left\"\n)\n\n# low-MOI CRISPRko data\nsceptre_object_lowmoi &lt;- set_analysis_parameters(\n  sceptre_object = sceptre_object_lowmoi,\n  discovery_pairs = discovery_pairs_lowmoi,\n  positive_control_pairs = positive_control_pairs_lowmoi\n)\n\nWe can call print() on the resulting sceptre_object, which prints to the console a summary tracking the status of the analysis. Notice that the “Analysis parameters” field of the output contains information about the analysis parameters that we have selected (or that have been set by default).\n\nprint(sceptre_object_highmoi)\n\nAn object of class sceptre_object.\n\nAttributes of the data:\n    • 45919 cells\n    • 526 responses\n    • High multiplicity-of-infection \n    • 70 targeting gRNAs (distributed across 35 targets) \n    • 25 non-targeting gRNAs \n    • 6 covariates (batch, grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito)\n\nAnalysis status:\n    ✓ import_data()\n    ✓ set_analysis_parameters()\n    ✗ assign_grnas()\n    ✗ run_qc()\n    ✗ run_calibration_check()\n    ✗ run_power_check()\n    ✗ run_discovery_analysis()\n\nAnalysis parameters: \n    • Discovery pairs: data frame with 610 pairs\n    • Positive control pairs: data frame with 10 pairs\n    • Sidedness of test: left\n    • N nonzero treatment cells threshold: not specified\n    • N nonzero control cells threshold: not specified\n    • Resampling mechanism: conditional resampling\n    • gRNA integration strategy: union\n    • Formula object: log(response_n_nonzero) + log(response_n_umis) + log(grna_n_nonzero) + log(grna_n_umis) + batch\n\n\n\n\n\n\nBarry, Timothy, Xuran Wang, John A. Morris, Kathryn Roeder, and Eugene Katsevich. 2021. “SCEPTRE improves calibration and sensitivity in single-cell CRISPR screen analysis.” Genome Biology 22 (1): 1–19.\n\n\nPapalexi, Efthymia, Eleni Mimitou, Andrew W. Butler, Samantha Foster, Bernadette Bracken, William M. Mauck III, Hans-Hermann Wessels, Bertrand Z. Yeung, Peter Smibert, and Rahul Satija. 2021. “Characterizing the molecular regulation of inhibitory immune checkpoints with multi-modal single-cell screens.” Nature Genetics 53 (3): 322–31."
  },
  {
    "objectID": "assign-grnas.html#initialize-the-crispri-and-crisprko-sceptre_objects",
    "href": "assign-grnas.html#initialize-the-crispri-and-crisprko-sceptre_objects",
    "title": "3  Assign gRNAs",
    "section": "\n3.1 Initialize the CRISPRi and CRISPRko sceptre_objects",
    "text": "3.1 Initialize the CRISPRi and CRISPRko sceptre_objects\nWe use the high-MOI CRISPRi and low-MOI CRISPRko data as running examples. We call import_data() and set_analysis_parameters() on the low-MOI CRISPRko data to initialize a sceptre_object called sceptre_object_lowmoi.\n\n# low-MOI CRISPRko data setup\n# 1. import data\nsceptre_object_lowmoi &lt;- import_data(\n  response_matrix = lowmoi_example_data$response_matrix,\n  grna_matrix = lowmoi_example_data$grna_matrix,\n  extra_covariates = lowmoi_example_data$extra_covariates,\n  grna_target_data_frame = lowmoi_example_data$grna_target_data_frame,\n  moi = \"low\"\n)\n\n# 2. set analysis parameters\npositive_control_pairs &lt;- construct_positive_control_pairs(sceptre_object_lowmoi)\ndiscovery_pairs &lt;- construct_trans_pairs(\n  sceptre_object = sceptre_object_lowmoi,\n  positive_control_pairs = positive_control_pairs,\n  pairs_to_exclude = \"pc_pairs\"\n)\nsceptre_object_lowmoi &lt;- set_analysis_parameters(\n  sceptre_object = sceptre_object_lowmoi,\n  discovery_pairs = discovery_pairs,\n  positive_control_pairs = positive_control_pairs\n)\n\nWe do the same for the high-MOI CRISPRi data, creating sceptre_object_highmoi.\n\n# high-MOI CRISPRi setup\n# 1. import data\nsceptre_object_highmoi &lt;- import_data(\n  response_matrix = highmoi_example_data$response_matrix,\n  grna_matrix = highmoi_example_data$grna_matrix,\n  grna_target_data_frame = grna_target_data_frame_highmoi,\n  moi = \"high\",\n  extra_covariates = highmoi_example_data$extra_covariates,\n  response_names = highmoi_example_data$gene_names\n)\n# 2. set analysis parameters\npositive_control_pairs &lt;- construct_positive_control_pairs(sceptre_object_highmoi)\ndiscovery_pairs &lt;- construct_cis_pairs(sceptre_object_highmoi,\n  positive_control_pairs = positive_control_pairs,\n  distance_threshold = 5e6\n)\nsceptre_object_highmoi &lt;- set_analysis_parameters(\n  sceptre_object = sceptre_object_highmoi,\n  discovery_pairs = discovery_pairs,\n  positive_control_pairs = positive_control_pairs,\n  side = \"left\"\n)\n\nWe are now ready to carry out the gRNA assignment step on both datasets."
  },
  {
    "objectID": "assign-grnas.html#visualize-the-grna-count-distributions",
    "href": "assign-grnas.html#visualize-the-grna-count-distributions",
    "title": "3  Assign gRNAs",
    "section": "\n3.2 Visualize the gRNA count distributions",
    "text": "3.2 Visualize the gRNA count distributions\nA helpful first step in assigning gRNAs to cells is to visualize the gRNA UMI count distributions. As discussed in Section 3 of The whole game, we can use the function plot_grna_count_distributions() to plot the empirical UMI count distribution of one or more gRNAs. plot_grna_count_distributions() takes several arguments: sceptre_object (required), n_grnas_to_plot (optional), grnas_to_plot (optional), and threshold (optional). n_grnas_to_plot is an integer specifying the number of randomly selected gRNAs to plot. grnas_to_plot is a character vector specifying (by name) one or more specific gRNAs to plot. Finally, threshold is an integer specifying the location at which to draw a dotted vertical line. We call plot_grna_count_distributions() on the low-MOI CRISPRko data, plotting nine random gRNAs.\n\nplot_grna_count_distributions(\n  sceptre_object = sceptre_object_lowmoi,\n  n_grnas_to_plot = 9\n)\n\n\n\n\n\nHistograms of the gRNA count distributions for the low-MOI CRISPRko data.\n\n\n\nWe see that the gRNA count distributions exhibit generally bimodal behavior. As discussed in The whole game, this bimodality is due to the phenomenon of background contamination: gRNA reads sometimes map to cells that do not contain the corresponding gRNA. sceptre provides three methods for assigning gRNAs to cells, all of which account for background contamination."
  },
  {
    "objectID": "assign-grnas.html#assign-grnas-to-cells",
    "href": "assign-grnas.html#assign-grnas-to-cells",
    "title": "3  Assign gRNAs",
    "section": "\n3.3 Assign gRNAs to cells",
    "text": "3.3 Assign gRNAs to cells\nWe assign gRNAs to cells to cells by calling the function assign_grnas(). assign_grnas() takes the arguments sceptre_object (required), method (optional), print_progress (optional), and parallel (optional). method is the gRNA assignment method and should be set to \"mixture\", \"maximum\", or \"thresholding\". print_progress (default TRUE) and parallel (default FALSE) are logical values specifying whether to print progress updates and run the function in parallel, respectively. Note that parallel computation is not yet configured for Windows; thus, Windows users either should omit the parallel argument or set parallel to FALSE. Below, we describe the three gRNA assignment strategies in detail.\n\n3.3.1 Mixture method\nThe first gRNA assignment strategy is the \"mixture\" method, which involves assigning gRNAs to cells using a mixture model (Barry, Roeder, and Katsevich 2022). The mixture method is the default method for high-MOI screens and is an optional method for low-MOI screens. The method works as follows. First, we fit a latent variable Poisson GLM to the data, regressing the gRNA UMI count vector onto the (latent) gRNA indicator vector and cell-specific covariate matrix. (A given entry of the gRNA indicator vector is defined to be “1” if the gRNA is present in the corresponding cell and “0” otherwise.) We fit the latent variable Poisson GLM using a novel variant of the EM algorithm. The fitted model yields the probability that each cell contains the gRNA; we threshold these probabilities to assign the gRNA to cells. An advantage of the GLM-based mixture modeling approach is that it accounts for cell-specific covariates, such as sequencing depth and batch. For example, cells that are sequenced deeply (and have a large value for grna_n_umis or response_n_umis) generally exhibit higher levels of ambient background contamination; sceptre controls for heterogeneity across cells due to sequencing depth and other factors.\nWe use the mixture assignment method to assign gRNAs to cells on both the high-MOI CRISPRi data and low-MOI CRISPRko data, saving the resulting outputs as sceptre_object_lowmoi_mixture and sceptre_object_highmoi_mixture, respectively.\n\n# high-MOI CRISPRi data\nsceptre_object_highmoi_mixture &lt;- assign_grnas(\n  sceptre_object = sceptre_object_highmoi,\n  method = \"mixture\", parallel = TRUE\n)\n\n\n# low-MOI CRISPRko data\nsceptre_object_lowmoi_mixture &lt;- assign_grnas(\n  sceptre_object = sceptre_object_lowmoi,\n  method = \"mixture\", parallel = TRUE\n)\n\nWe can pass optional, method-specific parameters to assign_grnas() to control precisely how the assignment method is deployed. The relevant parameters for the mixture method include formula_object, n_em_rep, n_nonzero_cells_cutoff, backup_threshold, and probability_threshold. formula_object is a formula object that specifies how sceptre is to adjust for the cell-specific covariates in the latent-variable gRNA count model. The default formula object is constructed by summing over all covariates and then log-transforming the count-based covariates. It is sometimes helpful to exclude covariates from the formula object so as to improve the speed of the gRNA assignment step. For example, we define a reduced formula object formula_object_reduced that includes only grna_n_nonzero and grna_n_umis, the two most important covariates for assigning gRNAs to cells.\n\nformula_object_reduced &lt;- formula(~ log(grna_n_nonzero) + log(grna_n_umis))\n\nn_em_rep is the number of times to run the EM algorithm using random starting estimates (default: n_em_rep = 5). Setting n_em_rep to a larger integer can improve the accuracy of the gRNA assignments at the cost of increasing compute. n_nonzero_cells_cutoff is the minimum number of cells that must exhibit nonzero expression of the gRNA to attempt fitting a mixture model to the gRNA count distribution (default: n_nonzero_cells_cutoff = 10). If the gRNA is expressed in fewer than n_nonzero_cells_cutoff cells, the gRNA instead is assigned to cells via the thresholding method, where the threshold used is backup_threshold (default: backup_threshold = 5). (See Section 3.3.3 for a detailed discussion of the thresholding method.) Finally, cells whose estimated probability of having received a gRNA exceeds probability_threshold are called as containing the gRNA (default: probability_threshold = 0.8). In practice probability_threshold typically does not impact the results considerably.\nTo illustrate use of these method-specific parameters, we again call assign_grnas() to assign gRNAs to cells on the high-MOI CRISPRi data, this time setting formula_object to formula_object_reduced.\n\nsceptre_object_highmoi_mixture &lt;- assign_grnas(\n  sceptre_object = sceptre_object_highmoi,\n  formula_object = formula_object_reduced,\n  parallel = TRUE\n)\n\n\n3.3.2 Maximum method\nThe second gRNA assignment strategy is the \"maximum\" method. The maximum method is the default assignment method for low-MOI screens and is not available as an option for high-MOI screens. The maximum method assigns the gRNA that accounts for the greatest number of UMIs in a given cell to that cell. We apply the maximum method to the low-MOI CRISPRko data below.\n\nsceptre_object_lowmoi_maximum &lt;- assign_grnas(\n  sceptre_object = sceptre_object_lowmoi, \n  method = \"maximum\"\n)\n\nThe maximum method allows for one optional argument: umi_fraction_threshold (default: umi_fraction_threshold = 0.8). Cells for which the maximally expressed gRNA constitutes fewer than umi_fraction_threshold of the UMIs in that cell are flagged as containing multiple gRNAs. (Cells containing multiple gRNAs are removed as part of low-MOI quality control step, as discussed in Chapter 4). For example, if the maximally expressed gRNA in a given cell makes up 0.64 (or 64\\(\\%\\)) of the UMIs in that cell, then that cell is flagged as containing multiple gRNAs and is removed during quality control (assuming that umi_fraction_threshold = 0.8).\n\n3.3.3 Thresholding method\nThe third method for assigning gRNAs to cells is the \"thresholding\" method; this method is available in both low- and high-MOI settings. The thresholding method assigns a gRNA to a cell if the UMI count of the gRNA in the cell is greater than or equal to some integer threshold (by default 5). We apply the \"thresholding\" method to both CRISPRi and CRISPRko datasets as follows.\n\n# high-MOI CRISPRi data\nsceptre_object_highmoi_thresholding &lt;- assign_grnas(\n  sceptre_object = sceptre_object_highmoi,\n  method = \"thresholding\"\n)\n# low-MOI CRISPRko data\nsceptre_object_lowmoi_thresholding &lt;- assign_grnas(\n  sceptre_object = sceptre_object_lowmoi,\n  method = \"thresholding\"\n)\n\nThe thresholding method allows for one optional argument, namely the integer threshold threshold. An important special case is to set threshold to 1, which causes any gRNA expressed in a given cell to be assigned to that cell. We assign gRNAs to cells on the CRISPRi data using a threshold of 1 below.\n\nsceptre_object_highmoi_thresholding &lt;- assign_grnas(\n  sceptre_object = sceptre_object_highmoi,\n  method = \"thresholding\",\n  threshold = 1\n)\n\nNote that setting threshold to 1 causes background contamination to be ignored."
  },
  {
    "objectID": "assign-grnas.html#plotting-and-printing-the-outcome-of-the-grna-to-cell-assignment-step",
    "href": "assign-grnas.html#plotting-and-printing-the-outcome-of-the-grna-to-cell-assignment-step",
    "title": "3  Assign gRNAs",
    "section": "\n3.4 Plotting and printing the outcome of the gRNA-to-cell assignment step",
    "text": "3.4 Plotting and printing the outcome of the gRNA-to-cell assignment step\nWe can call plot() on the sceptre_object to render a plot summarizing the outcome of the gRNA-to-cell assignment step. plot() takes the arguments sceptre_object (required) n_grnas_to_plot (optional), grnas_to_plot (optional), and return_indiv_plots (optional). n_grnas_to_plot is the number of (randomly selected) gRNAs to plot; grnas_to_plot is a vector of names of one or more gRNAs to plot; and return_indiv_plots is a logical value indicating whether to return the constituent panels of the plot individually (TRUE) or combined into a single figure (FALSE; default).\nWe visualize the outcome of the gRNA-to-cell assignment step on the low-MOI CRISPRko data based on the maximum assignment strategy. We specifically plot the gRNAs “IFNGR2g2”, “STAT1g2”, and “STAT5Ag4”. (These gRNAs were selected arbitrarily for the purpose of illustrating the grnas_to_plot argument.)\n\ngrnas_to_plot &lt;- c(\"IFNGR2g2\", \"STAT1g2\", \"STAT5Ag4\")\nplot(sceptre_object_lowmoi_maximum, grnas_to_plot = grnas_to_plot)\n\n\n\n\n\nMaximum assignment method on the low-MOI CRISPRko data.\n\n\n\nSection 3 of The whole game describes how to interpret this plot. Briefly, the top panel displays the gRNA-to-cell assignments of several individual gRNAS, and the bottom left panel shows the number of cells per gRNA. Typically, the bottom right panel plots the number of gRNAs per cell, but the bottom right panel is not meaningful under the maximum assignment strategy and is thus omitted.\nIt is informative to compare the output of multiple gRNA assignment methods and check for consistency across methods. To this end we render a visualization of the gRNA-to-cell assignments on the same dataset, this time based on the mixture method.\n\nplot(sceptre_object_lowmoi_mixture, grnas_to_plot = grnas_to_plot)\n\n\n\n\n\nMixture assignment method on the low-MOI CRISPRko data.\n\n\n\nEncouragingly, the gRNA assignments appear to be highly concordant across the maximum and mixture methods. Suppose that we ultimately choose to use the mixture strategy to assign gRNAs to cells on the low-MOI CRISPRko dataset. We update sceptre_object_lowmoi as follows.\n\nsceptre_object_lowmoi &lt;- sceptre_object_lowmoi_mixture\n\nWe can call print() on sceptre_object_lowmoi to print a summary tracking the progress of the analysis. The field “gRNA-to-cell assignment information” presents information about the gRNA assignment step, including the selected assignment method, the mean number of cells per gRNA, and the mean number of gRNAs per cell.\n\nprint(sceptre_object_lowmoi)\n\nAn object of class sceptre_object.\n\nAttributes of the data:\n    • 20729 cells\n    • 299 responses\n    • Low multiplicity-of-infection \n    • 101 targeting gRNAs (distributed across 26 targets) \n    • 9 non-targeting gRNAs \n    • 6 covariates (bio_rep, grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito)\n\nAnalysis status:\n    ✓ import_data()\n    ✓ set_analysis_parameters()\n    ✓ assign_grnas()\n    ✗ run_qc()\n    ✗ run_calibration_check()\n    ✗ run_power_check()\n    ✗ run_discovery_analysis()\n\nAnalysis parameters: \n    • Discovery pairs: data frame with 7765 pairs\n    • Positive control pairs: data frame with 9 pairs\n    • Sidedness of test: both\n    • N nonzero treatment cells threshold: not specified\n    • N nonzero control cells threshold: not specified\n    • Control group: non-targeting cells\n    • Resampling mechanism: permutations\n    • gRNA integration strategy: union\n    • Formula object: log(response_n_nonzero) + log(response_n_umis) + bio_rep\n\ngRNA-to-cell assignment information:\n    • Assignment method: mixture\n    • Mean N cells per gRNA: 205.07\n    • Mean N gRNAs per cell (MOI): 1.09\n\n\n\n\n\n\nBarry, Timothy, Kathryn Roeder, and Eugene Katsevich. 2022. “Exponential family measurement error models for single-cell CRISPR screens.” arXiv."
  },
  {
    "objectID": "run-qc.html#plot-the-cell-specific-covariates",
    "href": "run-qc.html#plot-the-cell-specific-covariates",
    "title": "4  Run quality control",
    "section": "\n4.1 Plot the cell-specific covariates",
    "text": "4.1 Plot the cell-specific covariates\nA helpful initial step in applying QC is to visualize the distribution of the cell-specific covariates. To this end we call the function plot_covariates(), which creates a histogram of the covariates response_n_nonzero, response_n_umis, and (if applicable) response_p_mito. Cellwise QC removes cells that lie in the extreme right tail of the response_p_mito distribution or that lie in the extreme left or right tail of the response_n_nonzero or response_n_umis distribution. To help guide the selection of QC thresholds, plot_covariates() plots candidate QC thresholds as vertical lines on the histograms. The optional arguments response_n_nonzero_range, response_n_umis_range, and p_mito_threshold control the location of these candidate QC thresholds. response_n_nonzero_range (resp., response_n_umis_range) is a length-two vector of quantiles (default: c(0.01, 0.99)) indicating the location at which to draw candidate QC thresholds on the response_n_nonzero (resp., response_n_umis) histogram. Next, p_mito_threshold is a single numeric value in the interval [0,1] specifying the location at which to draw a candidate QC threshold on the response_p_mito plot. We call plot_covariates() on the high-MOI CRISPRi sceptre_object (i.e., sceptre_object_highmoi), setting p_mito_threshold to 0.075.\n\nplot_covariates(sceptre_object_highmoi, p_mito_threshold = 0.075)\n\n\n\n\n\nPlot of covariates for high-MOI CRISPRi data.\n\n\n\nInspecting these plots (and tinkering with response_n_nonzero_range, response_n_umis_range, and p_mito_threshold as necessary) helps guide the selection of reasonable QC thresholds. In general it is good to clip long, asymmetric tails so as to remove outlier cells. The QC thresholds appear to be drawn at sensible locations on these data.\nWe also call plot_covariates() low-MOI CRISPRko data, again setting p_mito_threshold to 0.075.\n\nplot_covariates(sceptre_object_lowmoi, p_mito_threshold = 0.075)\n\n\n\n\n\nOutcome of QC on low-MOI CRISPRko data.\n\n\n\nThe low-MOI plot is broadly similar to its high-MOI counterpart. In particular, the QC thresholds appear to be drawn at sensible locations."
  },
  {
    "objectID": "run-qc.html#qc-parameters",
    "href": "run-qc.html#qc-parameters",
    "title": "4  Run quality control",
    "section": "\n4.2 QC parameters",
    "text": "4.2 QC parameters\nWe apply QC to a sceptre_object by calling the function run_qc(). run_qc() takes the arguments sceptre_object, response_n_umis_range, response_n_nonzero_range, p_mito_threshold, additional_cells_to_remove, n_nonzero_trt_thresh, and n_nonzero_cntrl_thresh. The only required argument among these is sceptre_object; the rest are set to reasonable defaults.\n\n4.2.1 Cellwise QC parameters\nThe parameters response_n_umis_range, response_n_nonzero_range, p_mito_threshold, and additional_cells_to_remove control cellwise QC. response_n_umis_range (resp., response_n_nonzero_range) is a length-two vector of quantiles (default c(0.01, 0.99)); cells whose response_n_umis (resp., response_n_nonzero) quantile falls outside this range are excluded. Next, p_mito_threshold is a number in the interval [0,1]; cells whose value for response_p_mito falls above this threshold likewise are excluded. (Note that p_mito_threshold is not a quantile but rather an absolute number). Finally, additional_cells_to_remove is an integer vector specifying the (1-based) indices of additional cells to remove. Cells flagged by additional_cells_to_remove are removed before applying any other cellwise QC filter.\n\n4.2.2 Pairwise QC parameters\nThe parameters n_nonzero_trt_thresh and n_nonzero_cntrl_thresh control pairwise QC (i.e., QC at the level of the target-response pair). Recall from Section 2.5 that for a given target-response pair, we divide the cells into treatment and control groups. The treatment group consists of the cells that contain a gRNA targeting the given target, and the control group consists of the cells against which the treatment cells are compared. (The control group can be either the complement set or NT cells; this choice is governed by the control_group parameter.) We define the “number of nonzero treatment cells” (resp., the “number of nonzero control cells”) as the number of cells in the treatment group (resp., control group) that contain nonzero expression of the response. (We sometimes use the shorthand n_nonzero_trt and n_nonzero_cntrl to refer to the number of nonzero treatment cells and control cells, respectively.) n_nonzero_trt and n_nonzero_cntrl are reasonable metrics of pair quality, with higher-quality pairs exhibiting larger values for n_nonzero_trt and n_nonzero_cntrl. The schematic below illustrates the definitions of n_nonzero_trt and n_nonzero_cntrl.\n\n\n\n\nDefinition of n_nonzero_trt and n_nonzero_cntrl. Each square represents a cell, and the integer within a square represents the UMI count of the response in the corresponding cell. Some cells belong to the treatment group (blue), and others belong to the control group (red). n_nonzero_trt (resp., n_nonzero_cntrl) is the number of cells in the treatment group (resp., control group) with nonzero expression of the response.\n\n\n\nsceptre tabulates n_nonzero_trt and n_nonzero_cntrl for each target-response pair. Pairs for which n_nonzero_trt is less than n_nonzero_trt_thresh or n_nonzero_cntrl is less than n_nonzero_cntrl_thresh are excluded. Both n_nonzero_trt_thresh and n_nonzero_cntrl_thresh are set to 7 by default."
  },
  {
    "objectID": "run-qc.html#run-qc",
    "href": "run-qc.html#run-qc",
    "title": "4  Run quality control",
    "section": "\n4.3 Run QC",
    "text": "4.3 Run QC\nWe call run_qc() on sceptre_object_highmoi and sceptre_object_lowmoi to run QC on the high-MOI CRISPRi and low-MOI CRISPRko data. In both cases we set p_mito_threshold to 0.075 but otherwise fall back on the default parameter values.\n\nsceptre_object_highmoi &lt;- run_qc(\n  sceptre_object = sceptre_object_highmoi,\n  p_mito_threshold = 0.075\n)\nsceptre_object_lowmoi &lt;- run_qc(\n  sceptre_object = sceptre_object_lowmoi,\n  p_mito_threshold = 0.075\n)\n\nWe can call the function plot() on the resulting sceptre_object to render a visualization of the outcome of the QC step. We call plot() on sceptre_object_lowmoi as an example.\n\nplot(sceptre_object_lowmoi)\n\n\n\n\n\nOutcome of applying cellwise (top) and pairwise (bottom) QC to the low-MOI CRISPRko data.\n\n\n\nWe described in Section 4 of The whole game how to interpret this figure. The top panel displays the percentage of cells removed (vertical axis) as a result of applying the different cellwise QC filters (horizontal axis). For example, over 20\\(\\%\\) of cells were removed because they contain multiple gRNAs, and about 2\\(\\%\\) of cells were removed because they exhibit extremely high or extremely values for response_n_nonzero. Note that the “multiple gRNAs” filter in general is applied only to low-MOI data. Next, the bottom panel plots the set of discovery target-response pairs, where the vertical (resp., horizontal) position of a given pair indicates its n_nonzero_cntrl (resp., n_nonzero_trt) value. Pairs with a sufficiently large value for n_nonzero_cntrl and n_nonzero_trt (colored in green) pass pairwise QC; all other pairs are removed.\nFinally, we call print() on sceptre_object_lowmoi to print a summary of the analysis status. The summary contains information about cellwise and pairwise QC; see the first entry under the “Attributes of the data” field and the second two entries under the “Analysis parameters” field.\n\nprint(sceptre_object_lowmoi)\n\nAn object of class sceptre_object.\n\nAttributes of the data:\n    • 20729 cells (15348 after cellwise QC)\n    • 299 responses\n    • Low multiplicity-of-infection \n    • 101 targeting gRNAs (distributed across 26 targets) \n    • 9 non-targeting gRNAs \n    • 6 covariates (bio_rep, grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito)\n\nAnalysis status:\n    ✓ import_data()\n    ✓ set_analysis_parameters()\n    ✓ assign_grnas()\n    ✓ run_qc()\n    ✗ run_calibration_check()\n    ✗ run_power_check()\n    ✗ run_discovery_analysis()\n\nAnalysis parameters: \n    • Discovery pairs: data frame with 7765 pairs (6205 after pairwise QC)\n    • Positive control pairs: data frame with 9 pairs (9 after pairwise QC)\n    • Sidedness of test: both\n    • N nonzero treatment cells threshold: 7\n    • N nonzero control cells threshold: 7\n    • Control group: non-targeting cells\n    • Resampling mechanism: permutations\n    • gRNA integration strategy: union\n    • Formula object: log(response_n_nonzero) + log(response_n_umis) + bio_rep\n\ngRNA-to-cell assignment information:\n    • Assignment method: maximum\n    • Mean N cells per gRNA: 188.45\n    • Mean N gRNAs per cell (MOI): not computed when using \"maximum\" assignment method\n\n\nUsers may wonder why sceptre does not implement response-wise QC (e.g., filtering out lowly expressed responses). The reason is that pairwise QC is in some sense stronger than response-wise QC. Suppose for example that a given response exhibits zero expression across cells. Target-response pairs containing this response will have n_nonzero_trt and n_nonzero_cntrl values of zero and thus be filtered out, in effect filtering out the response as well.\n\n\n\n\nBarry, Timothy, Kaishu Mason, Kathryn Roeder, and Eugene Katsevich. 2023. “Robust differential expression testing for single-cell CRISPR screens.” bioRxiv."
  },
  {
    "objectID": "run-calibration-check.html#calibration-check-methodology",
    "href": "run-calibration-check.html#calibration-check-methodology",
    "title": "5  Run calibration check",
    "section": "\n5.1 Calibration check methodology",
    "text": "5.1 Calibration check methodology\nWe begin by describing the methodology underlying the calibration check (Barry et al. 2023).\n\n5.1.1 Differential expression paradigm\nThe goal of the calibration check is to test for association between subsets of negative control gRNAs and responses. Suppose for simplicity that we are conducting a singleton analysis, i.e. suppose that we seek to test for association between an individual negative control gRNA and a response. The “treatment group” is the set of cells containing the given non-targeting gRNA, and the “control group” is the set of cells against which the treatment group is compared to carry out the test of association. The control group can be either the complement set or the NT cells. Within the context of the calibration check analysis, the complement set consists of the cells that do not contain the given non-targeting gRNA; the NT cells, on the other hand, consist of the cells that contain any non-targeting gRNA excluding the given non-targeting gRNA that we are testing for association against the response (see Figure 5.1). sceptre carries out the test of association by testing for differential expression of the response across the treatment and control groups, yielding a p-value.\n\n\n\n\nFigure 5.1: A schematic illustrating the differential expression paradigm of the calibration check analysis. The single-cell CRISPR screen experiment produces a pool of cells; in this example the cells contain targeting gRNAs and three non-targeting gRNAs (labeled NT\\(_1\\), NT\\(_2\\), and NT\\(_3\\)). Suppose that we seek to test for association between a given non-targeting gRNA (e.g., NT\\(_2\\)) and a response. First, we divide the cells into treatment and control groups, where the treatment group consists of the cells that contain NT\\(_2\\), and the control group can be either the complement set or the NT cells. Within the context of the calibration check analysis, the complement set consists of all cells that do not contain NT\\(_2\\); the NT cells, on the other hand, consist of cells that contain a non-targeting gRNA excluding NT\\(_2\\). (Thus, in this example, the NT cells consist of cells that contain NT\\(_1\\) or NT\\(_3\\).) sceptre tests for differential expression of the given response across the treatment and control groups, yielding a p-value for the test of association bewteen the given non-targeting gRNA and the response.\n\n\n\n\n5.1.2 Constructing the negative control pairs\nThe calibration check involves forming a set of negative control target-response pairs and then testing these pairs for association to ensure control of the false discovery rate. sceptre automatically constructs the negative control pairs, and it does so in such a way that the negative control pairs are highly similar to the discovery pairs, the difference being that the negative control pairs are devoid of biological signal. sceptre builds the negative control pairs as follows. First, sceptre forms “negative control groups” by randomly grouping together distinct sets of negative control gRNAs. For example, in a screen containing nine negative control gRNAs (labeled NT1- NT9), gRNAs NT2, NT5, and NT7 might be assigned randomly to one group, gRNAs NT3, NT6, and NT9 might be assigned randomly to another group, and so on. (See schematic below). The number of negative control gRNAs per group (by default) is set equal to the median number of gRNAs per discovery target. For example, in a screen in which each discovery target is targeted by three gRNAs, each negative control group is formed by randomly putting together three negative control gRNAs. The negative control gRNA groups can (and often do) overlap; for example, a given NT gRNA (e.g., NT2) could be a part of multiple negative control groups.\n\n\n\n\nA schematic illustrating how the negative control target response pairs are constructed. First, negative control gRNA groups are formed by randomly assembling negative control gRNAs into groups of size one or more. Next, the negative control gRNA groups are randomly paired to responses.\n\n\n\nIn a singleton analysis (i.e., an analysis in which we seek to test for association between individual gRNAs and responses), each negative control gRNA is placed into its own negative control group of size one. (Recall from Section 2.4 that we can prompt sceptre to run a singleton analysis by setting grna_integration_strategy to \"singleton\" in set_analysis_parameters()). We often use the term “negative control target” interchangeably with “negative control gRNA group.”\nAfter forming the negative control targets, sceptre constructs the set of negative control pairs by randomly pairing the negative control targets to the responses. The number of negative control pairs that sceptre constructs is set equal to the number of pairs in the discovery set (after QC is applied to the discovery pairs). Moreover, the negative control pairs are subjected to the same pairwise QC as the discovery pairs. In this sense the negative control pairs are “matched” to the discovery pairs in three respects: (1) the number of gRNAs contained within each target is the same across the negative control and discovery pairs; (2) the negative control pairs are subjected to the same pairwise QC as the discovery pairs; (3) the number of negative control pairs is equal to the number of discovery pairs.\n\n5.1.3 Analyzing the negative control pairs\nThe calibration check entails testing for association between the negative control targets and the responses to which the negative control targets have been paired. If grna_integration_strategy is set to \"singleton\", the analysis proceeds as described in Section 5.1.1. If grna_integration_strategy is set to \"union\" (the default), negative control gRNAs contained within a given negative control target are combined via the union operation; this combined gRNA is then tested for association against the responses as if it were a singleton gRNA. Consider again Figure 5.1. Suppose that NT1 and NT2 constitute a given negative control target, and suppose we seek to test for association between this negative control target and a given response. The “treatment group” in this case would be the cells containing either NT1 or NT2. Meanwhile, the “complement set” would consist of cells that do not contain NT1 or NT2. Finally, the “NT cells” would consist of cells containing NT3."
  },
  {
    "objectID": "run-calibration-check.html#sec-run-calibration-check_running_the_calibration_check",
    "href": "run-calibration-check.html#sec-run-calibration-check_running_the_calibration_check",
    "title": "5  Run calibration check",
    "section": "\n5.2 Running the calibration check",
    "text": "5.2 Running the calibration check\nWe carry out the calibration check by calling the function run_calibration_check() on the sceptre_object. run_calibration_check() takes the arguments sceptre_object (required), n_calibration_pairs (optional), calibration_group_size (optional), print_progress (optional), and parallel (optional), and output_amount (optional). n_calibration_pairs is the number of negative control target-response pairs to test for association. By default n_calibration_pairs is set to the number of discovery target-response pairs that passes pairwise QC. Next, calibration_group_size is the number of negative control gRNAs to put together to construct each negative control target. By default calibration_group_size is set to the median number of gRNAs per discovery target. Finally, print_progress and parallel control whether to print updates to the console and run the computation in parallel, respectively. We describe the output_amount argument in a subsequent section. Below, we run the calibration check on the high-MOI CRISPRi and low-MOI CRISPRko data, setting parallel to TRUE.\n\nsceptre_object_highmoi &lt;- run_calibration_check(\n  sceptre_object = sceptre_object_highmoi,\n  parallel = TRUE\n)\nsceptre_object_lowmoi &lt;- run_calibration_check(\n  sceptre_object = sceptre_object_lowmoi,\n  parallel = TRUE\n)\n\nWe can plot the outcome of the calibration check by calling plot() on the resulting sceptre_object. We plot the outcome of the calibration check on the low-MOI CRISPRko data.\n\nplot(sceptre_object_lowmoi)\n\n\n\n\n\nOutcome of the calibration check on the low-MOI CRISPRko data.\n\n\n\nWe described Section 5 of The whole game how to interpret this figure. Briefly, the upper left (resp., right) plot is a QQ plot of the negative control p-values on an untransformed (resp., transformed) scale; the p-values should lie predominantly along the diagonal line. The lower left plot is a histogram of the estimated (log-2) fold changes; the histogram should be symmetric and centered about zero. Finally, the lower right panel is a text box displaying the number of false discoveries made on the negative control pairs (after applying the multiple testing adjustment) and the mean estimated (log-2) fold change. Both of these numbers ideally should be close to zero. (It is OK if the number of false discoveries is nonzero; see next section.)\nWe can obtain a data frame containing the results by calling get_result on the sceptre_object, setting analysis to \"run_calibration_check\".\n\ncalibration_result &lt;- get_result(\n  sceptre_object = sceptre_object_lowmoi,\n  analysis = \"run_calibration_check\"\n)\nhead(calibration_result)\n\n    response_id          grna_target n_nonzero_trt n_nonzero_cntrl pass_qc\n1:       SLC8B1  NTg4&NTg7&NTg8&NTg9           236             162    TRUE\n2:       UBE2L6 NTg1&NTg5&NTg7&NTg10           982             812    TRUE\n3:       TMEM37  NTg3&NTg4&NTg5&NTg9            46              18    TRUE\n4:       PARPBP NTg3&NTg8&NTg9&NTg10            51              61    TRUE\n5:       MTMR10 NTg1&NTg3&NTg8&NTg10            87             250    TRUE\n6: RP11-799D4.4  NTg2&NTg3&NTg4&NTg7            25              44    TRUE\n        p_value log_2_fold_change significant\n1: 0.0000955005        0.23780413       FALSE\n2: 0.0003396914        0.05625781       FALSE\n3: 0.0004477911        0.56398692       FALSE\n4: 0.0010338764        0.53570790       FALSE\n5: 0.0010732514       -0.39425294       FALSE\n6: 0.0011500039       -0.64984993       FALSE\n\n\nEach row of this data frame corresponds to a negative control target-response pair. The columns response_id and grna_target indicate the response and target that make up a given negative control target-response pair. The individual non-targeting gRNAs that form a negative control target are listed, concatenated into a string via the ampersand (“&”) separator. (For example, the negative control gRNA target “NTg4&NTg7&NTg8&NTg9” was formed by combining the negative control gRNAs NTg4, NTg7, NTg8, and NTg9.) The remaining columns of the data frame are as follows: n_nonzero_trt (the number of nonzero treatment cells of a given pair), n_nonzero_cntrl (the number of nonzero control cells of a given pair), pass_qc (whether a given pair passes pairwise QC), p_value (the p-value of a given pair), log_2_fold_change (the estimated log-2 fold change of a given pair), and significant (whether a given pair is called as significant after applying the multiple testing correction adjustment)."
  },
  {
    "objectID": "run-calibration-check.html#diagnosing-miscalibration",
    "href": "run-calibration-check.html#diagnosing-miscalibration",
    "title": "5  Run calibration check",
    "section": "\n5.3 Diagnosing miscalibration",
    "text": "5.3 Diagnosing miscalibration\nThe negative control p-values may demonstrate miscalibration, which is a deviation of the p-values from the expected uniform distribution under the null hypothesis. Indicators of miscalibration include (i) the presence of points that lie considerably above or below the diagonal line on the negative control QQ plots and (ii) a large number of false discoveries on the negative control data. Miscalibration is problematic because it suggests that sceptre does not control the rate of false discoveries on the dataset under analysis. Miscalibration can be more or less severe; the table below provides a rough guideline for interpreting miscalibration severity as a function of the number of false discoveries made on the negative control data.\n\n\nTable 5.1: Calibration quality as a (rough) function of the number of false discoveries made on the negative control data in the calibration check analysis.\n\nNumber of false discoveries\nCalibration quality\n\n\n\n0-1\nExcellent calibration\n\n\n2-6\nMild miscalibration\n\n\n7-14\nModerate miscalibration\n\n\n15+\nSevere miscalibration\n\n\n\n\nsceptre could demonstrate miscalibration on a single-cell CRISPR screen dataset due to three main reasons: sparsity, the omission of relevant covariates, and model misspecification. Sparsity — the presence of a large proportion of zeros in the response UMI count matrix — can cause the skew-normal approximation to the distribution of the null test statistics to break down, resulting in miscalibrated p-values. Additionally, the omission of important covariates (such as batch or biological replicate) from the model or misspecification of the underlying negative binomial GLM (due, for example, to the presence of outlier cells) also can lead to miscalibration. Pairwise and cellwise QC (Chapter 4) provide the first line of defense against sparsity and model misspecification, respectively. Furthermore, the resampling methodology of sceptre protects against misspecification of the negative binomial GLM. In spite of these safeguards, sceptre may still exhibit miscalibration on some datasets.\nTo provide an example of miscalibration, we again run the calibration check on the high-MOI CRISPRi data, this time setting formula_object to formula(~log(grna_n_umis)), thereby excluding batch, response_n_umis, and other important covariates.\n\nsceptre_object_highmoi &lt;- sceptre_object_highmoi |&gt;\n  set_analysis_parameters(\n    discovery_pairs = discovery_pairs,\n    positive_control_pairs = positive_control_pairs,\n    side = \"left\",\n    formula_object = formula(~ log(grna_n_umis))\n  ) |&gt; \n  assign_grnas(parallel = TRUE) |&gt;\n  run_qc()\n\nsceptre_object_highmoi &lt;- run_calibration_check(\n  sceptre_object = sceptre_object_highmoi,\n  parallel = TRUE\n)\n\nWe create a plot to visualize the outcome of the calibration check analysis.\n\nplot(sceptre_object_highmoi)\n\n\n\n\n\nRemoving several covariates results in mild miscalibration on the high-MOI CRISPRi data.\n\n\n\nThe negative control p-values no longer lie completely along the diagonal line in the QQ plots; a handful of p-values in the tail of the distribution, for example, trends markedly above the diagonal. Moreover, sceptre has made five false discoveries. This is an example of mild miscalibration, per Table 5.1.\nWhat should one do in the event that sceptre exhibits miscalibration? If the miscalibration is mild, we recommend proceeding to the next steps of the pipeline (i.e., the power check and discovery analysis). We note that it may not possible to obtain perfect calibration (using sceptre or any other method) on a given dataset, as the dataset may pose fundamental challenges to calibration that are unresolvable. Moreover, it may not be preferable to obtain perfect calibration either, as a mild reduction in miscalibration sometimes leads to a substantial loss of power. If the miscalibration is moderate to severe, we recommend attempting to alleviate the miscalibration using one or more of the strategies described below."
  },
  {
    "objectID": "run-calibration-check.html#sec-improving_calibration",
    "href": "run-calibration-check.html#sec-improving_calibration",
    "title": "5  Run calibration check",
    "section": "\n5.4 Improving calibration",
    "text": "5.4 Improving calibration\nThere are several concrete steps that users can take to improve the calibration of sceptre. We list five of the most important strategies here, ordered roughly from most to least promising. These strategies need not be applied one-at-a-time and instead can be mixed and matched.\n\n\nDeactivate the parametric curve fitting functionality. sceptre by default computes the p-value for a given target-response pair by fitting a parametric curve (specifically, a skew-normal density) to the distribution of null test statistics and then evaluating the tail probability of the fitted curve at the observed test statistic (Section 2.8). If the parametric curve provides a poor fit to the distribution of the null test statistics, the resulting p-value can be miscalibrated. Users can deactivate the parametric curve fitting functionality of sceptre and instead return an exact p-value by setting fit_parametric_curve to FALSE in set_analysis_parameters(), as follows.\n\nsceptre_object_highmoi &lt;- sceptre_object_highmoi |&gt;\n  set_analysis_parameters(\n    discovery_pairs = discovery_pairs,\n    positive_control_pairs = positive_control_pairs,\n    side = \"left\",\n    fit_parametric_curve = FALSE # fit_parametric_curve set to FALSE\n  )\n\nThe calibration check, power check, and discovery analyses all run more slowly when fit_parametric_curve is set to FALSE, as sceptre must compute a greater number of null test statistics to preserve adequate precision of the p-values. Thus, setting fit_parametric_curve to FALSE may not be a feasible strategy for users seeking to test a large number (e.g., 10,000+) of pairs. Users should consider using the permutation test (resampling_mechaism = \"permutations\") rather than the conditional randomization test (resampling_mechanism = \"crt\") when setting fit_parametric_curve to FALSE to improve speed.\n\nsceptre_object_highmoi &lt;- sceptre_object_highmoi |&gt;\n  set_analysis_parameters(\n    discovery_pairs = discovery_pairs,\n    positive_control_pairs = positive_control_pairs,\n    side = \"left\",\n    fit_parametric_curve = FALSE,         # slows down the code\n    resampling_mechanism = \"permutations\" # speeds up the code\n  )\n\n\nAdd additional covariates. sceptre may be miscalibrated because important covariates are missing. Users should consider whether any additional covariates are relevant and, if so, add these covariates to the sceptre_object via import_data() or import_data_from_cellranger(). For example, cell type should be included as a covariate if the data contain multiple cell types. Batch, biological replicate, and cell cycle also may be relevant. (sceptre does not currently provide functionality for imputing cell type or cycle.)\n\nTighten the QC thresholds. Users can tighten the cellwise and pairwise QC thresholds to remove outlier cells and target-response pairs with a low effective sample size, respectively, thereby ameliorating challenges to calibration due to sparsity and model misspecification. Below, we increase n_nonzero_trt_thresh and n_nonzero_cntrl_thresh to 15; the default value for these parameters is 10. We additionally set response_n_umis_range to c(0.05, 0.95), which clips the response_n_umis distribution at the fifth and ninety-fifth percentiles (as opposed the the first and ninety-ninth percentiles, which is the default).\n\nsceptre_object_highmoi &lt;- sceptre_object_highmoi |&gt;\n  run_qc(\n    n_nonzero_trt_thresh = 15L,\n    n_nonzero_cntrl_thresh = 15L,\n    response_n_umis_range = c(0.05, 0.95)\n  )\n\n\n\nChange the resampling mechanism or the control group. sceptre provides two options for the resampling mechanism (namely, \"permutations\" or \"crt\"; see Section 2.7) and two options for the control group (namely, \"complement_set\" or \"nt_cells\"; see Section 2.5). (Note that \"nt_cells\" is available as an option only in low-MOI screens.) Switching the resampling mechanism and/or the control group may improve calibration. Below, we set the resampling mechanism to \"crt\" and the control group to \"complement_set\" on the low-MOI CRISPRko data; these choices are the opposites of the defaults.\n\nsceptre_object_lowmoi &lt;- sceptre_object_lowmoi |&gt;\n  set_analysis_parameters(\n    sceptre_object = sceptre_object_lowmoi,\n    discovery_pairs = discovery_pairs_lowmoi,\n    positive_control_pairs = positive_control_pairs_lowmoi,\n    resampling_mechanism = \"crt\",\n    control_group = \"complement_set\"\n  )\n\n\n\nTest fewer pairs. Obtaining good calibration becomes increasingly challenging as the number of target-response pairs in the discovery set grows. This is because the p-values must maintain uniformity further and further out into the tail of the distribution. A simple strategy to improve calibration is to reduce the number of target-response pairs by more selectively choosing pairs for inclusion in the discovery set. For example, we could construct the discovery set for the high-MOI CRISPRi data by coupling each candidate enhancer to the set of genes within one megabase of that candidate enhancer (as opposed to five megabases, as we have done previously). This change reduces the number of pairs in the discovery set (before applying QC) from 610 to 353, which makes obtaining good calibration considerably easier.\n\ndiscovery_pairs &lt;- construct_cis_pairs(sceptre_object_highmoi,\n  positive_control_pairs = positive_control_pairs,\n  distance_threshold = 1e6 # previous value: 5e6\n)\nsceptre_object_highmoi &lt;- sceptre_object_highmoi |&gt;\n  set_analysis_parameters(\n    discovery_pairs = discovery_pairs,\n    positive_control_pairs = positive_control_pairs,\n    side = \"left\"\n  )\n\nUsers also could more aggressively prioritize pairs for inclusion in the discovery set by leveraging orthogonal information, such as (single-cell) ATAC-seq or ChIP-seq data."
  },
  {
    "objectID": "run-calibration-check.html#sec-run_calibration_check_output_amount",
    "href": "run-calibration-check.html#sec-run_calibration_check_output_amount",
    "title": "5  Run calibration check",
    "section": "\n5.5 The output_amount argument",
    "text": "5.5 The output_amount argument\nThe function run_calibration_check() has the optional argument output_amount, which controls the amount of information that run_calibration_check() returns. output_amount can be set to 1, 2, or 3, with 1 (the default) returning the least information, 2 returning an intermediate amount of information, and 3 returning the most information. Setting output_amount to 2 causes several additional columns to be appended to the calibration check result data frame. To illustrate, we again run the calibration check on the low-MOI CRISPRko data, this time setting output_amount to 2.\n\nsceptre_object_lowmoi &lt;- run_calibration_check(sceptre_object_lowmoi,\n  parallel = TRUE,\n  output_amount = 2\n)\n\nConstructing negative control pairs. ✓\nGenerating permutation resamples. ✓\nRunning calibration_check in parallel. Change directories to /var/folders/h6/pt59hmwd7rqb3jqfzwh0hlth0000gn/T//RtmpcDyBqQ/sceptre_logs/ and view the files calibration_check_*.out for progress updates.\n ✓\n\n\n\nsceptre_object_lowmoi |&gt;\n  get_result(analysis = \"run_calibration_check\") |&gt; \n  head()\n\n    response_id          grna_target n_nonzero_trt n_nonzero_cntrl pass_qc\n1:       SLC8B1  NTg4&NTg7&NTg8&NTg9           236             162    TRUE\n2:       UBE2L6 NTg1&NTg5&NTg7&NTg10           982             812    TRUE\n3:       TMEM37  NTg3&NTg4&NTg5&NTg9            46              18    TRUE\n4:       PARPBP NTg3&NTg8&NTg9&NTg10            51              61    TRUE\n5:       MTMR10 NTg1&NTg3&NTg8&NTg10            87             250    TRUE\n6: RP11-799D4.4  NTg2&NTg3&NTg4&NTg7            25              44    TRUE\n        p_value log_2_fold_change stage    z_orig         xi    omega\n1: 0.0000955005        0.23780413     2  3.923777  0.2540283 1.040114\n2: 0.0003396914        0.05625781     2  3.694460 -0.2677594 1.059273\n3: 0.0004477911        0.56398692     2  3.327821 -0.4200504 1.018417\n4: 0.0010338764        0.53570790     2  3.387342 -0.7116245 1.180715\n5: 0.0010732514       -0.39425294     2 -3.177835 -0.6407830 1.187394\n6: 0.0011500039       -0.64984993     2 -3.224238  0.2756485 1.027669\n        alpha significant\n1: -0.3198038       FALSE\n2:  0.3626879       FALSE\n3:  0.4496051       FALSE\n4:  0.8571695       FALSE\n5:  0.8827759       FALSE\n6: -0.3098954       FALSE\n\n\nTo explain what the additional columns represent, we must first provide further details about how the sceptre methodology works. sceptre uses an adaptive resampling scheme to reduce compute. For a given target-response pair, sceptre first computes the observed z-score \\(z_\\textrm{obs}\\) and a small number \\(B_1\\) of null z-scores (where \\(B_1 \\approx 500\\)). The original z-score is compared to the null z-scores to compute a “stage 1” p-value \\(p_1\\). If \\(p_1\\) falls below some threshold (set to 0.02), then sceptre computes a large number \\(B_2\\) of fresh null z-scores (where \\(B_2 \\approx 5,000\\)). A skew-normal distribution is fit to the \\(B_2\\) fresh null z-scores, and a “stage 2” p-value \\(p_2\\) is computed by evaluating the tail probability of the fitted skew-normal distribution at the observed z-score. The goodness of fit of the skew-normal distribution is assessed. If the fit is poor, then sceptre computes a third set of \\(B_3\\) null z-scores (where \\(B_3 \\approx 25,000\\)), and a “stage 3” p-value is computed by comparing the original z-score to this third set of null z-scores.\nThe columns appended to the result data frame when output_amount is set to 2 are as follows: z_orig, stage, xi, omega, and alpha. z_orig is the original z-score. stage is the stage at which the p-value was computed, either 1, 2, or 3. And xi, omega, and alpha are the fitted values of the skew-normal distribution. (The latter three parameters are relevant only when stage is 2; when stage is 1 or 3, these parameters are set to NA.)\nFinally, we can set output_amount to 3, which causes the null z-scores to be appended to the result data frame. The null z-scores are labeled z_null_1, z_null_2, z_null_3, etc.\n\nsceptre_object_lowmoi &lt;- run_calibration_check(sceptre_object_lowmoi,\n  parallel = TRUE,\n  output_amount = 3\n)\ncalibration_result &lt;- get_result(\n  sceptre_object = sceptre_object_lowmoi,\n  analysis = \"run_calibration_check\"\n)\n\n\ncalibration_result[1, ] |&gt;\n  colnames() |&gt;\n  head(20)\n\n [1] \"response_id\"       \"grna_target\"       \"n_nonzero_trt\"    \n [4] \"n_nonzero_cntrl\"   \"pass_qc\"           \"p_value\"          \n [7] \"log_2_fold_change\" \"stage\"             \"z_orig\"           \n[10] \"xi\"                \"omega\"             \"alpha\"            \n[13] \"z_null_1\"          \"z_null_2\"          \"z_null_3\"         \n[16] \"z_null_4\"          \"z_null_5\"          \"z_null_6\"         \n[19] \"z_null_7\"          \"z_null_8\"         \n\n\nFinally, we can call print() on the updated sceptre_object to print a summary of the status of the analysis.\n\nprint(sceptre_object_lowmoi)\n\nAn object of class sceptre_object.\n\nAttributes of the data:\n    • 20729 cells (15348 after cellwise QC)\n    • 299 responses\n    • Low multiplicity-of-infection \n    • 101 targeting gRNAs (distributed across 26 targets) \n    • 9 non-targeting gRNAs \n    • 6 covariates (bio_rep, grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito)\n\nAnalysis status:\n    ✓ import_data()\n    ✓ set_analysis_parameters()\n    ✓ assign_grnas()\n    ✓ run_qc()\n    ✓ run_calibration_check()\n    ✗ run_power_check()\n    ✗ run_discovery_analysis()\n\nAnalysis parameters: \n    • Discovery pairs: data frame with 7765 pairs (6205 after pairwise QC)\n    • Positive control pairs: data frame with 9 pairs (9 after pairwise QC)\n    • Sidedness of test: both\n    • N nonzero treatment cells threshold: 7\n    • N nonzero control cells threshold: 7\n    • Control group: non-targeting cells\n    • Resampling mechanism: permutations\n    • gRNA integration strategy: union\n    • Formula object: log(response_n_nonzero) + log(response_n_umis) + bio_rep\n\ngRNA-to-cell assignment information:\n    • Assignment method: maximum\n    • Mean N cells per gRNA: 188.45\n    • Mean N gRNAs per cell (MOI): not computed when using \"maximum\" assignment method\n\nSummary of results:\n    • N negative control pairs called as significant: 0/6205\n    • Mean log-2 FC for negative control pairs: -0.0027\n\n\nThe the first two entries under the field “Summary of results” provide information about the outcome of the calibration check.\n\n\n\n\nBarry, Timothy, Kaishu Mason, Kathryn Roeder, and Eugene Katsevich. 2023. “Robust differential expression testing for single-cell CRISPR screens.” bioRxiv."
  },
  {
    "objectID": "run-power-check-and-discovery-analysis.html#run-power-check",
    "href": "run-power-check-and-discovery-analysis.html#run-power-check",
    "title": "\n6  Run power check and discovery analysis\n",
    "section": "\n6.1 Run power check",
    "text": "6.1 Run power check\nWe run the power check by calling the function run_power_check(), which takes the arguments sceptre_object (required), output_amount (optional), print_progress (optional), and parallel (optional). output_amount controls the amount of information that run_power_check() returns; see Section 5.5 of Run calibration check for more information about this argument. print_progress and parallel are logical values indicating whether to print progress updates and run the computation in parallel, respectively. We run the power check on the low-MOI CRISPRko data.\n\nsceptre_object_lowmoi &lt;- run_power_check(\n  sceptre_object = sceptre_object_lowmoi,\n  parallel = TRUE\n)\n\nWe call plot() on the resulting sceptre_object to visualize the outcome of the power check.\n\nplot(sceptre_object_lowmoi)\n\n\n\n\n\nPower check results on the low-MOI CRISPRko data.\n\n\n\nWe described how to interpret this plot in Section 6 of The whole game. Briefly, each point represents a pair, and the vertical position of a given point indicates the p-value of the corresponding pair. Points in the left (resp., right) column are positive control (resp, negative control) pairs. The positive control p-values should be generally smaller (i.e., more significant) than the negative control p-values."
  },
  {
    "objectID": "run-power-check-and-discovery-analysis.html#run-discovery-analysis",
    "href": "run-power-check-and-discovery-analysis.html#run-discovery-analysis",
    "title": "\n6  Run power check and discovery analysis\n",
    "section": "\n6.2 Run discovery analysis",
    "text": "6.2 Run discovery analysis\nWe run the discovery analysis by calling the function run_discovery_analysis(), which takes the same arguments as run_power_check(). We illustrate this function on the low-MOI CRISPRko data.\n\nsceptre_object_lowmoi &lt;- run_discovery_analysis(\n  sceptre_object = sceptre_object_lowmoi,\n  parallel = TRUE\n)\n\nWe can visualize the outcome of the discovery analysis by calling plot() on the resulting sceptre_object.\n\nplot(sceptre_object_lowmoi)\n\n\n\n\n\nDiscovery analysis results on the low-MOI CRISPRko data.\n\n\n\nWe described how to interpret this plot in Section 7 of The whole game. Briefly, the top left (resp. right) panel is a QQ plot of the negative control p-values and the discovery p-values plotted on an untransformed (resp., transformed) scale. The bottom left panel plots the p-value of each discovery pair against its log-2-fold-change. Finally, the bottom right panel displays the number of discoveries that sceptre makes on the discovery set (after applying the multiplicity correction)."
  },
  {
    "objectID": "run-power-check-and-discovery-analysis.html#inspecting-the-results",
    "href": "run-power-check-and-discovery-analysis.html#inspecting-the-results",
    "title": "\n6  Run power check and discovery analysis\n",
    "section": "\n6.3 Inspecting the results",
    "text": "6.3 Inspecting the results\nWe can obtain a data frame containing the results by calling get_result() on the sceptre_object, setting the parameter analysis to the name of the function whose results we are querying. For example, we can obtain the discovery results as follows.\n\ndiscovery_result &lt;- get_result(\n  sceptre_object = sceptre_object_lowmoi,\n  analysis = \"run_discovery_analysis\"\n)\nhead(discovery_result)\n\n   response_id grna_target n_nonzero_trt n_nonzero_cntrl pass_qc       p_value\n1:        JAK2       STAT1           112            1557    TRUE 1.000000e-250\n2:       PSMB9      IFNGR1           873            1801    TRUE 3.381199e-155\n3:       PSMB9        JAK2           706            1801    TRUE 4.456437e-145\n4:       STAT1      IFNGR2           821            1819    TRUE 3.231543e-127\n5:       STAT1      IFNGR1           898            1819    TRUE 3.361381e-127\n6:       STAT1        JAK2           714            1819    TRUE 1.404004e-122\n   log_2_fold_change significant\n1:        -1.3840723        TRUE\n2:        -0.8561766        TRUE\n3:        -0.9410000        TRUE\n4:        -0.6669393        TRUE\n5:        -0.6371647        TRUE\n6:        -0.7134929        TRUE\n\n\nThe data frame discovery_result contains the columns response_id, grna_target, n_nonzero_trt, n_nonzero_cntrl, pass_qc, p_value, log_2_fold_change, and significant; see Section 5.2 of Run calibration check for a description of these columns. The rows are ordered according to p_value. Pairs called as significant are stored in the top rows of the data frame; pairs called as insignificant are stored in the middle rows; and pairs filtered out by pairwise QC are stored in the bottom rows. (The latter pairs have a value of NA in the p_value, log_2_fold_change, and significant columns.)\nThe format of the result data frame is slightly different when we use the “singleton” gRNA integration strategy rather than the default “union” strategy. To illustrate, we again analyze the low-MOI CRISPRko data, this time setting grna_integration_strategy to \"singleton\" in set_analysis_parameters(). We then call assign_grnas(), run_qc(), and run_discovery_analysis().\n\nsceptre_object_lowmoi_singleton &lt;- sceptre_object_lowmoi |&gt;\n  set_analysis_parameters(\n    discovery_pairs = discovery_pairs_lowmoi,\n    positive_control_pairs = positive_control_pairs_lowmoi,\n    grna_integration_strategy = \"singleton\"\n  ) |&gt;\n  assign_grnas() |&gt;\n  run_qc(p_mito_threshold = 0.075) |&gt;\n  run_discovery_analysis(parallel = TRUE)\n\nThe result data frame obtained via get_result() contains the additional column grna_id. Each row of this data frame corresponds to an individual gRNA-response pair (as opposed to target-response pair).\n\ndiscovery_result &lt;- get_result(\n  sceptre_object = sceptre_object_lowmoi_singleton,\n  analysis = \"run_discovery_analysis\"\n)\nhead(discovery_result)\n\n   response_id  grna_id grna_target n_nonzero_trt n_nonzero_cntrl pass_qc\n1:       PSMB9 IFNGR2g1      IFNGR2           384            1801    TRUE\n2:       STAT1 IFNGR2g1      IFNGR2           407            1819    TRUE\n3:       STAT1 IFNGR1g3      IFNGR1           317            1819    TRUE\n4:       PSMB9 IFNGR1g3      IFNGR1           304            1801    TRUE\n5:      UBE2L6 IFNGR2g1      IFNGR2           375            1794    TRUE\n6:        JAK2 IFNGR2g1      IFNGR2           176            1557    TRUE\n         p_value log_2_fold_change significant\n1: 3.610750e-106        -1.2076649        TRUE\n2:  1.525194e-97        -0.9332334        TRUE\n3:  7.272333e-92        -1.0104953        TRUE\n4:  7.077892e-85        -1.2386121        TRUE\n5:  4.216879e-80        -0.8712660        TRUE\n6:  1.992249e-70        -1.5816584        TRUE\n\n\nWe can filter for a given target to view the p-values of the individual gRNAs targeting that target. For example, we filter the result data frame for rows containing response ID “PSMB9” and gRNA target “IFNGR2,” displaying the columns response_id, grna_id, grna_target, p_value, significant, and n_nonzero_trt.\n\ndiscovery_result |&gt;\n  filter(response_id == \"PSMB9\", grna_target == \"IFNGR2\") |&gt;\n  select(response_id, grna_id, grna_target, p_value, significant, n_nonzero_trt)\n\n   response_id  grna_id grna_target       p_value significant n_nonzero_trt\n1:       PSMB9 IFNGR2g1      IFNGR2 3.610750e-106        TRUE           384\n2:       PSMB9 IFNGR2g2      IFNGR2  9.280090e-50        TRUE           286\n3:       PSMB9 IFNGR2g3      IFNGR2  1.424416e-17        TRUE           115\n4:       PSMB9 IFNGR2g4      IFNGR2  3.200000e-02       FALSE            12\n\n\nThe individual gRNAs that target “IFNGR2” are “IFNGR2g1,” “IFNGR2g2,” IFNGR2g3,” and “IFNGR2g4.” All produce a significant association except “IFNGR2g4.” The latter likely does not produce a significant association because the pair consisting of gRNA IFNGR2g4 and response PSMB9 has a smaller effective sample size than the other pairs (as quantified by n_nonzero_trt).\nWe additionally can call print() on the updated sceptre_object to print information about the status of the analysis to the console.\n\nprint(sceptre_object_lowmoi)\n\nAn object of class sceptre_object.\n\nAttributes of the data:\n    • 20729 cells (15348 after cellwise QC)\n    • 299 responses\n    • Low multiplicity-of-infection \n    • 101 targeting gRNAs (distributed across 26 targets) \n    • 9 non-targeting gRNAs \n    • 6 covariates (bio_rep, grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito)\n\nAnalysis status:\n    ✓ import_data()\n    ✓ set_analysis_parameters()\n    ✓ assign_grnas()\n    ✓ run_qc()\n    ✓ run_calibration_check()\n    ✓ run_power_check()\n    ✓ run_discovery_analysis()\n\nAnalysis parameters: \n    • Discovery pairs: data frame with 7765 pairs (6205 after pairwise QC)\n    • Positive control pairs: data frame with 9 pairs (9 after pairwise QC)\n    • Sidedness of test: both\n    • N nonzero treatment cells threshold: 7\n    • N nonzero control cells threshold: 7\n    • Control group: non-targeting cells\n    • Resampling mechanism: permutations\n    • gRNA integration strategy: union\n    • Formula object: log(response_n_nonzero) + log(response_n_umis) + bio_rep\n\ngRNA-to-cell assignment information:\n    • Assignment method: maximum\n    • Mean N cells per gRNA: 188.45\n    • Mean N gRNAs per cell (MOI): not computed when using \"maximum\" assignment method\n\nSummary of results:\n    • N negative control pairs called as significant: 0/6205\n    • Mean log-2 FC for negative control pairs: -0.0027\n    • Median positive control p-value: 1.3e-18\n    • N discovery pairs called as significant: 453/6205\n\n\nThe third and fourth entries under the field “Summary of results” provide information about the power check and discovery analysis, respectively."
  },
  {
    "objectID": "run-power-check-and-discovery-analysis.html#writing-the-outputs-to-a-directory",
    "href": "run-power-check-and-discovery-analysis.html#writing-the-outputs-to-a-directory",
    "title": "\n6  Run power check and discovery analysis\n",
    "section": "\n6.4 Writing the outputs to a directory",
    "text": "6.4 Writing the outputs to a directory\nWe can write all outputs (i.e., results and plots) of an analysis to a directory on disk via the function write_outputs_to_directory(). See Section 8 of The whole game for a description of this function."
  },
  {
    "objectID": "methods-and-theory.html",
    "href": "methods-and-theory.html",
    "title": "Part II: Methods and Algorithms",
    "section": "",
    "text": "This part of the book discusses the methods and algorithms that undergird sceptre. It also explores several theoretical issues related to the conditions under which these methods can be expected to work well in practice.\n\nChapter 7 provides an overview of the statistical methods that underlie sceptre.\nChapter 8 describes the various statistical and computational accelerations that help make sceptre fast.\nChapter 9 explores several theoretical issues, including the precise conditions under which differential expression testing methods — including sceptre, negative binomial regression, and the Wilcoxon test — can be expected to control the rate of false positives on a single-cell CRISPR screen dataset.\nChapter 10 provides recommendations on experimental design for single-cell CRISPR screens."
  },
  {
    "objectID": "methods.html#notation",
    "href": "methods.html#notation",
    "title": "7  Overview of methods",
    "section": "7.1 Notation",
    "text": "7.1 Notation\nWe begin by introducing some notation that we use throughout the chapter. Let \\(\\mathbb{N} = \\{1, 2, \\dots\\}\\) denote the set of positive integers. For a given single-cell CRISPR screen dataset, let \\(d\\in\\mathbb{N}\\) denote the number of responses, \\(r\\in\\mathbb{N}\\) the number of gRNAs, and \\(n\\in\\mathbb{N}\\) the number of cells in the dataset. Next, let \\(Y\\in \\mathbb{N}^{d \\times n}\\) be the matrix of response UMI counts, where responses are in the rows and cells in the columns. A given entry \\(y_{ij}\\) of \\(Y\\) indicates the number of UMIs from response \\(i\\) sequenced in cell \\(j\\). Similarly, let \\(G \\in \\mathbb{N}^{r \\times n}\\) be the matrix of gRNA UMI counts; a given entry \\(g_{ij}\\) of \\(G\\) indicates the number of UMIs from gRNA \\(i\\) sequenced in cell \\(j\\). Finally, let \\(Z \\in \\mathbb{N}^{n\\times p}\\) be the matrix of cell-specific covariates, which can include variables such as response_n_umis, response_n_nonzero, grna_n_umis, grna_n_nonzero, response_p_mito, batch, and cell type."
  },
  {
    "objectID": "methods.html#assigning-grnas-to-cells",
    "href": "methods.html#assigning-grnas-to-cells",
    "title": "7  Overview of methods",
    "section": "7.2 Assigning gRNAs to cells",
    "text": "7.2 Assigning gRNAs to cells\nThe first statistical task involved in single-cell CRISPR screen analysis is to assign gRNAs to cells. The gRNA assignment task involves leveraging the gRNA count matrix \\(G\\) (and possibly the covariate matrix \\(Z\\)) to impute the (unobserved) binary matrix \\(X \\in \\{0,1\\}^{r \\times n}\\) of gRNA presences and absences, where a given entry \\(x_{ij}\\) of \\(X\\) is defined to be \\(1\\) (resp., \\(0\\)) if gRNA \\(i\\) is present (resp., absent) in cell \\(j\\). sceptre implements three gRNA assignment strategies: the thresholding method, maximum method, and the mixture method. All three methods account for background contamination, the phenomenon by which gRNA reads sometimes map to cells that do not contain the corresponding gRNA. (See Section 3 of the introductory chapter for a real-data example of background contamination.) We describe each method in greater depth here.\n\n7.2.1 Thresholding and maximum methods\nThe thresholding method assigns a gRNA to a cell if the UMI count of the gRNA in the cell exceeds some integer threshold \\(c \\in \\mathbb{N}\\). Formally, the thresholding method sets \\(x_{ij}\\) to \\(1\\) if \\(g_{ij} \\geq c\\) and to \\(0\\) if \\(g_{ij} &lt; c\\). The default value for \\(c\\) is 5 (as proposed in Gasperini et al. (2019) and further validated by Barry, Roeder, and Katsevich (2022)). An important special case is to set \\(c\\) to \\(1\\), which corresponds to the “naive” (but occasionally useful) strategy of assigning any gRNA expressed in a given cell to that cell (and ignoring background contamination). The thresholding method is available in both low- and high-MOI settings in sceptre.\nThe maximum method assigns the gRNA exhibiting the greatest UMI count in a given cell to that cell. Formally, consider a given cell \\(j\\); the UMI count of gRNA \\(i\\) in cell \\(j\\) is \\(g_{ij}\\). Let \\(i^* \\in \\{1, \\dots, r\\}\\) be the index such that \\[ g_{i^*j} = \\max_{i \\in \\{1, \\dots, r\\}}{g_{ij}}.\\] (If multiple indices satisfy this criterion, select \\(i^*\\) among these arbitrarily.) We assign gRNA \\(i^*\\) to cell \\(j\\), i.e. we set \\(x_{i^*j}\\) to \\(1\\) and \\(x_{ij}\\) to \\(0\\) for \\(i \\neq i^*\\). In carrying out the maximum assignment step, sceptre also flags cells that likely contain multiple gRNAs. Let \\(u \\in [0,1]\\) be a user-specified threshold (default value \\(0.8\\)). Suppose that the gRNA assigned to cell \\(j\\) constitutes fewer than \\(u\\) of the UMIs in that cell. In other words, suppose that\n\\[\n\\frac{g_{i^*j}}{\\sum_{i=1}^{r} g_{ij}} &lt; u.\n\\]\nThen cell \\(j\\) is flagged as containing multiple gRNAs and is removed as part of the QC step. (Note that if multiple gRNAs are tied for most highly expressed in a given cell, and if \\(u &gt; 0.5\\), then that cell is flagged as containing multiple gRNAs, per the above rule.) The maximum method is available only in the low-MOI setting in sceptre.\n\n\n7.2.2 Mixture method\nThe mixture method assigns gRNAs to cells using a latent variable generalized linear model (GLM). Consider a given gRNA \\(i\\). Let \\(g_j\\) be the UMI count of gRNA \\(i\\) in cell \\(j\\), and let \\(x_j\\) be the (unobserved) variable indicating whether gRNA \\(i\\) is present (\\(x_j = 1\\)) or absent (\\(x_j = 0\\)) in cell \\(j\\). (We drop the \\(i\\) subscript for notational compactness.) Additionally, let \\(z_j\\) be the vector of cell-specific covariates in cell \\(j.\\) (We assume that the count-based covariates, such as grna_n_nonzero and grna_n_umis, have been log-transformed, which sceptre does by default.) We model the gRNA UMI counts using a latent variable Poisson GLM:\n\\[\n\\begin{cases}\ng_j | \\mu_j \\sim \\textrm{Pois}(\\mu_j) \\\\\n\\log(\\mu_j | x_j, z_j) = \\beta_0 + \\gamma x_j + \\beta^T z_j \\\\\nx_j \\sim \\textrm{Bernoulli}(\\pi).\n\\end{cases}\n\\tag{7.1}\\]\nHere, \\(\\mu_j\\) is the mean expression level of gRNA \\(i\\) in cell \\(j\\) (given the covariates); \\(\\beta_0\\), \\(\\gamma\\), and \\(\\beta \\in \\mathbb{R}^d\\) are the (unknown) regression coefficients; and \\(\\pi \\in [0,1]\\) is the (unknown) probability that gRNA \\(i\\) is present in a given cell. We fit the model Equation 7.1 using an EM algorithm, producing estimates \\(\\hat{\\beta}_0\\), \\(\\hat{\\gamma}\\), \\(\\hat{\\beta}\\), and \\(\\hat{\\pi}\\) for the model coefficients \\(\\beta_0\\), \\(\\gamma\\), \\(\\beta\\), and \\(\\pi\\). Using these estimates, we can compute the probability \\(T_{ij} := \\mathbb{P}(x_{ij} = 1)\\) that a given cell \\(j\\) contains gRNA \\(i\\). (The probabilities \\(T_{i1}, \\dots, T_{in}\\) are sometimes called “posterior probabilities.”) Finally, we threshold the posterior probabilities at some threshold \\(u\\) (default value 0.8) to assign gRNA \\(i\\) to the cells, i.e. we set \\(x_{ij} = 1\\) if \\(T_{ij} &gt; u\\) and \\(x_{ij} = 0\\) if \\(T_{ij} \\leq u\\). An advantage of the Poisson GLM framework is that it enables us to account for cell-specific covariates that might affect the level of background contamination, such as the number of gRNA UMIs sequenced in a given cell (i.e., grna_n_umis). The mixture method is available in both low- and high-MOI settings in sceptre.\nFormulating the model Equation 7.1 is fairly straightforward; fitting the model to data in a fast and numerically stable way is more challenging. sceptre leverages a novel variant of the EM algorithm for this purpose, which we describe below.\nApproximating the model Equation 7.1 with a simpler model. We begin by approximating the latent variable model Equation 7.1 with a simpler latent variable model that is easier to estimate. First, we obtain accurate estimates for the parameters \\(\\beta_0\\) and \\(\\beta\\) by exploiting the fact that the gRNA is present in only a small fraction (typically \\(&lt; 2\\%\\)) of cells. Let \\(f(g_j; \\mu_j)\\) denote the probability mass function of the Poisson distribution with mean \\(\\mu_j\\) evaluated at \\(g_j\\), i.e.,\n\\[\nf(g_j; \\mu_j) = \\frac{\\mu_j^{g_j} e^{-\\mu_j}}{g_j!}.\n\\]Conditioning on the covariates (i.e., treating \\(x_j\\) and \\(z_j\\) as fixed), we can express the log-likelihood of the GLM in Equation 7.1 as follows:\n\\[\n\\begin{multline}\nL(\\beta_0, \\gamma, \\beta^T) = \\sum_{j=1}^n \\log \\left[ f(g_j;\\mu_j )\\right] = \\sum_{j=1}^n \\log \\left[ f(g_j; \\exp(\\beta_0 + \\gamma x_j + \\beta^T z_j)) \\right] \\\\ = \\underbrace{\\sum_{j:x_j = 1} \\log \\left[ f(g_j; \\exp(\\beta_0 + \\gamma + \\beta^T z_j)) \\right]}_{\\textrm{few terms}} + \\underbrace{\\sum_{j: x_j = 0} \\log \\left[ f(g_j; \\exp(\\beta_0 + \\beta^T z_j)) \\right]}_\\textrm{many terms} \\\\ \\approx \\sum_{j=1}^n \\log \\left[ f(g_j; \\exp(\\beta_0 + \\beta^T z_j)) \\right].\n\\end{multline}\n\\]\nIn words, the gRNA indicator \\(x_j\\) is equal to zero in the large majority of cells, and so we can approximate the GLM in Equation 7.1 with the GLM that results from excluding \\(x_j\\) from the model:\n\\[\n\\begin{cases}\ng_j | \\mu_j \\sim \\textrm{Pois} (\\mu_j) \\\\\n\\log(\\mu_j | z_j) = \\beta_0 + \\beta^T z_j.\n\\end{cases}\n\\tag{7.2}\\]\nWe can fit the GLM Equation 7.2 using the standard procedure for fitting GLMs (e.g., in R), as the covariates in this GLM are observed. Doing so yields estimates \\(\\hat{\\beta}_0\\) and \\(\\hat{\\beta}\\) for \\(\\beta_0\\) and \\(\\beta\\), respectively. Assuming that \\(\\hat{\\beta_0} \\approx \\beta_0\\) and \\(\\hat{\\beta} \\approx \\beta\\) (which holds for large \\(n\\) and small \\(\\pi\\)), we can write\n\\[\\gamma x_j + \\beta_0 x_j + \\beta z_j \\approx \\gamma x_j + \\hat{\\beta}_0 + \\hat{\\beta} z_j = \\gamma x_i + o_j,\\]where we have set \\(o_j\\) to \\(\\hat{\\beta}_0 + \\hat{\\beta}z_j\\), i.e. the \\(j\\)th fitted value (on the scale of the linear component) of the GLM Equation 7.2. Finally, we propose a simplified model for expression of the gRNA:\n\\[\\begin{cases}\ng_j | \\mu_j \\sim \\textrm{Pois}(\\mu_j) \\\\\n\\log(\\mu_j | x_j) = \\gamma x_j + o_j \\\\\nx_j \\sim \\textrm{Bernoulli}(\\pi).\n\\end{cases}\n\\tag{7.3}\\]\nHere, the \\(o_j\\)s are offset terms in the GLM. Notice that the GLM in Equation 7.3 does not include covariates or an intercept term; rather, all information about the covariates and the baseline expression level of the gRNA has been “encoded” into the offsets \\(o_1, \\dots, o_n\\). In summary we (i) estimated \\(\\beta_0\\) and \\(\\beta\\) using the GLM Equation 7.2 and then (ii) replaced \\(\\beta_0\\) and \\(\\beta\\) in Equation 7.1 with their corresponding estimates, yielding the model Equation 7.3. The model Equation 7.3 is a good approximation to Equation 7.1 in the sense that the maximum likelihood estimates for \\(\\gamma\\) and \\(\\pi\\) in Equation 7.3 are close to the corresponding estimates for these parameters in Equation 7.1 when \\(n\\) is large and \\(\\pi\\) is small (as is the case on most single-cell CRISPR screen datasets). We turn our attention to estimating the model Equation 7.3, treating the offset terms \\(o_1, \\dots, o_n\\) as known and fixed.\nEM algorithm. We derive an EM algorithm to estimate the model Equation 7.3. Let \\(\\theta = (\\gamma, \\pi)\\) denote the unknown model parameters. Let \\(G_j\\) be a random variable that represents the UMI count of the gRNA in the \\(j\\)th cell, and let \\(g_j\\) be the realized value of this random variable. (Similarly, let \\(x_j\\) be the realized value of the random variable \\(X_j\\).) We begin by writing down the complete-data likelihood \\(l\\) of this model, which is the likelihood that would result if \\(x_1, \\dots, x_n\\) had been observed.\n\\[\n\\begin{multline*}\nl(\\theta) = \\prod_{j=1}^n \\mathbb{P}(G_j = g_j, X_j = x_j) = \\prod_{j=1}^n\\mathbb{P}(G_j = g_j | X_j = x_j) \\mathbb{P}(X_j = x_j) \\\\ = \\prod_{j=1}^n f(g_j; \\exp( \\gamma x_j + o_j))\\left[\\pi^{x_i} (1-\\pi)^{1-x_i} \\right].\n\\end{multline*}\n\\]\nWe obtain the complete-data log-likelihood \\(L\\) by taking the log of \\(l\\):\n\\[\nL(\\theta) = \\log(l(\\theta)) = \\sum_{j=1}^n \\log\\left[ f(g_j; \\exp(\\gamma x_j + o_j)\\right] + \\sum_{j=1}^n x_j \\log(\\pi) + (1-x_j)(1-\\pi).\n\\]\nWe derive the E and M steps for the EM algorithm in this model.\nE step: The E step entails computing the membership probability of each cell (i.e., the probability that each cell contains the gRNA given the current parameter estimates and the observed gRNA counts). Let \\(\\theta^{(t)} = (\\gamma^{(t)}, \\pi^{(t)})\\) be the parameter estimate for \\(\\theta\\) at the \\(t\\)th iteration of the algorithm. The \\(j\\)th membership probability at the \\(t\\)th iteration of the algorithm \\(T^{(t)}_j\\) is defined as \\(T^{(t)}_j = \\mathbb{P}(X_j = 1 | G_j = g_j, \\theta^{(t)}).\\) Let \\([\\mu_j(k)]^{(t)}\\) be the mean gRNA UMI count in the \\(j\\)th cell at the \\(t\\)th iteration of the algorithm that results from setting \\(x_j\\) to \\(k \\in \\{0,1\\}\\), i.e.,\n\\[\n[\\mu_j(k)]^{(t)} = \\exp( \\gamma^{(t)} \\cdot k + o_j ).\n\\]\nApplying Bayes rule, we can express the membership probability \\(T^{(t)}_j\\) as\n\\[\n\\begin{multline*}\nT^{(t)}_j = \\mathbb{P}(X_j = 1 | G_j = g_j, \\theta^{(t)}) = \\frac{\\mathbb{P}(G_j = g_j | X_j = 1, \\theta^{(t)})\\mathbb{P}(X_j = 1 | \\theta^{(t)})}{ \\sum_{k=0}^1 \\mathbb{P}(G_j = g_j | X_j = k, \\theta^{(t)}) \\mathbb{P}(X_j = k | \\theta^{(t)})} \\\\ = \\left(\\frac{\\mathbb{P}(G_j = g_j | X_j = 0, \\theta^{(t)}) \\mathbb{P}(X_j = 0)}{\\mathbb{P}( G_j = g_j | X_j = 1, \\theta^{(t)}) \\mathbb{P}(X_j = 1)} +1\\right)^{-1} = \\left(\\frac{f(g_j; [\\mu_j(0)]^{(t)})(1-\\pi^{(t)}))}{f(g_j; [\\mu_j(1)]^{(t)})\\pi^{(t)})} + 1 \\right)^{-1} \\\\ = \\left(\\exp(q_j^{(t)}) + 1 \\right)^{-1},\n\\end{multline*}\n\\] where we define \\[q_j^{(t)} := \\log\\left( \\frac{f(g_j; [\\mu_j(0)]^{(t)})(1-\\pi^{(t)})}{f(g_j; [\\mu_j(1)]^{(t)})\\pi^{(t)}} \\right).\\]\nPlugging in the Poisson probability mass function for \\(f\\), we can express \\(q_j^{(t)}\\) is follows.\n\\[\n\\begin{multline*}\nq_j^{(t)} := \\log(1-\\pi^{(t)}) - \\log(\\pi^{(t)}) + g_j \\left(\\log([\\mu_j(0)]^{(t)}) - \\log([\\mu_j(1)]^{(t)}) \\right) \\\\ + [\\mu_j(1)]^{(t)} - [\\mu_j(0)]^{(t)}.\n\\end{multline*}\n\\tag{7.4}\\]\nThis expression Equation 7.4 for \\(q_j^{(t)}\\) is numerically stable and fast to evaluate. In summary the M step consists of computing \\(T^{(t)}_j\\) for all \\(j\\in\\{1, \\dots, n\\}\\) by computing \\(q^{(t)}_j\\) (using Equation 7.4) and then evaluating \\(T^{(t)}_j = \\exp(q_j^{(t)} + 1)^{-1}.\\)\nM step: The M-step involves maximizing the so-called “Q function,” which is the function that results from taking the expectation of the complete-data log-likelihood with respect to the \\(X_j\\)s while conditioning on the \\(G_j\\)s and the current parameter estimates \\(\\theta^{(t)}\\). Formally, the Q function \\(Q(\\theta | \\theta^{(t)})\\) is defined as \\(Q(\\theta|\\theta^{(t)}) = \\mathbb{E}_{X_1, \\dots, X_n}[L(\\theta) | G_1 = g_1, \\dots, G_n = g_n \\theta^{(t)}]\\). We can express the Q function as\n\\[\n\\begin{multline*}\nQ(\\theta|\\theta^{(t)}) = \\sum_{j=1}^n T^{(t)}_j \\log(\\pi) + \\sum_{j=1}^n (1 - T_j^{(t)})\\log(1-\\pi) \\\\ + \\sum_{j=1}^n T_j^{(t)} \\log \\left[ f\\left(g_j; \\exp[\\gamma + o_j] \\right) \\right] + \\sum_{j=1}^n (1 - T^{(t)}_j) \\log \\left[f(g_j; \\exp(o_j) \\right].\n\\end{multline*}\n\\tag{7.5}\\]\nThe goal of the M step to identify the parameter \\(\\theta = (\\pi, \\gamma)\\) that maximizes Equation 7.5. The first two terms of Equation 7.5 are a function of \\(\\pi\\), and the last two terms are a function of \\(\\gamma\\). Thus, we can optimize these sets of terms separately.\nTo find the maximizer in \\(\\pi\\), we differentiate the first two terms of Equation 7.5 with respect to \\(\\pi\\), yielding\n\\[\n\\frac{\\sum_{j=1}^n T_j^{(t)}}{\\pi} - \\frac{\\sum_{j=1}^n (1 - T_j^{(t)})}{1 - \\pi}.\n\\tag{7.6}\\]\nSetting Equation 7.6 to zero and solving for \\(\\pi\\) produces the maximizer \\(\\pi^{(t+1)}\\):\n\\[ \\pi^{(t+1)} = (1/n) \\sum_{j=1}^n T_j^{(t)}. \\tag{7.7}\\]\nWe turn our attention to the last two terms of Equation 7.5. The final term is not a function of \\(\\gamma\\) and thus can be ignored. We rewrite the penultimate term as follows:\n\\[\n\\begin{multline*}\n\\sum_{j=1}^n T^{(t)}_j \\log\\left[ f(g_j; \\exp[\\gamma + o_j])\\right] \\\\ = \\sum_{j=1}^n T^{(t)}_j \\log\\left[ \\frac{\\exp(\\gamma + o_j)^{g_j} \\exp(-\\exp[\\gamma + o_j])}{g_j!} \\right] \\\\ =\n\\sum_{j=1}^n T_j^{(t)}\\left[ g_j(\\gamma + o_j) - \\exp(\\gamma + o_j) - \\log(g_j!) \\right].\n\\end{multline*}\n\\tag{7.8}\\]\nThe derivative of Equation 7.8 with respect to \\(\\gamma\\) is\n\\[\n\\begin{multline*}\n\\sum_{j=1}^n T^{(t)}_j g_j - T^{(t)}_j \\exp(\\gamma + o_j) = \\sum_{j=1}^n T^{(t)}_j g_j - \\exp(\\gamma) \\sum_{j=1}^n T_j^{(t)} \\exp(o_j).\n\\end{multline*}\n\\tag{7.9}\\]\nFinally, setting Equation 7.9 to zero and solving for \\(\\gamma\\) yields the maximizer\n\\[\n\\gamma^{(t+1)} = \\log\\left(\\frac{\\sum_{j=1}^n T^{(t)}_j y_j }{\\sum_{j=1}^n T^{(t)}_j e^{o_j} }\\right).\n\\tag{7.10}\\]\nIn summary the M step entails computing the updated parameter estimates \\(\\pi^{(t+1)}\\) and \\(\\gamma^{(t+1)}\\) using the formulas Equation 7.7 and Equation 7.10, respectively.\nConvergence: The incomplete-data likelihood (which we obtain by integrating the complete-data likelihood with respect to the \\(x_j\\)s) is\n\\[\nl_\\textrm{incomplete}(\\theta) = \\prod_{j=1}^n f(g_j; \\gamma + o_j) \\pi + f(g_j; o_j)(1-\\pi).\n\\]\nThe incomplete-data log-likelihood is\n\\[\nL_\\textrm{incomplete}(\\theta) = \\log(l_\\textrm{incomplete}(\\theta)) = \\sum_{j=1}^n \\log\\left[ f(g_j; \\gamma + o_j) \\pi + f(g_j; o_j)(1-\\pi) \\right].\n\\]\nNote that the incomplete-data log-likelihood — in contrast to the complete-data log-likelihood — is computable (albeit hard to optimize directly). We iterate between E and M steps until \\(L_\\textrm{incomplete}\\) converges. We declare that the sequence of estimates \\(\\theta^{(0)}, \\theta^{(1)}, \\theta^{(2)}, \\dots\\) has converged when\n\\[\n\\frac{|L_\\textrm{incomplete}(\\theta^{(t+1)}) - L_\\textrm{incomplete}(\\theta^{(t)})|}{ \\min\\left\\{ |L_\\textrm{incomplete}(\\theta^{(t+1)})|, |L_\\textrm{incomplete}(\\theta^{(t)}) | \\right\\}} &lt; \\epsilon\n\\]\nfor some \\(\\epsilon &gt; 0\\) (by default \\(\\epsilon = 0.5 \\cdot 10^{-4}\\)). We set the final parameter estimates \\(\\hat{\\pi}\\) and \\(\\hat{\\gamma}\\) to \\(\\pi^{(t+1)}\\) and \\(\\gamma^{(t+1)}\\). Additionally, we use the final membership probabilities \\(T^{(t+1)}_1, \\dots, T^{(t+1)}_n\\) to assign the gRNA to cells.\nAs is standard, we run the EM algorithm several times over random starting estimates for \\(\\pi\\) and \\(\\gamma\\) to improve chances of converging to the global maximizer of the incomplete-data likelihood. We take the run whose estimates yield the greatest incomplete-data log-likelihood as the final run."
  },
  {
    "objectID": "accelerations.html",
    "href": "accelerations.html",
    "title": "8  Statistical and computational accelerations",
    "section": "",
    "text": "We expect some of these techniques to be useful in applications beyond single-cell CRISPR screens."
  },
  {
    "objectID": "glossary.html#assay-design",
    "href": "glossary.html#assay-design",
    "title": "Appendix A — Glossary",
    "section": "\nA.1 Assay design",
    "text": "A.1 Assay design\nThe following terms describe the design of pooled single-cell CRISPR screen assays, where the goal is to perturb a set of genomic targets and measure the effects of these perturbations on a set of molecular phenotypes.\n\nPerturbation: A change to the genome of a cell carried out by the CRISPR-Cas9 system or one of its variants. Common perturbations include CRISPRko (knockout via nuclease-active Cas9), CRISPRi (inactivation via dCas9 tethered to a repressive domain), CRISPRa (activation via dCas9 tethered to an activating domain).\nGuide RNA (gRNA): An RNA guiding the Cas9 (or one of its variants) to its target in order to perturb it.\nTarget: The genomic element targeted by a gRNA. Possible targets include gene transcription start sites and noncoding elements such as enhancers, silencers, and noncoding GWAS variants.\nTargeting gRNA: A gRNA that is intended to perturb a genomic target.\nNon-targeting gRNA: A gRNA whose barcode sequence either does not map anywhere in the genome or maps to a location whose perturbation is known to have no effect. Non-targeting gRNAs serve as negative controls.\nResponse: A molecular phenotype readout in the single-cell CRISPR screen, whose response to CRISPR perturbation is of interest. Possible responses include genes, proteins, and chromatin-derived features.\nMultiplicity of infection (MOI): The MOI of a screen can be categorized as low or high and also can also be numerically quantified. A high-MOI (respectively, low-MOI) dataset is one in which the experimenter has aimed to insert multiple gRNAs (respectively, a single gRNA) into each cell. Quantitatively, the MOI of a screen is the average number of gRNAs delivered per cell. For example, an MOI of 10 means that on average each cell receives 10 gRNAs."
  },
  {
    "objectID": "glossary.html#hypothesis-construction",
    "href": "glossary.html#hypothesis-construction",
    "title": "Appendix A — Glossary",
    "section": "\nA.2 Hypothesis construction",
    "text": "A.2 Hypothesis construction\nThe main statistical task in single-cell CRISPR screen analysis is to test hypotheses of the form: Does perturbing a target impact a response? We use the following terminology to describe the construction of such hypotheses.\n\n\nTarget-response pair: A pair consisting of a target and a response. For example, a target-response pair could be a specific enhancer and a specific gene. Each target-response pair corresponds to a hypothesis to be tested: Does perturbing the target impact the response?\nNegative control pair: A target-response pair in which the target is a non-targeting gRNA. Negative control pairs are used to assess the calibration of a statistical analysis method.\nPositive control pair: A target-response pair in which the target is a targeting gRNA known to have an effect on the response. For example, a positive control pair may consist of a gRNA targeting a transcription start site coupled to the gene regulated by that transcription start site. Positive control pairs are used to assess the power of a statistical analysis method.\nDiscovery pair: A target-response pair in which the target is a targeting gRNA whose effect on the response is unknown. The main goal of a single-cell CRISPR screen is to search for new associations among discovery pairs.\nCis pair: A target-response pair in which the target and response are located in close proximity on the same chromosome. For example, a cis pair may consist of a gRNA targeting an enhancer and a gene whose transcription start site is located a few kilobases away.\nTrans pair: A target-response pair for which the target and response are not necessarily located in close proximity or on the same chromosome as one another.\nPairwise quality control: A procedure for filtering out target-response pairs whose data are too sparse to be analyzed reliably. Pairwise quality control is based on metrics that take into account the sparsity of the response variable and the number of cells in which the target has been perturbed.\nCellwise quality control: A procedure for filtering out cells whose data suggest aberrations in the library preparation or sequencing processes. This common step in single-cell sequencing analyses (not just CRISPR screens) is based on metrics like the total number of UMIs detected in a cell and the percentage of UMIs mapping to mitochondrial genes."
  },
  {
    "objectID": "glossary.html#statistical-methodologies",
    "href": "glossary.html#statistical-methodologies",
    "title": "Appendix A — Glossary",
    "section": "\nA.3 Statistical methodologies",
    "text": "A.3 Statistical methodologies\nThe following terms describe the statistical methodologies used in single-cell CRISPR screen analysis. Their main focus is to compare the responses of cells that have been perturbed with those that have not.\n\nTreatment group: The group of cells for which a given target has been perturbed.\nControl group: A group of cells for which a given target has not been perturbed, which serve as a point of comparison to the treatment group. The control group is typically either the non-targeting set or the complement set; see below.\nNon-targeting set: The set of cells to which only a non-targeting gRNA has been delivered. This is the most common control group for low-MOI screens.\nComplement set: The set of cells for which a given target has not been perturbed (but for which other targets may have been perturbed). This is the most common control group for high-MOI screens.\nCovariate: An unwanted source of variation that may affect (the measurement of) the response and/or the perturbations in a cell. Covariates can be technical (relating to the library preparation or sequencing processes) or biological (relating to the cell itself). Common technical covariates include the sequencing depth of a cell and the number of gRNAs inserted into a cell; common biological covariates include cell cycle stage and cell type.\n\nFormula object: A formula object specifies the covariates and their transformations that should be used adjusted for in a statistical analysis method. An example of a formula object is\n\n~ log(response_n_nonzero) + log(response_n_umis) + response_p_mito + batch\n\n\nResampling: A computer-based procedure for estimating the null distribution of a test statistic that circumvents the use of asymptotic approximations (which may not hold for sparse single-cell data). Resampling procedures include the permutation test and the conditional randomization test (see below).\nPermutation test: A resampling procedure for estimating the null distribution of a test statistic based on permuting the treatment and control labels of the cells and recomputing the test statistic.\nConditional randomization test: A resampling procedure for estimating the null distribution of a test statistic based on randomly reassigning the treatment and control labels of the cells based on their covariate values.\nSkew-normal distribution: A generalization of the Gaussian distribution that has three parameters: a mean parameter, a variance parameter, and a skew parameter. The skew parameter controls the extent to which the distribution is asymmetric relative to a Gaussian distribution.\nMultiple testing procedure: A procedure that inputs a list of p-values for a set of target-response pairs and outputs a subset of these pairs that are deemed to have a statistically significant relationship. The most common multiple testing procedure is the Benjamini-Hochberg procedure, which aims to control the false discovery rate (see below) at a prespecified level, such as 0.1."
  },
  {
    "objectID": "glossary.html#statistical-properties-and-their-assessment",
    "href": "glossary.html#statistical-properties-and-their-assessment",
    "title": "Appendix A — Glossary",
    "section": "\nA.4 Statistical properties and their assessment",
    "text": "A.4 Statistical properties and their assessment\nThe following terms describe the statistical properties of an analysis method (whether sceptre or otherwise) and how they are assessed. These statistical properties are essential to making reliable conclusions based on single-cell CRISPR screen data.\n\nFalse discovery rate (FDR): The proportion of the statistically significant target-response pairs returned by a multiple testing procedure that are false positives. A high FDR indicates significant contamination by false positives, making the underlying statistical methodology unreliable.\nCalibration: The extent to which the p-values returned by a statistical analysis method are uniformly distributed under the null hypothesis. A well-calibrated method will return p-values that, when processed by a multiple testing procedure, will result in an FDR close to the desired level.\nPower: Otherwise known as sensitivity, power is the ability of a statistical analysis method to detect true associations. For example, a method has high power if it can detect many of the true associations with high probability.\nCalibration check: A procedure for assessing the calibration of a statistical analysis method. A calibration check typically proceeds by applying the method to a set of negative control pairs and then checking the extent to which the resulting p-values are uniformly distributed.\nPower check: A procedure for assessing the power of a statistical analysis method. A power check typically proceeds by applying the method to a set of positive control pairs and then checking the extent to which the resulting p-values are small.\nQQ plot: A plot used to compare the set of p-values outputted by a method to the uniform distribution, which is the null distribution of a well-calibrated method. A QQ plot of the p-values returned by a method for a set of negative control pairs therefore can be used to check the method’s calibration. Visually, a well-calibrated method will produce a QQ plot that is close to the diagonal."
  },
  {
    "objectID": "faq.html#i-am-trying-to-install-sceptre-but-i-am-getting-an-error.-what-should-i-do",
    "href": "faq.html#i-am-trying-to-install-sceptre-but-i-am-getting-an-error.-what-should-i-do",
    "title": "Appendix B — Frequently asked questions",
    "section": "\nB.1 I am trying to install sceptre, but I am getting an error. What should I do?",
    "text": "B.1 I am trying to install sceptre, but I am getting an error. What should I do?\nThe first thing to do is to remove any previous installations of sceptre and then try again. First, determine the directory on your computer in which R packages are stored by executing .libPaths() in the R console.\n\n.libPaths()\n\n[1] \"/Library/Frameworks/R.framework/Versions/4.2/Resources/library\"\n\n\nNext, within your terminal, cd to this directory and then execute rm -rf sceptre.\n\n\nTerminal\n\ncd /Library/Frameworks/R.framework/Versions/4.2/Resources/library # change me!\nrm -rf sceptre\n\nNow, try to install sceptre again.\nIf this does not work, try to delete and reinstall the dependencies of sceptre. sceptre has the following dependencies: BH, cowplot, crayon, data.table, dplyr, ggplot2, Matrix, Rcpp. Using the method described above, delete and reinstall each of these dependencies one-by-one."
  },
  {
    "objectID": "faq.html#how-can-i-install-a-previous-version-of-sceptre",
    "href": "faq.html#how-can-i-install-a-previous-version-of-sceptre",
    "title": "Appendix B — Frequently asked questions",
    "section": "\nB.2 How can I install a previous version of sceptre?",
    "text": "B.2 How can I install a previous version of sceptre?\nSee the instructions here."
  },
  {
    "objectID": "faq.html#my-negative-control-p-values-are-miscalibrated.-what-should-i-do",
    "href": "faq.html#my-negative-control-p-values-are-miscalibrated.-what-should-i-do",
    "title": "Appendix B — Frequently asked questions",
    "section": "\nB.3 My negative control p-values are miscalibrated. What should I do?",
    "text": "B.3 My negative control p-values are miscalibrated. What should I do?\nNot to worry! First of all, the extent of the miscalibration may be mild enough not to cause significant issues with your analysis; see Table 5.1 for assessing the severity of your miscalibration. If the miscalibration is moderate to severe, then see Section 5.4 for several suggestions to improve calibration."
  },
  {
    "objectID": "faq.html#how-many-negative-control-grnas-do-i-need",
    "href": "faq.html#how-many-negative-control-grnas-do-i-need",
    "title": "Appendix B — Frequently asked questions",
    "section": "\nB.4 How many negative control gRNAs do I need?",
    "text": "B.4 How many negative control gRNAs do I need?\nThe table below summarizes the minimum number of negative control gRNAs required to run an analysis as a function of the control group (either NT cells or complement set) and analysis type (either calibration check, discovery analysis, or power check). Recall that the default control group for low-MOI screens is the set of NT cells, while the default control group for high-MOI screens is the complement set.\n\nMinimum number of negative control gRNAs required to run an analysis as a function of the control group (vertical axis) and analysis type (horizontal axis).\n\n\n\n\n\n\n\nCalibration check\nDiscovery analysis or power check\n\n\n\nNT cells\n2\n1\n\n\nComplement set\n0\n0\n\n\n\nIn general having more negative control gRNAs is better. We recommend including at least ten to fifteen negative control gRNAs in the assay for the best chance of obtaining high-quality results."
  },
  {
    "objectID": "faq.html#sec-multiple_analyses",
    "href": "faq.html#sec-multiple_analyses",
    "title": "Appendix B — Frequently asked questions",
    "section": "\nB.5 How should I run multiple sceptre analyses?",
    "text": "B.5 How should I run multiple sceptre analyses?\nSometimes users wish to carry out multiple sceptre analyses on a single dataset, such as\n\nrunning cis and trans analyses;\nrunning analyses with gRNAs grouped based on target and with singleton gRNAs.\n\nHere we demonstrate how to do this efficiently. We begin by loading the sceptre package.\n\nlibrary(sceptre)\n\nWelcome to sceptre.\nSubmit issues on the sceptre website: github.com/Katsevich-Lab/sceptre\nRead the sceptre manual: timothy-barry.github.io/sceptre-book/\n\n\n\nB.5.1 Running cis and trans analyses\nSome users may wish to run both a cis analysis and a trans analysis. We recommend that such users apply the sceptre pipeline twice: once to analyze the cis pairs and once to analyze the trans pairs. We illustrate this approach on the high-MOI CRISPRi data; we begin by creating a sceptre_object to represent these data.\n\nsceptre_object &lt;- import_data(\n  response_matrix = highmoi_example_data$response_matrix,\n  grna_matrix = highmoi_example_data$grna_matrix,\n  grna_target_data_frame = grna_target_data_frame_highmoi,\n  moi = \"high\",\n  extra_covariates = highmoi_example_data$extra_covariates,\n  response_names = highmoi_example_data$gene_names\n)\n\nFirst, we carry out an analysis of the cis pairs, storing the results in the directory \"~/sceptre_results_cis\".\n\n# positive control pairs\npositive_control_pairs &lt;- construct_positive_control_pairs(sceptre_object)\n\n# cis pairs\ndiscovery_pairs_cis &lt;- construct_cis_pairs(\n  sceptre_object = sceptre_object,\n  positive_control_pairs = positive_control_pairs,\n  distance_threshold = 5e6\n)\n# run cis analysis\nsceptre_object &lt;- sceptre_object |&gt;\n  set_analysis_parameters(\n    discovery_pairs = discovery_pairs_cis,\n    positive_control_pairs = positive_control_pairs,\n    side = \"left\"\n  ) |&gt;\n  assign_grnas(parallel = TRUE) |&gt;\n  run_qc(p_mito_threshold = 0.075) |&gt;\n  run_calibration_check(parallel = TRUE) |&gt;\n  run_power_check(parallel = TRUE) |&gt;\n  run_discovery_analysis(parallel = TRUE)\n\n# write outputs\nwrite_outputs_to_directory(\n  sceptre_object = sceptre_object,\n  directory = \"~/sceptre_results_cis\"\n)\n\nNext, we carry out an analysis of the trans pairs, storing the results in \"~/sceptre_results_trans\".\n\n# trans pairs\ndiscovery_pairs_trans &lt;- construct_trans_pairs(\n  sceptre_object = sceptre_object,\n  positive_control_pairs = positive_control_pairs,\n  exclude_positive_control_targets = TRUE\n)\n# run trans analysis\nsceptre_object &lt;- sceptre_object |&gt;\n  set_analysis_parameters(\n    discovery_pairs = discovery_pairs_trans,\n    positive_control_pairs = positive_control_pairs,\n    side = \"both\"\n  ) |&gt;\n  assign_grnas(parallel = TRUE) |&gt;\n  run_qc(p_mito_threshold = 0.075) |&gt;\n  run_calibration_check(parallel = TRUE) |&gt;\n  run_power_check(parallel = TRUE) |&gt;\n  run_discovery_analysis(parallel = TRUE)\n\n# write outputs\nwrite_outputs_to_directory(\n  sceptre_object = sceptre_object,\n  directory = \"~/sceptre_results_trans\"\n)\n\nNote that we update the sceptre_object with the output of the cis analysis. We then use the same sceptre_object to carry out the trans analysis. Under the hood sceptre stores (or “caches”) intermediate computations carried out as part of the cis analysis inside the sceptre_object. These intermediate computations are then recycled to carry out the trans analysis, thereby reducing compute.\n\nB.5.2 Running singleton and grouped analyses\nAnother common analysis paradigm is to run both a grouped analysis (in which gRNAs targeting the same site are integrated or “combined”) and a singleton analysis (in which gRNAs targeting the same site are analyzed individually). We carried out a grouped analysis of the cis pairs on the high-MOI CRISPRi data above. Below, we conduct a singleton analysis on the same set of pairs, storing the result in \"~/sceptre_results_cis_singleton\". We operate on the same sceptre_object so as to exploit caching.\n\n# singleton cis analysis\nsceptre_object &lt;- sceptre_object |&gt;\n  set_analysis_parameters(\n    discovery_pairs = discovery_pairs_cis,\n    positive_control_pairs = positive_control_pairs,\n    side = \"left\",\n    grna_integration_strategy = \"singleton\"\n  ) |&gt;\n  assign_grnas(parallel = TRUE) |&gt;\n  run_qc(p_mito_threshold = 0.075) |&gt;\n  run_calibration_check(parallel = TRUE) |&gt;\n  run_power_check(parallel = TRUE) |&gt;\n  run_discovery_analysis(parallel = TRUE)\n\n# write outputs\nwrite_outputs_to_directory(\n  sceptre_object = sceptre_object,\n  directory = \"~/sceptre_results_cis_singleton\"\n)\n\nIn summary, to carry out multiple analyses on the same dataset, users should apply the sceptre pipeline multiple times, reusing the underlying sceptre_object to exploit caching and reduce compute."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Appendix C — References",
    "section": "",
    "text": "Barry, Timothy, Kaishu Mason, Kathryn Roeder, and Eugene Katsevich.\n2023. “Robust differential expression testing\nfor single-cell CRISPR screens.” bioRxiv.\n\n\nBarry, Timothy, Kathryn Roeder, and Eugene Katsevich. 2022. “Exponential family measurement error models for\nsingle-cell CRISPR screens.” arXiv.\n\n\nBarry, Timothy, Xuran Wang, John A. Morris, Kathryn Roeder, and Eugene\nKatsevich. 2021. “SCEPTRE improves\ncalibration and sensitivity in single-cell CRISPR screen\nanalysis.” Genome Biology 22 (1): 1–19.\n\n\nGasperini, Molly, Andrew J. Hill, José L. McFaline-Figueroa, Beth\nMartin, Seungsoo Kim, Melissa D. Zhang, Dana Jackson, et al. 2019.\n“A Genome-wide Framework for Mapping Gene\nRegulation via Cellular Genetic Screens.” Cell\n176 (1): 377–90.\n\n\nPapalexi, Efthymia, Eleni Mimitou, Andrew W. Butler, Samantha Foster,\nBernadette Bracken, William M. Mauck III, Hans-Hermann Wessels, Bertrand\nZ. Yeung, Peter Smibert, and Rahul Satija. 2021. “Characterizing the molecular regulation of inhibitory\nimmune checkpoints with multi-modal single-cell screens.”\nNature Genetics 53 (3): 322–31."
  },
  {
    "objectID": "methods.html#integrating-information-across-grnas",
    "href": "methods.html#integrating-information-across-grnas",
    "title": "7  Overview of methods",
    "section": "7.5 Integrating information across gRNAs",
    "text": "7.5 Integrating information across gRNAs\nSuppose that gRNAs \\(1, \\dots, k\\) target the same site. Testing each of these gRNAs individually against a given response yields p-values \\(p_1, \\dots, p_k\\).\nTheorem: Suppose that \\(p_1, \\dots, p_k\\) are superuniform, i.e. \\(\\mathbb{P}(p_i \\leq \\alpha) \\leq \\alpha\\) for all \\(i \\in \\{1, \\dots, k\\}\\) and all \\(\\alpha \\in [0,1]\\). Then \\(k \\cdot \\min\\{p_1, \\dots, p_k\\}\\) also is superuniform.\nProof:\n\\[\n\\begin{multline}\n\\mathbb{P}( k \\cdot \\min\\{p_1, \\dots, p_k\\} \\leq \\alpha) = \\mathbb{P}( \\min\\{p_1, \\dots, p_k\\} \\leq \\alpha/k )\\\\ = \\mathbb{P}\\left( p_1 \\leq \\alpha/k \\textrm{ or } \\dots \\textrm{ or } p_k \\leq \\alpha /k  \\right) \\leq \\sum_{i=1}^k \\mathbb{P}(p_i \\leq \\alpha/k) \\leq \\sum_{i=1}^k \\alpha/k = \\alpha.\n\\end{multline}\n\\]\nThe penultimate inequality follows from the union bound, and the final inequality follows from the superuniformity of \\(p_i\\). \\(\\square\\)\n\n\n\n\nBarry, Timothy, Kaishu Mason, Kathryn Roeder, and Eugene Katsevich. 2023. “Robust differential expression testing for single-cell CRISPR screens.” bioRxiv.\n\n\nBarry, Timothy, Kathryn Roeder, and Eugene Katsevich. 2022. “Exponential family measurement error models for single-cell CRISPR screens.” arXiv.\n\n\nBarry, Timothy, Xuran Wang, John A. Morris, Kathryn Roeder, and Eugene Katsevich. 2021. “SCEPTRE improves calibration and sensitivity in single-cell CRISPR screen analysis.” Genome Biology 22 (1): 1–19.\n\n\nGasperini, Molly, Andrew J. Hill, José L. McFaline-Figueroa, Beth Martin, Seungsoo Kim, Melissa D. Zhang, Dana Jackson, et al. 2019. “A Genome-wide Framework for Mapping Gene Regulation via Cellular Genetic Screens.” Cell 176 (1): 377–90."
  },
  {
    "objectID": "methods.html#control-group-analysis-type-and-grna-integration-strategy",
    "href": "methods.html#control-group-analysis-type-and-grna-integration-strategy",
    "title": "7  Overview of methods",
    "section": "7.3 Control group, analysis type and gRNA integration strategy",
    "text": "7.3 Control group, analysis type and gRNA integration strategy\nThe analysis parameters of control group, analysis type, and gRNA integration strategy interact with one another in subtle ways. We clarify the relationship between these analysis parameters here.\nWe begin by introducing some notation. Let \\(\\mathcal{S} =\\{1, \\dots, n\\}\\) denote the set of cells. Let \\(X \\in \\{0,1\\}^{r \\times n}\\) denote the matrix of imputed gRNA presences and absences (as determined in the gRNA assignment step; see Section 7.2). For \\(i \\in \\{1, \\dots, r\\}\\), let \\(G_i\\) denote the set of cells that gRNA \\(i\\) is contained within, i.e. \\(G_i := \\{ j: x_{ij} = 1 \\}.\\) Let \\(\\mathcal{N} \\subset \\{1, \\dots, r\\}\\) denote the non-targeting gRNAs, and let \\(\\mathcal{T} = \\{1,\\dots,r\\} \\setminus \\mathcal{N}\\) denote the discovery and positive control gRNAs. Suppose that quality control has been run on the data."
  },
  {
    "objectID": "methods.html#sec-methods_assign_grnas",
    "href": "methods.html#sec-methods_assign_grnas",
    "title": "7  Overview of methods",
    "section": "7.2 Assigning gRNAs to cells",
    "text": "7.2 Assigning gRNAs to cells\nThe first statistical task involved in single-cell CRISPR screen analysis is to assign gRNAs to cells. The gRNA assignment task involves leveraging the gRNA count matrix \\(G\\) (and possibly the covariate matrix \\(Z\\)) to impute the (unobserved) binary matrix \\(X \\in \\{0,1\\}^{r \\times n}\\) of gRNA presences and absences, where a given entry \\(x_{ij}\\) of \\(X\\) is defined to be \\(1\\) (resp., \\(0\\)) if gRNA \\(i\\) is present (resp., absent) in cell \\(j\\). sceptre implements three gRNA assignment strategies: the thresholding method, maximum method, and the mixture method. All three methods account for background contamination, the phenomenon by which gRNA reads sometimes map to cells that do not contain the corresponding gRNA. (See Section 3 of the introductory chapter for a real-data example of background contamination.) We describe each method in greater depth here.\n\n7.2.1 Thresholding and maximum methods\nThe thresholding method assigns a gRNA to a cell if the UMI count of the gRNA in the cell exceeds some integer threshold \\(c \\in \\mathbb{N}\\). Formally, the thresholding method sets \\(x_{ij}\\) to \\(1\\) if \\(g_{ij} \\geq c\\) and to \\(0\\) if \\(g_{ij} &lt; c\\). The default value for \\(c\\) is 5 (as proposed in Gasperini et al. (2019) and further validated by Barry, Roeder, and Katsevich (2022)). An important special case is to set \\(c\\) to \\(1\\), which corresponds to the “naive” (but occasionally useful) strategy of assigning any gRNA expressed in a given cell to that cell (and ignoring background contamination). The thresholding method is available in both low- and high-MOI settings in sceptre.\nThe maximum method assigns the gRNA exhibiting the greatest UMI count in a given cell to that cell. Formally, consider a given cell \\(j\\); the UMI count of gRNA \\(i\\) in cell \\(j\\) is \\(g_{ij}\\). Let \\(i^* \\in \\{1, \\dots, r\\}\\) be the index such that \\[ g_{i^*j} = \\max_{i \\in \\{1, \\dots, r\\}}{g_{ij}}.\\] (If multiple indices satisfy this criterion, select \\(i^*\\) among these arbitrarily.) We assign gRNA \\(i^*\\) to cell \\(j\\), i.e. we set \\(x_{i^*j}\\) to \\(1\\) and \\(x_{ij}\\) to \\(0\\) for \\(i \\neq i^*\\). In carrying out the maximum assignment step, sceptre also flags cells that likely contain multiple gRNAs. Let \\(u \\in [0,1]\\) be a user-specified threshold (default value \\(0.8\\)). Suppose that the gRNA assigned to cell \\(j\\) constitutes fewer than \\(u\\) of the UMIs in that cell. In other words, suppose that\n\\[\n\\frac{g_{i^*j}}{\\sum_{i=1}^{r} g_{ij}} &lt; u.\n\\]\nThen cell \\(j\\) is flagged as containing multiple gRNAs and is removed as part of the QC step. (Note that if multiple gRNAs are tied for most highly expressed in a given cell, and if \\(u &gt; 0.5\\), then that cell is flagged as containing multiple gRNAs, per the above rule.) The maximum method is available only in the low-MOI setting in sceptre.\n\n\n7.2.2 Mixture method\nThe mixture method assigns gRNAs to cells using a latent variable generalized linear model (GLM). Consider a given gRNA \\(i\\). Let \\(g_j\\) be the UMI count of gRNA \\(i\\) in cell \\(j\\), and let \\(x_j\\) be the (unobserved) variable indicating whether gRNA \\(i\\) is present (\\(x_j = 1\\)) or absent (\\(x_j = 0\\)) in cell \\(j\\). (We drop the \\(i\\) subscript for notational compactness.) Additionally, let \\(z_j\\) be the vector of cell-specific covariates in cell \\(j.\\) (We assume that the count-based covariates, such as grna_n_nonzero and grna_n_umis, have been log-transformed, which sceptre does by default.) We model the gRNA UMI counts using a latent variable Poisson GLM:\n\\[\n\\begin{cases}\ng_j | \\mu_j \\sim \\textrm{Pois}(\\mu_j) \\\\\n\\log(\\mu_j | x_j, z_j) = \\beta_0 + \\gamma x_j + \\beta^T z_j \\\\\nx_j \\sim \\textrm{Bernoulli}(\\pi).\n\\end{cases}\n\\tag{7.1}\\]\nHere, \\(\\mu_j\\) is the mean expression level of gRNA \\(i\\) in cell \\(j\\) (given the covariates); \\(\\beta_0\\), \\(\\gamma\\), and \\(\\beta \\in \\mathbb{R}^d\\) are the (unknown) regression coefficients; and \\(\\pi \\in [0,1]\\) is the (unknown) probability that gRNA \\(i\\) is present in a given cell. We fit the model Equation 7.1 using an EM algorithm, producing estimates \\(\\hat{\\beta}_0\\), \\(\\hat{\\gamma}\\), \\(\\hat{\\beta}\\), and \\(\\hat{\\pi}\\) for the model coefficients \\(\\beta_0\\), \\(\\gamma\\), \\(\\beta\\), and \\(\\pi\\). Using these estimates, we can compute the probability \\(T_{ij} := \\mathbb{P}(x_{ij} = 1)\\) that a given cell \\(j\\) contains gRNA \\(i\\). (The probabilities \\(T_{i1}, \\dots, T_{in}\\) are sometimes called “posterior probabilities.”) Finally, we threshold the posterior probabilities at some threshold \\(u\\) (default value 0.8) to assign gRNA \\(i\\) to the cells, i.e. we set \\(x_{ij} = 1\\) if \\(T_{ij} &gt; u\\) and \\(x_{ij} = 0\\) if \\(T_{ij} \\leq u\\). An advantage of the Poisson GLM framework is that it enables us to account for cell-specific covariates that might affect the level of background contamination, such as the number of gRNA UMIs sequenced in a given cell (i.e., grna_n_umis). The mixture method is available in both low- and high-MOI settings in sceptre.\nFormulating the model Equation 7.1 is fairly straightforward; fitting the model to data in a fast and numerically stable way is more challenging. sceptre leverages a novel variant of the EM algorithm for this purpose, which we describe below.\nApproximating the model Equation 7.1 with a simpler model. We begin by approximating the latent variable model Equation 7.1 with a simpler latent variable model that is easier to estimate. First, we obtain accurate estimates for the parameters \\(\\beta_0\\) and \\(\\beta\\) by exploiting the fact that the gRNA is present in only a small fraction (typically \\(&lt; 2\\%\\)) of cells. Let \\(f(g_j; \\mu_j)\\) denote the probability mass function of the Poisson distribution with mean \\(\\mu_j\\) evaluated at \\(g_j\\), i.e.,\n\\[\nf(g_j; \\mu_j) = \\frac{\\mu_j^{g_j} e^{-\\mu_j}}{g_j!}.\n\\]Conditioning on the covariates (i.e., treating \\(x_j\\) and \\(z_j\\) as fixed), we can express the log-likelihood of the GLM in Equation 7.1 as follows:\n\\[\n\\begin{multline}\nL(\\beta_0, \\gamma, \\beta^T) = \\sum_{j=1}^n \\log \\left[ f(g_j;\\mu_j )\\right] = \\sum_{j=1}^n \\log \\left[ f(g_j; \\exp(\\beta_0 + \\gamma x_j + \\beta^T z_j)) \\right] \\\\ = \\underbrace{\\sum_{j:x_j = 1} \\log \\left[ f(g_j; \\exp(\\beta_0 + \\gamma + \\beta^T z_j)) \\right]}_{\\textrm{few terms}} + \\underbrace{\\sum_{j: x_j = 0} \\log \\left[ f(g_j; \\exp(\\beta_0 + \\beta^T z_j)) \\right]}_\\textrm{many terms} \\\\ \\approx \\sum_{j=1}^n \\log \\left[ f(g_j; \\exp(\\beta_0 + \\beta^T z_j)) \\right].\n\\end{multline}\n\\]\nIn words, the gRNA indicator \\(x_j\\) is equal to zero in the large majority of cells, and so we can approximate the GLM in Equation 7.1 with the GLM that results from excluding \\(x_j\\) from the model:\n\\[\n\\begin{cases}\ng_j | \\mu_j \\sim \\textrm{Pois} (\\mu_j) \\\\\n\\log(\\mu_j | z_j) = \\beta_0 + \\beta^T z_j.\n\\end{cases}\n\\tag{7.2}\\]\nWe can fit the GLM Equation 7.2 using the standard procedure for fitting GLMs (e.g., in R), as the covariates in this GLM are observed. Doing so yields estimates \\(\\hat{\\beta}_0\\) and \\(\\hat{\\beta}\\) for \\(\\beta_0\\) and \\(\\beta\\), respectively. Assuming that \\(\\hat{\\beta_0} \\approx \\beta_0\\) and \\(\\hat{\\beta} \\approx \\beta\\) (which holds for large \\(n\\) and small \\(\\pi\\)), we can write\n\\[\\gamma x_j + \\beta_0 x_j + \\beta z_j \\approx \\gamma x_j + \\hat{\\beta}_0 + \\hat{\\beta} z_j = \\gamma x_i + o_j,\\]where we have set \\(o_j\\) to \\(\\hat{\\beta}_0 + \\hat{\\beta}z_j\\), i.e. the \\(j\\)th fitted value (on the scale of the linear component) of the GLM Equation 7.2. Finally, we propose a simplified model for expression of the gRNA:\n\\[\\begin{cases}\ng_j | \\mu_j \\sim \\textrm{Pois}(\\mu_j) \\\\\n\\log(\\mu_j | x_j) = \\gamma x_j + o_j \\\\\nx_j \\sim \\textrm{Bernoulli}(\\pi).\n\\end{cases}\n\\tag{7.3}\\]\nHere, the \\(o_j\\)s are offset terms in the GLM. Notice that the GLM in Equation 7.3 does not include covariates or an intercept term; rather, all information about the covariates and the baseline expression level of the gRNA has been “encoded” into the offsets \\(o_1, \\dots, o_n\\). In summary we (i) estimated \\(\\beta_0\\) and \\(\\beta\\) using the GLM Equation 7.2 and then (ii) replaced \\(\\beta_0\\) and \\(\\beta\\) in Equation 7.1 with their corresponding estimates, yielding the model Equation 7.3. The model Equation 7.3 is a good approximation to Equation 7.1 in the sense that the maximum likelihood estimates for \\(\\gamma\\) and \\(\\pi\\) in Equation 7.3 are close to the corresponding estimates for these parameters in Equation 7.1 when \\(n\\) is large and \\(\\pi\\) is small (as is the case on most single-cell CRISPR screen datasets). We turn our attention to estimating the model Equation 7.3, treating the offset terms \\(o_1, \\dots, o_n\\) as known and fixed.\nEM algorithm. We derive an EM algorithm to estimate the model Equation 7.3. Let \\(\\theta = (\\gamma, \\pi)\\) denote the unknown model parameters. Let \\(G_j\\) be a random variable that represents the UMI count of the gRNA in the \\(j\\)th cell, and let \\(g_j\\) be the realized value of this random variable. (Similarly, let \\(x_j\\) be the realized value of the random variable \\(X_j\\).) We begin by writing down the complete-data likelihood \\(l\\) of this model, which is the likelihood that would result if \\(x_1, \\dots, x_n\\) had been observed.\n\\[\n\\begin{multline*}\nl(\\theta) = \\prod_{j=1}^n \\mathbb{P}(G_j = g_j, X_j = x_j) = \\prod_{j=1}^n\\mathbb{P}(G_j = g_j | X_j = x_j) \\mathbb{P}(X_j = x_j) \\\\ = \\prod_{j=1}^n f(g_j; \\exp( \\gamma x_j + o_j))\\left[\\pi^{x_i} (1-\\pi)^{1-x_i} \\right].\n\\end{multline*}\n\\]\nWe obtain the complete-data log-likelihood \\(L\\) by taking the log of \\(l\\):\n\\[\nL(\\theta) = \\log(l(\\theta)) = \\sum_{j=1}^n \\log\\left[ f(g_j; \\exp(\\gamma x_j + o_j)\\right] + \\sum_{j=1}^n x_j \\log(\\pi) + (1-x_j)(1-\\pi).\n\\]\nWe derive the E and M steps for the EM algorithm in this model.\nE step: The E step entails computing the membership probability of each cell (i.e., the probability that each cell contains the gRNA given the current parameter estimates and the observed gRNA counts). Let \\(\\theta^{(t)} = (\\gamma^{(t)}, \\pi^{(t)})\\) be the parameter estimate for \\(\\theta\\) at the \\(t\\)th iteration of the algorithm. The \\(j\\)th membership probability at the \\(t\\)th iteration of the algorithm \\(T^{(t)}_j\\) is defined as \\(T^{(t)}_j = \\mathbb{P}(X_j = 1 | G_j = g_j, \\theta^{(t)}).\\) Let \\([\\mu_j(k)]^{(t)}\\) be the mean gRNA UMI count in the \\(j\\)th cell at the \\(t\\)th iteration of the algorithm that results from setting \\(x_j\\) to \\(k \\in \\{0,1\\}\\), i.e.,\n\\[\n[\\mu_j(k)]^{(t)} = \\exp( \\gamma^{(t)} \\cdot k + o_j ).\n\\]\nApplying Bayes rule, we can express the membership probability \\(T^{(t)}_j\\) as\n\\[\n\\begin{multline*}\nT^{(t)}_j = \\mathbb{P}(X_j = 1 | G_j = g_j, \\theta^{(t)}) = \\frac{\\mathbb{P}(G_j = g_j | X_j = 1, \\theta^{(t)})\\mathbb{P}(X_j = 1 | \\theta^{(t)})}{ \\sum_{k=0}^1 \\mathbb{P}(G_j = g_j | X_j = k, \\theta^{(t)}) \\mathbb{P}(X_j = k | \\theta^{(t)})} \\\\ = \\left(\\frac{\\mathbb{P}(G_j = g_j | X_j = 0, \\theta^{(t)}) \\mathbb{P}(X_j = 0)}{\\mathbb{P}( G_j = g_j | X_j = 1, \\theta^{(t)}) \\mathbb{P}(X_j = 1)} +1\\right)^{-1} = \\left(\\frac{f(g_j; [\\mu_j(0)]^{(t)})(1-\\pi^{(t)}))}{f(g_j; [\\mu_j(1)]^{(t)})\\pi^{(t)})} + 1 \\right)^{-1} \\\\ = \\left(\\exp(q_j^{(t)}) + 1 \\right)^{-1},\n\\end{multline*}\n\\] where we define \\[q_j^{(t)} := \\log\\left( \\frac{f(g_j; [\\mu_j(0)]^{(t)})(1-\\pi^{(t)})}{f(g_j; [\\mu_j(1)]^{(t)})\\pi^{(t)}} \\right).\\]\nPlugging in the Poisson probability mass function for \\(f\\), we can express \\(q_j^{(t)}\\) is follows.\n\\[\n\\begin{multline*}\nq_j^{(t)} := \\log(1-\\pi^{(t)}) - \\log(\\pi^{(t)}) + g_j \\left(\\log([\\mu_j(0)]^{(t)}) - \\log([\\mu_j(1)]^{(t)}) \\right) \\\\ + [\\mu_j(1)]^{(t)} - [\\mu_j(0)]^{(t)}.\n\\end{multline*}\n\\tag{7.4}\\]\nThis expression Equation 7.4 for \\(q_j^{(t)}\\) is numerically stable and fast to evaluate. In summary the M step consists of computing \\(T^{(t)}_j\\) for all \\(j\\in\\{1, \\dots, n\\}\\) by computing \\(q^{(t)}_j\\) (using Equation 7.4) and then evaluating \\(T^{(t)}_j = \\exp(q_j^{(t)} + 1)^{-1}.\\)\nM step: The M-step involves maximizing the so-called “Q function,” which is the function that results from taking the expectation of the complete-data log-likelihood with respect to the \\(X_j\\)s while conditioning on the \\(G_j\\)s and the current parameter estimates \\(\\theta^{(t)}\\). Formally, the Q function \\(Q(\\theta | \\theta^{(t)})\\) is defined as \\(Q(\\theta|\\theta^{(t)}) = \\mathbb{E}_{X_1, \\dots, X_n}[L(\\theta) | G_1 = g_1, \\dots, G_n = g_n \\theta^{(t)}]\\). We can express the Q function as\n\\[\n\\begin{multline*}\nQ(\\theta|\\theta^{(t)}) = \\sum_{j=1}^n T^{(t)}_j \\log(\\pi) + \\sum_{j=1}^n (1 - T_j^{(t)})\\log(1-\\pi) \\\\ + \\sum_{j=1}^n T_j^{(t)} \\log \\left[ f\\left(g_j; \\exp[\\gamma + o_j] \\right) \\right] + \\sum_{j=1}^n (1 - T^{(t)}_j) \\log \\left[f(g_j; \\exp(o_j) \\right].\n\\end{multline*}\n\\tag{7.5}\\]\nThe goal of the M step to identify the parameter \\(\\theta = (\\pi, \\gamma)\\) that maximizes Equation 7.5. The first two terms of Equation 7.5 are a function of \\(\\pi\\), and the last two terms are a function of \\(\\gamma\\). Thus, we can optimize these sets of terms separately.\nTo find the maximizer in \\(\\pi\\), we differentiate the first two terms of Equation 7.5 with respect to \\(\\pi\\), yielding\n\\[\n\\frac{\\sum_{j=1}^n T_j^{(t)}}{\\pi} - \\frac{\\sum_{j=1}^n (1 - T_j^{(t)})}{1 - \\pi}.\n\\tag{7.6}\\]\nSetting Equation 7.6 to zero and solving for \\(\\pi\\) produces the maximizer \\(\\pi^{(t+1)}\\):\n\\[ \\pi^{(t+1)} = (1/n) \\sum_{j=1}^n T_j^{(t)}. \\tag{7.7}\\]\nWe turn our attention to the last two terms of Equation 7.5. The final term is not a function of \\(\\gamma\\) and thus can be ignored. We rewrite the penultimate term as follows:\n\\[\n\\begin{multline*}\n\\sum_{j=1}^n T^{(t)}_j \\log\\left[ f(g_j; \\exp[\\gamma + o_j])\\right] \\\\ = \\sum_{j=1}^n T^{(t)}_j \\log\\left[ \\frac{\\exp(\\gamma + o_j)^{g_j} \\exp(-\\exp[\\gamma + o_j])}{g_j!} \\right] \\\\ =\n\\sum_{j=1}^n T_j^{(t)}\\left[ g_j(\\gamma + o_j) - \\exp(\\gamma + o_j) - \\log(g_j!) \\right].\n\\end{multline*}\n\\tag{7.8}\\]\nThe derivative of Equation 7.8 with respect to \\(\\gamma\\) is\n\\[\n\\begin{multline*}\n\\sum_{j=1}^n T^{(t)}_j g_j - T^{(t)}_j \\exp(\\gamma + o_j) = \\sum_{j=1}^n T^{(t)}_j g_j - \\exp(\\gamma) \\sum_{j=1}^n T_j^{(t)} \\exp(o_j).\n\\end{multline*}\n\\tag{7.9}\\]\nFinally, setting Equation 7.9 to zero and solving for \\(\\gamma\\) yields the maximizer\n\\[\n\\gamma^{(t+1)} = \\log\\left(\\frac{\\sum_{j=1}^n T^{(t)}_j y_j }{\\sum_{j=1}^n T^{(t)}_j e^{o_j} }\\right).\n\\tag{7.10}\\]\nIn summary the M step entails computing the updated parameter estimates \\(\\pi^{(t+1)}\\) and \\(\\gamma^{(t+1)}\\) using the formulas Equation 7.7 and Equation 7.10, respectively.\nConvergence: The incomplete-data likelihood (which we obtain by integrating the complete-data likelihood with respect to the \\(x_j\\)s) is\n\\[\nl_\\textrm{incomplete}(\\theta) = \\prod_{j=1}^n f(g_j; \\gamma + o_j) \\pi + f(g_j; o_j)(1-\\pi).\n\\]\nThe incomplete-data log-likelihood is\n\\[\nL_\\textrm{incomplete}(\\theta) = \\log(l_\\textrm{incomplete}(\\theta)) = \\sum_{j=1}^n \\log\\left[ f(g_j; \\gamma + o_j) \\pi + f(g_j; o_j)(1-\\pi) \\right].\n\\]\nNote that the incomplete-data log-likelihood — in contrast to the complete-data log-likelihood — is computable (albeit hard to optimize directly). We iterate between E and M steps until \\(L_\\textrm{incomplete}\\) converges. We declare that the sequence of estimates \\(\\theta^{(0)}, \\theta^{(1)}, \\theta^{(2)}, \\dots\\) has converged when\n\\[\n\\frac{|L_\\textrm{incomplete}(\\theta^{(t+1)}) - L_\\textrm{incomplete}(\\theta^{(t)})|}{ \\min\\left\\{ |L_\\textrm{incomplete}(\\theta^{(t+1)})|, |L_\\textrm{incomplete}(\\theta^{(t)}) | \\right\\}} &lt; \\epsilon\n\\]\nfor some \\(\\epsilon &gt; 0\\) (by default \\(\\epsilon = 0.5 \\cdot 10^{-4}\\)). We set the final parameter estimates \\(\\hat{\\pi}\\) and \\(\\hat{\\gamma}\\) to \\(\\pi^{(t+1)}\\) and \\(\\gamma^{(t+1)}\\). Additionally, we use the final membership probabilities \\(T^{(t+1)}_1, \\dots, T^{(t+1)}_n\\) to assign the gRNA to cells.\nAs is standard, we run the EM algorithm several times over random starting estimates for \\(\\pi\\) and \\(\\gamma\\) to improve chances of converging to the global maximizer of the incomplete-data likelihood. We take the run whose estimates yield the greatest incomplete-data log-likelihood as the final run."
  },
  {
    "objectID": "methods.html#control-group-analysis-type-grna-integration-strategy-and-moi",
    "href": "methods.html#control-group-analysis-type-grna-integration-strategy-and-moi",
    "title": "7  Overview of methods",
    "section": "7.3 Control group, analysis type, gRNA integration strategy, and MOI",
    "text": "7.3 Control group, analysis type, gRNA integration strategy, and MOI\nsceptre tests for association by comparing the expression of a response across a “treatment group” and a “control group.”\nThe analysis parameters of control group, analysis type, gRNA integration strategy, and MOI interact with one another in subtle ways. We clarify the relationship between these analysis parameters here.\nWe begin by introducing some notation. Let \\(\\mathcal{S} =\\{1, \\dots, n\\}\\) denote the set of cells. Let \\(X \\in \\{0,1\\}^{r \\times n}\\) denote the matrix of imputed gRNA presences and absences (as estimated in the gRNA assignment step; see Section 7.2). For \\(i \\in \\{1, \\dots, r\\}\\), let \\(G_i\\) denote the set of cells that gRNA \\(i\\) has infected, i.e. \\(G_i := \\{ j: x_{ij} = 1 \\}.\\) Let \\(\\mathcal{N} \\subset \\{1, \\dots, r\\}\\) denote the set of non-targeting gRNAs, and let \\(\\mathcal{T} = \\{1,\\dots,r\\} \\setminus \\mathcal{N}\\) denote the set of discovery and positive control gRNAs. Note that in low MOI, after applying quality control, each cell contains a single gRNA, implying that the sets \\(G_1, \\dots, G_r\\) are disjoint, i.e.\n\\[\n\\bigcap_{i=1}^r G_i = \\emptyset.\n\\]\nThis of course is not the case in high-MOI.\n\n7.3.1 Union gRNA integration strategy\nWe first consider the “union” gRNA integration strategy. The union integration strategy involves combining multiple distinct gRNAs into a single “combined” gRNA and then testing this combined gRNA against responses as if it were a singleton gRNA. Suppose that we are running a discovery analysis, and let \\(\\mathcal{I} \\subset \\mathcal{T}\\) be a given set of gRNAs that target the same site. The table below defines the treatment group, the complement set control group, and the NT cells control group relative to \\(\\mathcal{I}\\).\n\nThe treatment group, complement set control group, and NT cells control group under the union gRNA integration strategy when running a discovery analysis. Here, \\(\\mathcal{I}\\) is a given set of gRNAs that target the same site.\n\n\n\n\n\n\n\nTreatment group\nComplement set control group\nNT cells control group\n\n\n\n\n\\(\\cup_{i \\in \\mathcal{I}} G_i\\)\n\\(\\mathcal{S} \\setminus \\cup_{i \\in \\mathcal{I}} G_i\\)\n\\(\\cup_{i \\in \\mathcal{N}} G_i\\)\n\n\n\nNext, suppose that we are running a calibration check analysis (again using the union gRNA integration strategy). Let \\(\\mathcal{L} \\subset \\mathcal{N}\\) be a set of non-targeting gRNAs that have been combined into a “negative control” gRNA target. (By default, \\(|\\mathcal{L}| = |\\mathcal{I}|\\), i.e., the discovery target and negative control target contain the same number of gRNAs.) The treatment group, complement set control group, and NT cells control group are defined relative to \\(\\mathcal{L}\\) as follows.\n\nThe treatment group, complement set control group, and NT cells control group under the union gRNA integration strategy when running a calibration check. Here, \\(\\mathcal{L}\\) is a given set of non-targeting gRNAs that have been randomly combined into a “negative control” gRNA target.\n\n\n\n\n\n\n\nTreatment group\nComplement set control group\nNT cells control group\n\n\n\n\n\\(\\cup_{i \\in \\mathcal{L}} G_i\\)\n\\(\\mathcal{S} \\setminus \\cup_{i \\in \\mathcal{L}} G_i\\)\n\\(\\cup_{i \\in (\\mathcal{N} \\setminus \\mathcal{L})} G_i\\)\n\n\n\n\n\n7.3.2 Singleton and Bonferroni gRNA integration strategies\nWe next consider the “singleton” and “Bonferroni” gRNA integration strategies. Both strategies involve testing singleton gRNAs for association responses. Let \\(i \\in \\mathcal{T}\\) be a given"
  },
  {
    "objectID": "methods.html#differential-expression-testing-and-estimation",
    "href": "methods.html#differential-expression-testing-and-estimation",
    "title": "7  Overview of methods",
    "section": "7.4 Differential expression testing and estimation",
    "text": "7.4 Differential expression testing and estimation"
  },
  {
    "objectID": "methods.html#integrating-information-across-potentially-variably-effective-grnas",
    "href": "methods.html#integrating-information-across-potentially-variably-effective-grnas",
    "title": "7  Overview of methods",
    "section": "7.5 Integrating information across (potentially variably effective) gRNAs",
    "text": "7.5 Integrating information across (potentially variably effective) gRNAs\nSuppose that gRNAs \\(1, \\dots, k\\) target the same site. Testing each of these gRNAs individually against a given response yields p-values \\(p_1, \\dots, p_k\\).\nTheorem: Suppose that \\(p_1, \\dots, p_k\\) are superuniform, i.e. \\(\\mathbb{P}(p_i \\leq \\alpha) \\leq \\alpha\\) for all \\(i \\in \\{1, \\dots, k\\}\\) and all \\(\\alpha \\in [0,1]\\). Then \\(k \\cdot \\min\\{p_1, \\dots, p_k\\}\\) also is superuniform.\nProof:\n\\[\n\\begin{multline}\n\\mathbb{P}( k \\cdot \\min\\{p_1, \\dots, p_k\\} \\leq \\alpha) = \\mathbb{P}( \\min\\{p_1, \\dots, p_k\\} \\leq \\alpha/k )\\\\ = \\mathbb{P}\\left( p_1 \\leq \\alpha/k \\textrm{ or } \\dots \\textrm{ or } p_k \\leq \\alpha /k  \\right) \\leq \\sum_{i=1}^k \\mathbb{P}(p_i \\leq \\alpha/k) \\leq \\sum_{i=1}^k \\alpha/k = \\alpha.\n\\end{multline}\n\\]\nThe penultimate inequality follows from the union bound, and the final inequality follows from the superuniformity of \\(p_i\\). \\(\\square\\)\n\n\n\n\nBarry, Timothy, Kaishu Mason, Kathryn Roeder, and Eugene Katsevich. 2023. “Robust differential expression testing for single-cell CRISPR screens.” bioRxiv.\n\n\nBarry, Timothy, Kathryn Roeder, and Eugene Katsevich. 2022. “Exponential family measurement error models for single-cell CRISPR screens.” arXiv.\n\n\nBarry, Timothy, Xuran Wang, John A. Morris, Kathryn Roeder, and Eugene Katsevich. 2021. “SCEPTRE improves calibration and sensitivity in single-cell CRISPR screen analysis.” Genome Biology 22 (1): 1–19.\n\n\nGasperini, Molly, Andrew J. Hill, José L. McFaline-Figueroa, Beth Martin, Seungsoo Kim, Melissa D. Zhang, Dana Jackson, et al. 2019. “A Genome-wide Framework for Mapping Gene Regulation via Cellular Genetic Screens.” Cell 176 (1): 377–90."
  },
  {
    "objectID": "methods.html#integrating-information-across-possibly-variably-effective-grnas",
    "href": "methods.html#integrating-information-across-possibly-variably-effective-grnas",
    "title": "7  Overview of methods",
    "section": "7.5 Integrating information across (possibly variably effective) gRNAs",
    "text": "7.5 Integrating information across (possibly variably effective) gRNAs\nSuppose that gRNAs \\(1, \\dots, k\\) target the same site. Testing each of these gRNAs individually against a given response yields p-values \\(p_1, \\dots, p_k\\).\nTheorem: Suppose that \\(p_1, \\dots, p_k\\) are superuniform, i.e. \\(\\mathbb{P}(p_i \\leq \\alpha) \\leq \\alpha\\) for all \\(i \\in \\{1, \\dots, k\\}\\) and all \\(\\alpha \\in [0,1]\\). Then \\(k \\cdot \\min\\{p_1, \\dots, p_k\\}\\) also is superuniform.\nProof:\n\\[\n\\begin{multline}\n\\mathbb{P}( k \\cdot \\min\\{p_1, \\dots, p_k\\} \\leq \\alpha) = \\mathbb{P}( \\min\\{p_1, \\dots, p_k\\} \\leq \\alpha/k )\\\\ = \\mathbb{P}\\left( p_1 \\leq \\alpha/k \\textrm{ or } \\dots \\textrm{ or } p_k \\leq \\alpha /k  \\right) \\leq \\sum_{i=1}^k \\mathbb{P}(p_i \\leq \\alpha/k) \\leq \\sum_{i=1}^k \\alpha/k = \\alpha.\n\\end{multline}\n\\]\nThe penultimate inequality follows from the union bound, and the final inequality follows from the superuniformity of \\(p_i\\). \\(\\square\\)\n\n\n\n\nBarry, Timothy, Kaishu Mason, Kathryn Roeder, and Eugene Katsevich. 2023. “Robust differential expression testing for single-cell CRISPR screens.” bioRxiv.\n\n\nBarry, Timothy, Kathryn Roeder, and Eugene Katsevich. 2022. “Exponential family measurement error models for single-cell CRISPR screens.” arXiv.\n\n\nBarry, Timothy, Xuran Wang, John A. Morris, Kathryn Roeder, and Eugene Katsevich. 2021. “SCEPTRE improves calibration and sensitivity in single-cell CRISPR screen analysis.” Genome Biology 22 (1): 1–19.\n\n\nGasperini, Molly, Andrew J. Hill, José L. McFaline-Figueroa, Beth Martin, Seungsoo Kim, Melissa D. Zhang, Dana Jackson, et al. 2019. “A Genome-wide Framework for Mapping Gene Regulation via Cellular Genetic Screens.” Cell 176 (1): 377–90."
  },
  {
    "objectID": "methods.html#treatment-and-control-groups",
    "href": "methods.html#treatment-and-control-groups",
    "title": "7  Overview of methods",
    "section": "7.3 Treatment and control groups",
    "text": "7.3 Treatment and control groups\nsceptre tests for association by comparing the expression of a response across a “treatment group” and a “control group.”\nThe analysis parameters of control group, analysis type, gRNA integration strategy, and MOI interact with one another in subtle ways. We clarify the relationship between these analysis parameters here.\nWe begin by introducing some notation. Let \\(\\mathcal{S} =\\{1, \\dots, n\\}\\) denote the set of cells. Let \\(X \\in \\{0,1\\}^{r \\times n}\\) denote the matrix of imputed gRNA presences and absences (as estimated in the gRNA assignment step; see Section 7.2). For \\(i \\in \\{1, \\dots, r\\}\\), let \\(G_i\\) denote the set of cells that gRNA \\(i\\) has infected, i.e. \\(G_i := \\{ j: x_{ij} = 1 \\}.\\) Let \\(\\mathcal{N} \\subset \\{1, \\dots, r\\}\\) denote the set of non-targeting gRNAs, and let \\(\\mathcal{T} = \\{1,\\dots,r\\} \\setminus \\mathcal{N}\\) denote the set of discovery and positive control gRNAs. Note that in low MOI, after applying quality control, each cell contains a single gRNA, implying that the sets \\(G_1, \\dots, G_r\\) are disjoint, i.e.\n\\[\n\\bigcap_{i=1}^r G_i = \\emptyset.\n\\]\nThis of course is not the case in high-MOI.\nUnion gRNA integration strategy. We first consider the “union” gRNA integration strategy. The union integration strategy involves combining multiple distinct gRNAs into a single “combined” gRNA and then testing this combined gRNA against responses as if it were a singleton gRNA. Suppose that we are running a discovery analysis, and let \\(\\mathcal{I} \\subset \\mathcal{T}\\) be a given set of gRNAs that target the same site. The table below defines the treatment group, the complement set control group, and the NT cells control group relative to \\(\\mathcal{I}\\).\n\nUnion gRNA integration strategy, discovery analysis.\n\n\n\n\n\n\n\nTreatment group\nComplement set control group\nNT cells control group\n\n\n\n\n\\(\\cup_{i \\in \\mathcal{I}} G_i\\)\n\\(\\mathcal{S} \\setminus \\cup_{i \\in \\mathcal{I}} G_i\\)\n\\(\\cup_{i \\in \\mathcal{N}} G_i\\)\n\n\n\nNext, suppose that we are running a calibration check analysis (again using the union gRNA integration strategy). Let \\(\\mathcal{L} \\subset \\mathcal{N}\\) be a set of non-targeting gRNAs that have been combined into a “negative control” gRNA target. (By default, \\(|\\mathcal{L}| = |\\mathcal{I}|\\), i.e., the discovery target and negative control target contain the same number of gRNAs.) The treatment group, complement set control group, and NT cells control group are defined relative to \\(\\mathcal{L}\\) as follows.\n\nUnion gRNA integration strategy, calibration check.\n\n\n\n\n\n\n\nTreatment group\nComplement set control group\nNT cells control group\n\n\n\n\n\\(\\cup_{l \\in \\mathcal{L}} G_l\\)\n\\(\\mathcal{S} \\setminus \\cup_{l \\in \\mathcal{L}} G_l\\)\n\\(\\cup_{l \\in (\\mathcal{N} \\setminus \\mathcal{L})} G_l\\)\n\n\n\nSingleton and Bonferroni gRNA integration strategies. Next, we consider the “singleton” and “Bonferroni” gRNA integration strategies. Both strategies involve testing singleton gRNAs for association against responses. Let \\(i \\in \\mathcal{T}\\) be a given targeting gRNA. The table below defines the treatment group, complement set control group, and NT cells control group relative to \\(i\\).\n\nSingleton/Bonferroni gRNA integration strategy, discovery analysis.\n\n\n\n\n\n\n\nTreatment group\nComplement set control group\nNT cells control group\n\n\n\n\n\\(G_i\\)\n\\(\\mathcal{S} \\setminus G_i\\)\n\\(\\cup_{i \\in \\mathcal{N}} G_i\\)\n\n\n\nFinally, suppose that we are running a calibration check using the singleton or Bonferroni gRNA integration strategy. Let \\(l \\in \\mathcal{N}\\) be a non-targeting gRNA. The treatment group, complement set control group, and NT cells control group are defined in terms of \\(l\\) as follows.\n\nSingleton/Bonferroni gRNA integration strategy, calibration check.\n\n\n\n\n\n\n\nTreatment group\nComplement set control group\nNT cells control group\n\n\n\n\n\\(G_l\\)\n\\(\\mathcal{S} \\setminus G_l\\)\n\\(\\cup_{i \\in (\\mathcal{N}\\setminus \\{ l \\} )} G_i\\)\n\n\n\nNote that the Bonferroni gRNA integration strategy combines p-values across gRNAs that target the same site into a single “target-wide” p-value via a Bonferroni correction (discussed below). Note also that the complement set is available as a control group in both low- and high-MOI settings, while the NT cells are available as a control group only in the low-MOI setting."
  },
  {
    "objectID": "methods.html#treatment-group-and-control-group",
    "href": "methods.html#treatment-group-and-control-group",
    "title": "7  Overview of methods",
    "section": "7.3 Treatment group and control group",
    "text": "7.3 Treatment group and control group\nTo test for association between a given gRNA (or gRNA target) and a response, sceptre divides the cells into two groups: the “treatment group” and the “control group.” sceptre tests for differential expression of the response across these two groups of cells, yielding a p-value for the test of association. The definitions of treatment group and control group are somewhat subtle and depend on the analysis parameters of gRNA integration strategy (i.e., union, singleton, or Bonferroni), and control group (i.e., complement set or NT cells), analysis type (i.e., discovery analysis or calibration check). (See Chapter 2 for a discussion of these parameters.) This section aims to carefully define “treatment group” and “control group,” in particular as a function of the aforementioned factors.\nWe first introduce some notation. Let \\(\\mathcal{S} =\\{1, \\dots, n\\}\\) denote the set of cells. Let \\(X \\in \\{0,1\\}^{r \\times n}\\) denote the matrix of imputed gRNA presences and absences (as determined in the gRNA assignment step; Section 7.2). For \\(i \\in \\{1, \\dots, r\\}\\), let \\(G_i\\) denote the set of cells that gRNA \\(i\\) has infected, i.e. \\(G_i := \\{ j: x_{ij} = 1 \\}.\\) Let \\(\\mathcal{N} \\subset \\{1, \\dots, r\\}\\) denote the set of non-targeting gRNAs, and let \\(\\mathcal{T} = \\{1,\\dots,r\\} \\setminus \\mathcal{N}\\) denote the set of targeting gRNAs. (Typically, \\(\\mathcal{T}\\) consists of both discovery gRNAs and positive control gRNAs.) Note that in low MOI, after applying quality control, each cell contains a single gRNA, implying that the sets \\(G_1, \\dots, G_r\\) are disjoint, i.e.\n\\[\n\\bigcap_{i=1}^r G_i = \\emptyset.\n\\]\nWe proceed by taking cases on gRNA integration strategy, first considering the union integration strategy and then considering the singleton and Bonferroni integration strategies.\nUnion gRNA integration strategy. We first consider the “union” gRNA integration strategy. The union integration strategy involves combining multiple distinct gRNAs into a single “combined” gRNA and then testing this combined gRNA against responses as if it were a singleton gRNA. Suppose that we are running a discovery analysis, and let \\(\\mathcal{I} \\subset \\mathcal{T}\\) be a given set of gRNAs that target the same site. The table below defines the treatment group, the complement set control group, and the NT cells control group relative to \\(\\mathcal{I}\\).\n\nUnion gRNA integration strategy, discovery analysis.\n\n\n\n\n\n\n\nTreatment group\nComplement set control group\nNT cells control group\n\n\n\\(\\cup_{i \\in \\mathcal{I}} G_i\\)\n\\(\\mathcal{S} \\setminus \\cup_{i \\in \\mathcal{I}} G_i\\)\n\\(\\cup_{i \\in \\mathcal{N}} G_i\\)\n\n\n\nNext, suppose that we are running a calibration check analysis (again using the union gRNA integration strategy). Let \\(\\mathcal{L} \\subset \\mathcal{N}\\) be a set of non-targeting gRNAs that have been combined into a “negative control” gRNA target. (By default, \\(|\\mathcal{L}| = |\\mathcal{I}|\\), i.e., the discovery target and negative control target contain the same number of gRNAs.) The treatment group, complement set control group, and NT cells control group are defined relative to \\(\\mathcal{L}\\) as follows.\n\nUnion gRNA integration strategy, calibration check.\n\n\n\n\n\n\n\nTreatment group\nComplement set control group\nNT cells control group\n\n\n\\(\\cup_{l \\in \\mathcal{L}} G_l\\)\n\\(\\mathcal{S} \\setminus \\cup_{l \\in \\mathcal{L}} G_l\\)\n\\(\\cup_{l \\in (\\mathcal{N} \\setminus \\mathcal{L})} G_l\\)\n\n\n\nSingleton and Bonferroni gRNA integration strategies. Next, we consider the “singleton” and “Bonferroni” gRNA integration strategies. Both strategies involve testing singleton gRNAs for association against responses. Suppose that we are running a discovery analysis, and let \\(i \\in \\mathcal{T}\\) be a given targeting gRNA. The table below defines the treatment group, complement set control group, and NT cells control group relative to \\(i\\).\n\nSingleton/Bonferroni gRNA integration strategy, discovery analysis.\n\n\n\n\n\n\n\nTreatment group\nComplement set control group\nNT cells control group\n\n\n\\(G_i\\)\n\\(\\mathcal{S} \\setminus G_i\\)\n\\(\\cup_{i \\in \\mathcal{N}} G_i\\)\n\n\n\nFinally, suppose that we are running a calibration check using the singleton or Bonferroni gRNA integration strategy. Let \\(l \\in \\mathcal{N}\\) be a non-targeting gRNA. The treatment group, complement set control group, and NT cells control group are defined relative to \\(l\\) as follows.\n\nSingleton/Bonferroni gRNA integration strategy, calibration check.\n\n\n\n\n\n\n\nTreatment group\nComplement set control group\nNT cells control group\n\n\n\\(G_l\\)\n\\(\\mathcal{S} \\setminus G_l\\)\n\\(\\cup_{i \\in (\\mathcal{N}\\setminus \\{ l \\} )} G_i\\)\n\n\n\nNote that the Bonferroni gRNA integration strategy combines p-values across gRNAs that target the same site into a single “target-wide” p-value via a Bonferroni correction (discussed below). Note also that the complement set is available as a control group in both low- and high-MOI settings, while the NT cells are available as a control group only in the low-MOI setting."
  }
]