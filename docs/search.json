[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hands-On Single-Cell CRISPR Screen Analysis",
    "section": "",
    "text": "Welcome\nSingle-cell CRISPR screens (e.g., perturb-seq) combine CRISPR genome engineering and single-cell sequencing to survey the effects of genetic perturbations on individual cells. Single-cell CRISPR screens pose enormous potential for unraveling mechanisms underlying disease and accelerating drug discovery. However, the analysis of these screens presents considerable statistical and computational challenges. Hands-On Single-Cell CRISPR Screen Analysis is a step-by-step guide to carrying out statistically rigorous and massively scalable single-cell CRISPR screen data analysis using the sceptre R package.\nsceptre is compatible with a broad range of single-cell CRISPR screen experimental designs. In particular, datasets can vary along the following axes: multiplicity of infection (low or high), genomic element targeted (gene or noncoding regulatory element), CRISPR modality (CRISPRko, CRISPRi, CRISPRa, or CRISPR prime or base editing), and molecular readout (gene expression, protein expression, or chromatin accessibility). Additionally, sceptre enables the analysis of massive-scale data that are too large to fit into memory or that require a cluster or cloud to process.\n\n\nNavigating this book\nWe recommend that users read through the chapters of the book in order.\n\nThe whole game provides a high-level overview of analyzing single-cell CRISPR screen data using sceptre. First-time users can get started by reading this chapter only.\nPart I (Chapter 1 — Chapter 6) describes in greater detail how to carry out a sceptre analysis on a laptop or desktop.\nPart II (Chapter 7 — Chapter 9) describes how to deploy sceptre at-scale on a cluster or cloud.\n\nFinally, we recommend that users consult the Glossary throughout to keep track of the terminology used in this book.\n\n\nAcknowledgments\nWe gratefully acknowledge Kathryn Roeder, John Morris, Kaishu Mason, Xuran Wang, and Ziang Niu for contributing to the research and development underlying sceptre. We additionally thank the many sceptre users who have provided and continue to provide valuable feedback on the package.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "sceptre.html",
    "href": "sceptre.html",
    "title": "The whole game",
    "section": "",
    "text": "1. Import data\nThe first step is to import the data. Data can be imported into sceptre from 10X Cell Ranger or Parse outputs, as well as from R matrices. The simplest way to import the data is to read the output of one or more calls to cellranger_count into sceptre via the function import_data_from_cellranger(). import_data_from_cellranger() requires three arguments: directories, grna_target_data_frame, and moi.\nFinally, we call the function import_data_from_cellranger(), passing directories, grna_target_data_frame, and moi as arguments.\nsceptre_object &lt;- import_data_from_cellranger(\n  directories = directories,\n  grna_target_data_frame = grna_target_data_frame_highmoi,\n  moi = moi\n)\nimport_data_from_cellranger() returns a sceptre_object, which is an object-based representation of the single-cell CRISPR screen data. Evaluating sceptre_object in the console prints a helpful summary of the data.\nsceptre_object\n\nAn object of class sceptre_object.\n\nAttributes of the data:\n    • 45919 cells\n    • 526 responses\n    • High multiplicity-of-infection \n    • 70 targeting gRNAs (distributed across 35 targets) \n    • 25 non-targeting gRNAs \n    • 6 covariates (batch, grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito)\nSeveral metrics are displayed, including the number of cells, the number of genes (or “responses”), and the number of gRNAs present in the data. sceptre also automatically computes the following cell-specific covariates: grna_n_nonzero (i.e., the number of gRNAs expressed in the cell), grna_n_umis (i.e., the number of gRNA UMIs sequenced in the cell), response_n_nonzero (i.e., the number of responses expressed in the cell), response_n_umis (i.e., the number of response UMIs sequenced in the cell), response_p_mito (i.e., the fraction of transcripts mapping to mitochondrial genes), and batch. (Cells loaded from different directories are assumed to come from different batches.)\nSee 1  Import data for more details about data import.",
    "crumbs": [
      "The whole game"
    ]
  },
  {
    "objectID": "sceptre.html#sec-whole_game_import_data",
    "href": "sceptre.html#sec-whole_game_import_data",
    "title": "The whole game",
    "section": "",
    "text": "directories is a character vector specifying the locations of the directories outputted by one or more calls to cellranger_count. Below, we set the variable directories to the (machine-dependent) location of the example CRISPRi data on disk.\n\ndirectories &lt;- paste0(\n  system.file(\"extdata\", package = \"sceptredata\"), \n  \"/highmoi_example/gem_group_\", 1:2\n)\ndirectories # file paths to the example data on your computer\n\n[1] \"/Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library/sceptredata/extdata/highmoi_example/gem_group_1\"\n[2] \"/Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library/sceptredata/extdata/highmoi_example/gem_group_2\"\n\n\ndirectories points to two directories, both of which store the expression data in matrix market format and contain the files barcodes.tsv.gz, features.tsv.gz, and matrix.mtx.gz.\n\nlist.files(directories[1])\n\n[1] \"barcodes.tsv.gz\" \"features.tsv.gz\" \"matrix.mtx.gz\"  \n\nlist.files(directories[2])\n\n[1] \"barcodes.tsv.gz\" \"features.tsv.gz\" \"matrix.mtx.gz\"  \n\n\n\n\ngrna_target_data_frame is a data frame mapping each individual gRNA to the genomic element that the gRNA targets. grna_target_data_frame contains two required columns: grna_id and grna_target. grna_id is the ID of an individual gRNA, while grna_target is a label specifying the genomic element that the gRNA targets. (Typically, multiple gRNAs are designed to target a given genomic element in a single-cell CRISPR screen.) Non-targeting (NT) gRNAs are assigned a gRNA target label of “non-targeting”. grna_target_data_frame optionally contains the columns chr, start, and end, which give the chromosome, start coordinate, and end coordinate, respectively, of the genomic region that each gRNA targets. Finally, grna_target_data_frame optionally can contain the column vector_id specifying the vector to which a given gRNA belongs. vector_id should be supplied in experiments in which each viral vector contains two or more distinct gRNAs (as in, e.g., Replogle 2022). We load and examine the grna_target_data_frame corresponding to the example data.\n\ndata(grna_target_data_frame_highmoi)\ngrna_target_data_frame_highmoi[c(1:4, 21:24, 80:83),]\n\n        grna_id      grna_target   chr     start       end\n1  grna_CCGGGCG  ENSG00000069482 chr11  68451943  68451958\n2  grna_TGGCGGC  ENSG00000069482 chr11  68451958  68451974\n3  grna_AAGGCCG  ENSG00000100316 chr22  39715775  39715790\n4  grna_GACGCCG  ENSG00000100316 chr22  39715790  39715806\n21 grna_TCTTGAC  candidate_enh_1  chr1 205720419 205720623\n22 grna_TGATCGC  candidate_enh_1  chr1 205720623 205720828\n23 grna_ATAGGAG candidate_enh_10 chr19  19475680  19475878\n24 grna_GCAGGCA candidate_enh_10 chr19  19475878  19476077\n80 grna_TATTCGT    non-targeting  &lt;NA&gt;        NA        NA\n81 grna_GACCTCC    non-targeting  &lt;NA&gt;        NA        NA\n82 grna_TTTCTCT    non-targeting  &lt;NA&gt;        NA        NA\n83 grna_AATGAGG    non-targeting  &lt;NA&gt;        NA        NA\n\n\nSome gRNAs (e.g., grna_CCGGGCG and grna_TGGCGGC) target gene transcription start sites and serve as positive controls; other gRNAs (e.g., grna_TCTTGAC and grna_TGATCGC) target candidate enhancers, while others still (e.g., grna_TATTCGT and grna_GACCTCC) are non-targeting. Each gene and candidate enhancer in this dataset is targeted by exactly two gRNAs.\n\n\nmoi is a string specifying the multiplicity-of-infection (MOI) of the data, taking values \"high\" or \"low\". A high-MOI (respectively, low-MOI) dataset is one in which the experimenter has aimed to insert multiple gRNAs (respectively, a single gRNA) into each cell. (If a given cell is determined to contain multiple gRNAs in a low-MOI screen, that cell is removed as part of the quality control step, as discussed below.) The example dataset is a high MOI dataset, and so we set moi to \"high\".\n\nmoi &lt;- \"high\"",
    "crumbs": [
      "The whole game"
    ]
  },
  {
    "objectID": "sceptre.html#sec-whole_game_set_analysis_parameters",
    "href": "sceptre.html#sec-whole_game_set_analysis_parameters",
    "title": "The whole game",
    "section": "2. Set analysis parameters",
    "text": "2. Set analysis parameters\nThe second step is to set the analysis parameters. The most important analysis parameters are the discovery pairs, positive control pairs, sidedness, and gRNA grouping strategy.\n\n\nDiscovery pairs and positive control pairs. The primary goal of sceptre is to determine whether perturbation of a gRNA target (such as an enhancer) leads to a change in expression of a response (such as gene). We use the term target-response pair to refer to a given gRNA target and response that we seek to test for association (upon perturbation of the gRNA target). A discovery target-response pair is a target-response pair whose association status we do not know but would like to learn. For example, in an experiment in which we aim to link putative enhancers to genes, the discovery target-response pairs might consist of the set of putative enhancers and genes in close physical proximity to one another.\nA positive control (resp., negative control) target-response pair is a target-response pair for which we know that there is (resp., is not) a relationship between the target and the response. Positive control target-response pairs often are formed by coupling a transcription start site to the gene known to be regulated by that transcription start site. Negative control target-response pairs, meanwhile, typically are constructed by pairing negative control gRNAs to one or more responses. (We defer a detailed discussion of negative control pairs to a later section of this chapter.) Discovery pairs are of primary scientific interest, while positive control and negative control pairs serve a mainly technial purpose, helping us verify that the biological assay and statistical methodology are in working order.\nsceptre offers several helper functions to facilitate the construction of positive control and discovery pairs. The function construct_positive_control_pairs() takes as argument a sceptre_object and outputs the set of positive control pairs formed by matching gRNA targets (as contained in the grna_target_data_frame) to response IDs. Positive control pairs are optional and need not be computed.\n\npositive_control_pairs &lt;- construct_positive_control_pairs(sceptre_object)\nhead(positive_control_pairs)\n\n      grna_target     response_id\n1 ENSG00000069482 ENSG00000069482\n2 ENSG00000100316 ENSG00000100316\n3 ENSG00000104131 ENSG00000104131\n4 ENSG00000122026 ENSG00000122026\n5 ENSG00000135821 ENSG00000135821\n6 ENSG00000147669 ENSG00000147669\n\n\nNext, the functions construct_cis_pairs() and construct_trans_pairs() facilitate the construction of cis and trans discovery sets, respectively. construct_cis_pairs() takes as arguments a sceptre_object and an integer distance_threshold and returns the set of response-target pairs located on the same chromosome within distance_threshold bases of one another. positive_control_pairs optionally can be passed to this function, in which case positive control gRNA targets are excluded from the cis pairs. (Note that construct_cis_pairs() assumes that the responses are genes rather than, say, proteins or chromatin-derived features.)\n\ndiscovery_pairs &lt;- construct_cis_pairs(\n  sceptre_object = sceptre_object,\n  positive_control_pairs = positive_control_pairs,\n  distance_threshold = 5e6\n)\ndiscovery_pairs[c(1:4, 101:104),]\n\n         grna_target     response_id\n1    candidate_enh_1 ENSG00000174529\n2    candidate_enh_1 ENSG00000117222\n3    candidate_enh_1 ENSG00000133059\n4    candidate_enh_1 ENSG00000133069\n101 candidate_enh_10 ENSG00000064490\n102 candidate_enh_10 ENSG00000254901\n103 candidate_enh_10 ENSG00000184162\n104 candidate_enh_10 ENSG00000105705\n\n\nconstruct_trans_pairs() constructs the entire set of possible target-response pairs. See 2.2.1 Construct cis pairs and 2.2.2 Construct trans pairs of Set analysis parameters for more information about these functions.\n\n\nSidedness. The parameter side controls whether to run a left-tailed (\"left\"), right-tailed (\"right\"), or two-tailed (\"both\"; default) test. A left-tailed (resp., right-tailed) test is appropriate when testing for a decrease (resp., increase) in expression; a two-tailed test, by contrast, is appropriate when testing for an increase or decrease in expression. A left-tailed test is the most appropriate choice for a CRISPRi screen of enhancers, and so we set side to \"left\".\n\nside &lt;- \"left\"\n\n\ngRNA integration strategy. Typically, multiple gRNAs are designed to target a given genomic element. The parameter grna_integration_strategy controls if and how gRNAs that target the same genomic element are integrated. The default option, \"union\", combines gRNAs that target the same element into a single “grouped gRNA;” this “grouped gRNA” is tested for association against the responses to which the element is paired. grna_integration_strategy also can be set to “singleton,” in which case each gRNA targeting a given element is tested individually against the responses paired to that element. In our analysis we use the default “union” strategy.\n\nFinally, we set the analysis parameters by calling the function set_analysis_parameters(), passing sceptre_object, discovery_pairs, positive_control_pairs, and side as arguments. Note that sceptre_object is the only required arguments to this function.\n\nsceptre_object &lt;- set_analysis_parameters(\n  sceptre_object = sceptre_object,\n  discovery_pairs = discovery_pairs,\n  positive_control_pairs = positive_control_pairs,\n  side = side\n)\nprint(sceptre_object) # output suppressed for brevity\n\nSee 2  Set analysis parameters for more information about setting the analysis parameters.",
    "crumbs": [
      "The whole game"
    ]
  },
  {
    "objectID": "sceptre.html#sec-sceptre_assign_grnas",
    "href": "sceptre.html#sec-sceptre_assign_grnas",
    "title": "The whole game",
    "section": "3. Assign gRNAs to cells (optional)",
    "text": "3. Assign gRNAs to cells (optional)\nThe third step is to assign gRNAs to cells. This step can be skipped, in which case gRNAs are assigned to cells automatically using default options. The gRNA assignment step involves using the gRNA UMI counts to determine which cells contain which gRNAs. We begin by plotting the UMI count distribution of several randomly selected gRNAs via a call to the function plot_grna_count_distributions().\n\nplot_grna_count_distributions(sceptre_object)\n\n\n\n\n\nHistograms of the gRNA count distributions\n\n\n\nThe gRNAs display bimodal count distributions. Consider, for example, gRNA_CCTGACA (top left corner). This gRNA exhibits a UMI count of \\(\\leq 1\\) or \\(\\geq 5\\) in most cells and a UMI count of 2, 3, or 4 in only a handful of cells. The vast majority of cells with a UMI count of 1 likely do not actually contain gRNA_CCTGACA. This is an example of “background contamination,” the phenomenon by which gRNA transcripts sometimes map to cells that do not contain the corresponding gRNA.\nsceptre provides three methods for assigning gRNAs to cells (the “mixture method,” the “maximum method,” and the “thresholding method”), all of which account for background contamination. The default method for high-MOI data is the “mixture method.” The gRNA counts are regressed onto the (unobserved) gRNA presence/absence indicator and the cell-specific covariates (e.g., grna_n_umis, batch) via a latent variable Poisson GLM. The fitted model yields the probability that each cell contains the gRNA, and these probabilities are thresholded to assign the gRNA to cells. The default method in low-MOI is the simpler “maximum” approach: the gRNA that accounts for the greatest number of UMIs in a given cell is assigned to that cell. A backup option in both low- and high-MOI is the “thresholding” approach: a given gRNA is assigned to a given cell if the UMI count of that gRNA in that cell exceeds some integer threshold.\nWe carry out the gRNA assignment step via a call to the function assign_grnas(). assign_grnas() takes arguments sceptre_object (required) and method (optional); the latter argument can be set to \"mixture\", \"maximum\", or \"thresholding\". We parallelize execution of assign_grnas() by setting parallel to TRUE. (Parallel execution is not yet configured for Windows. We recommend that Windows users seeking to parallelize their analysis leverage the sceptre Nextflow pipeline.)\n\nsceptre_object &lt;- assign_grnas(sceptre_object = sceptre_object, parallel = TRUE)\nprint(sceptre_object) # output suppressed for brevity\n\nWe can call plot() on the resulting sceptre_object to render a plot summarizing the output of the gRNA-to-cell assignment step.\n\nplot(sceptre_object)\n\n\n\n\n\ngRNA-to-cell assignments\n\n\n\nThe top panel plots the gRNA-to-cell assignments of three randomly selected gRNAs. In each plot the points represent cells; the vertical axis indicates the UMI count of the gRNA in a given cell, and the horizontal axis indicates whether the cell has been classified as “perturbed” (i.e., it contains the gRNA) or unperturbed (i.e., it does not contain the gRNA). Perturbed (resp., unperturbed) cells are shown in the left (resp., right) column. The bottom left panel is a barplot of the number of cells to which each gRNA has been mapped. Finally, the bottom right panel is a histogram of the number of gRNAs contained in each cell. The mean number of gRNAs per cell — i.e., the MOI — is displayed in purple text.\nSee 3  Assign gRNAs for more information about assigning gRNAs to cells.",
    "crumbs": [
      "The whole game"
    ]
  },
  {
    "objectID": "sceptre.html#sec-sceptre_qc",
    "href": "sceptre.html#sec-sceptre_qc",
    "title": "The whole game",
    "section": "4. Run quality control (optional)",
    "text": "4. Run quality control (optional)\nThe fourth step is to run quality control (QC). This step likewise can be skipped, in which case QC is applied automatically using default options. sceptre implements two kinds of QC: cellwise QC and pairwise QC. The former aims to remove low-quality cells, while the latter aims to remove low-quality target-response pairs.\nThe cellwise QC that sceptre implements is standard in single-cell analysis. Cells for which response_n_nonzero (i.e., the number of expressed responses) or response_n_umis (i.e., the number of response UMIs) are extremely high or extremely low are removed. Likewise, cells for which response_p_mito (i.e., the fraction of UMIs mapping to mitochondrial genes) is excessively high are removed. Additionally, in low-MOI, cells that contain zero or multiple gRNAs (as determined during the RNA-to-cell assignment step) are removed. Finally, users optionally can provide a list of additional cells to remove.\nsceptre also implements QC at the level of the target-response pair. For a given pair we define the “treatment cells” as those that contain a gRNA targeting the given target. Next, we define the “control cells” as the cells against which the treatment cells are compared to carry out the differential expression test. We define the “number of nonzero treatment cells” (n_nonzero_trt) as the number of treatment cells with nonzero expression of the response; similarly, we define the “number of nonzero control cells” (n_nonzero_cntrl) as the number of control cells with nonzero expression of the response. sceptre filters out pairs for which n_nonzero_trt or n_nonzero_cntrl falls below some threshold (by default 7).\nWe call the function run_qc() on the sceptre_object to carry out cellwise and pairwise QC. run_qc() has several optional arguments that control the stringency of the various QC thresholds. For example, we set p_mito_threshold = 0.075, which filters out cells whose response_p_mito value exceeds 0.075. (The optional arguments are set to reasonable defaults; the default for p_mito_threshold is 0.2, for instance).\n\nsceptre_object &lt;- run_qc(sceptre_object, p_mito_threshold = 0.075)\nprint(sceptre_object) # output suppressed for brevity\n\nWe can visualize the output of the QC step by calling plot() on the updated sceptre_object.\n\nplot(sceptre_object)\n\n\n\n\n\nCellwise and pairwise quality control\n\n\n\nThe top panel depicts the outcome of the cellwise QC. The various cellwise QC filters (e.g., “N nonzero responses,” “N response UMIs,” “Percent mito”, etc.) are shown on the horizontal axis, and the percentage of cells removed due application of a given QC filter is shown on the vertical axis. Note that a cell can be flagged by multiple QC filters; for example, a cell might have an extremely high response_n_umi value and an extremely high response_n_nonzero value. Thus, the height of the “any filter” bar (which indicates the percentage of cells removed due to application of any filter) need not be equal to the sum of the heights of the other bars. The bottom panel depicts the outcome of the pairwise QC. Each point corresponds to a target-response pair; the vertical axis (resp., horizontal axis) indicates the n_nonzero_trt (resp., n_nonzero_cntrl) value of that pair. Pairs for which n_nonzero_trt or n_nonzero_cntrl fall below the threshold are removed (red), while the remaining pairs are retained (green).\nSee 4  Run quality control for more information about QC.",
    "crumbs": [
      "The whole game"
    ]
  },
  {
    "objectID": "sceptre.html#sec-sceptre_calibration_check",
    "href": "sceptre.html#sec-sceptre_calibration_check",
    "title": "The whole game",
    "section": "5. Run calibration check",
    "text": "5. Run calibration check\nThe fifth step is to run the calibration check. The calibration check is an analysis that verifies that sceptre controls the rate of false discoveries on the dataset under analysis. The calibration check proceeds as follows. First, negative control target-response pairs are constructed (automatically) by coupling subsets of NT gRNAs to randomly selected responses. Importantly, the negative control pairs are constructed in such a way that they are similar to the discovery pairs, the difference being that the negative control pairs are devoid of biological signal. Next, sceptre is applied to analyze the negative control pairs. Given that the negative control pairs are absent of signal, sceptre should produce approximately uniformly distributed p-values on the negative control pairs. Moreover, after an appropriate multiple testing correction, sceptre should make zero (or very few) discoveries on the negative control pairs. Verifying calibration via the calibration check increases our confidence that the discovery set that sceptre ultimately produces is uncontaminated by excess false positives.\nWe run the calibration check by calling the function run_calibration_check() on the sceptre_object.\n\nsceptre_object &lt;- run_calibration_check(sceptre_object, parallel = TRUE)\nprint(sceptre_object) # output suppressed for brevity\n\nWe can assess the outcome of the calibration check by calling plot() on the resulting sceptre_object.\n\nplot(sceptre_object)\n\n\n\n\n\nCalibration check results\n\n\n\nThe visualization consists of four panels, which we describe below.\n\nThe upper left panel is a QQ plot of the p-values plotted on an untransformed scale. The p-values should lie along the diagonal line, indicating uniformity of the p-values in the bulk of the distribution.\nThe upper right panel is a QQ plot of the p-values plotted on a negative log-10 transformed scale. The p-values again should lie along the diagonal line (with the majority of the p-values falling within the gray confidence band), indicating uniformity of the p-values in the tail of the distribution.\nThe lower left panel is a histogram of the estimated log-2 fold changes. The histogram should be roughly symmetric and centered around zero.\nFinally, the bottom right panel is a text box displaying (i) the number of false discoveries that sceptre has made on the negative control data and (ii) the mean estimated log-fold change. The number of false discoveries should be a small integer like zero, one, two, or three, with zero being ideal. The mean estimated log-fold change, meanwhile, should be a numeric value close to zero; a number in the range [-0.1, 0.1] is adequate.\n\nsceptre may not exhibit good calibration initially, which is OK. See 5  Run calibration check for more information about the calibration check analysis, including concrete strategies for improving calibration.",
    "crumbs": [
      "The whole game"
    ]
  },
  {
    "objectID": "sceptre.html#sec-sceptre_run_power_check",
    "href": "sceptre.html#sec-sceptre_run_power_check",
    "title": "The whole game",
    "section": "6. Run power check (optional)",
    "text": "6. Run power check (optional)\nThe sixth step — which is optional — is to run the power check. The power check involves applying sceptre to analyze the positive control pairs. Given that the positive control pairs are known to contain signal, sceptre should produce significant (i.e., small) p-values on the positive control pairs. The power check enables us to assess sceptre’s power (i.e., its ability to detect true associations) on the dataset under analysis. We run the power check by calling the function run_power_check() on the sceptre_object.\n\nsceptre_object &lt;- run_power_check(sceptre_object, parallel = TRUE)\nprint(sceptre_object) # output suppressed for brevity\n\nWe can visualize the outcome of the power check by calling plot() on the resulting sceptre_object.\n\nplot(sceptre_object)\n\n\n\n\n\nPower check results\n\n\n\nEach point in the plot corresponds to a target-response pair, with positive control pairs in the left column and negative control pairs in the right column. The vertical axis indicates the p-value of a given pair; smaller (i.e., more significant) p-values are positioned higher along this axis (p-values truncated at \\(10^{-20}\\) for visualization). The positive control p-values should be small, and in particular, smaller than the negative control p-values.",
    "crumbs": [
      "The whole game"
    ]
  },
  {
    "objectID": "sceptre.html#sec-sceptre_run_discovery_analysis",
    "href": "sceptre.html#sec-sceptre_run_discovery_analysis",
    "title": "The whole game",
    "section": "7. Run discovery analysis",
    "text": "7. Run discovery analysis\nThe seventh and penultimate step is to run the discovery analysis. The discovery analysis entails applying sceptre to analyze the discovery pairs. We run the discovery analysis by calling the function run_discovery_analysis().\n\nsceptre_object &lt;- run_discovery_analysis(sceptre_object, parallel = TRUE)\nprint(sceptre_object) # output suppressed for brevity\n\nWe can visualize the outcome of the discovery analysis by calling plot() on the resulting sceptre_object.\n\nplot(sceptre_object)\n\n\n\n\n\nDiscovery analysis results\n\n\n\nThe visualization consists of four panels.\n\nThe upper left plot superimposes the discovery p-values (blue) on top of the negative control p-values (red) on an untransformed scale.\nThe upper right plot is the same as the upper left plot, but the scale is negative log-10 transformed. The discovery p-values should trend above the diagonal line, indicating the presence of signal in the discovery set. The horizontal dashed line indicates the multiple testing threshold; discovery pairs whose p-value falls above this line are called as significant.\nThe bottom left panel is a volcano plot of the p-values and log fold changes of the discovery pairs. Each point corresponds to a pair; the estimated log-2 fold change of the pair is plotted on the horizontal axis, and the (negative log-10 transformed) p-value is plotted on the vertical axis. The horizontal dashed line again indicates the multiple testing threshold. Points above the dashed line (colored in purple) are called as discoveries, while points below (colored in blue) are called as insignificant.\nThe bottom right panel is a text box displaying the number of discovery pairs called as significant.",
    "crumbs": [
      "The whole game"
    ]
  },
  {
    "objectID": "sceptre.html#sec-sceptre_write_outputs_to_directory",
    "href": "sceptre.html#sec-sceptre_write_outputs_to_directory",
    "title": "The whole game",
    "section": "8. Write outputs to directory",
    "text": "8. Write outputs to directory\nThe eighth and final step is to write the outputs of the analysis to a directory on disk. We call the function write_outputs_to_directory(), which takes as arguments a sceptre_object and directory; directory is a string indicating the location of the directory in which to write the results contained within the sceptre_object.\n\nwrite_outputs_to_directory(\n  sceptre_object = sceptre_object, \n  directory = \"~/sceptre_outputs\"\n)\n\nwrite_outputs_to_directory() writes several files to the specified directory: a text-based summary of the analysis (analysis_summary.txt), the various plots (*.png), the calibration check, power check, discovery analysis results (results_run_calibration_check.rds, results_run_power_check.rds, and results_run_discovery_analysis.rds, respectively), and the binary gRNA-to-cell assignment matrix (grna_assignment_matrix.rds).\n\nlist.files(\"~/sceptre_outputs\")\n\n [1] \"analysis_summary.txt\"               \"grna_assignment_matrix.rds\"        \n [3] \"plot_assign_grnas.png\"              \"plot_grna_count_distributions.png\" \n [5] \"plot_run_calibration_check.png\"     \"plot_run_discovery_analysis.png\"   \n [7] \"plot_run_power_check.png\"           \"plot_run_qc.png\"                   \n [9] \"results_run_calibration_check.rds\"  \"results_run_discovery_analysis.rds\"\n[11] \"results_run_power_check.rds\"       \n\n\nWe also can obtain the calibration check, power check, and discovery analysis results in R via a call to the function get_result(), passing as arguments sceptre_object and analysis, where the latter is a string indicating the function whose results we are querying.\n\nresult &lt;- get_result(\n  sceptre_object = sceptre_object,\n  analysis = \"run_discovery_analysis\"\n)\n\nThe variable result is a data frame, the rows of which correspond to target-response pairs, and the columns of which are as follows: response_id, grna_target, n_nonzero_trt, n_nonzero_cntrl, pass_qc (a TRUE/FALSE value indicating whether the pair passes pairwise QC), p_value, log_2_fold_change, and significant (a TRUE/FALSE value indicating whether the pair is called as significant). The p-value contained within the p_value column is a raw (i.e., non-multiplicity-adjusted) p-value.\n\nhead(result)\n\n       response_id      grna_target n_nonzero_trt n_nonzero_cntrl pass_qc\n            &lt;char&gt;           &lt;char&gt;         &lt;int&gt;           &lt;int&gt;  &lt;lgcl&gt;\n1: ENSG00000147454 candidate_enh_19           987           38763    TRUE\n2: ENSG00000136938 candidate_enh_20           829           43056    TRUE\n3: ENSG00000165702 candidate_enh_23           421           17129    TRUE\n4: ENSG00000136929 candidate_enh_20           507           30997    TRUE\n5: ENSG00000135046 candidate_enh_25           438           32903    TRUE\n6: ENSG00000106992 candidate_enh_22           693           30172    TRUE\n        p_value log_2_fold_change significant\n          &lt;num&gt;             &lt;num&gt;      &lt;lgcl&gt;\n1: 4.913199e-39        -0.7299781        TRUE\n2: 3.674899e-37        -0.3377841        TRUE\n3: 2.742344e-31        -0.7788056        TRUE\n4: 7.510057e-24        -0.6062542        TRUE\n5: 1.112955e-18        -0.8483076        TRUE\n6: 1.142874e-14        -0.3438875        TRUE",
    "crumbs": [
      "The whole game"
    ]
  },
  {
    "objectID": "sceptre.html#further-reading",
    "href": "sceptre.html#further-reading",
    "title": "The whole game",
    "section": "Further reading",
    "text": "Further reading\nEach step of the pipeline has its own dedicated chapter in Part I of this book. We encourage interested users to read these additional chapters one-by-one to learn more about the various options available at each step of the pipeline, starting with 1  Import data.\nAlso, see complete worked examples for the low-MOI CRISPRko and high-MOI CRISPRi data by calling ?sceptre in the console.\n\n\n\n\nGasperini, Molly, Andrew J. Hill, José L. McFaline-Figueroa, Beth Martin, Seungsoo Kim, Melissa D. Zhang, Dana Jackson, et al. 2019. “A Genome-wide Framework for Mapping Gene Regulation via Cellular Genetic Screens.” Cell 176 (1): 377–90.",
    "crumbs": [
      "The whole game"
    ]
  },
  {
    "objectID": "import-data.html",
    "href": "import-data.html",
    "title": "1  Import data",
    "section": "",
    "text": "1.1 Import data from an existing software package\nsceptre links up with two programs for upstream processing of single-cell CRISPR screen data: 10X Cell Ranger and the analogous software tool developed by Parse Biosciences. (We refer to the latter program as the “Parse program.”) We describe how to import data from each of these tools below.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Import data</span>"
    ]
  },
  {
    "objectID": "import-data.html#import-data-from-an-existing-software-package",
    "href": "import-data.html#import-data-from-an-existing-software-package",
    "title": "1  Import data",
    "section": "",
    "text": "1.1.1 Import from 10X Cell Ranger\nSection 1 of The whole game describes how to import data from 10X Cell Ranger. We include a minimal working example here.\n\ndirectories &lt;- paste0(\n  system.file(\"extdata\", package = \"sceptredata\"),\n  \"/highmoi_example/gem_group_\", 1:2)\ndata(grna_target_data_frame_highmoi)\nsceptre_object &lt;- import_data_from_cellranger(\n  directories = directories,\n  moi = \"high\",\n  grna_target_data_frame = grna_target_data_frame_highmoi\n)\n\n\n1.1.2 Import from the Parse program (experimental)\nUsers also can import data from the output of the Parse CRISPR Detect platform via the function import_data_from_parse(). import_data_from_parse() takes the arguments gene_mat_fp, grna_mat_fp, all_genes_fp, all_grnas_fp, moi, grna_target_data_frame, and extra_covariates. (Only the latter argument is optional; all others are required.) gene_mat_fp (resp., grna_mat_fp) is a file path to the .mtx file storing the gene (resp., gRNA) expression data. Next, all_genes_fp is a file path to the all_genes.csv file. all_genes.csv is assumed to have columns “gene_id,” “gene_name,” and “genome;” the first two columns are assumed to give the ID and human readable name, respectively, of each gene, and the last column (indicating the genome to which each gene belongs) is ignored. Next, all_grnas_fp is a file path to the all_grnas.csv file. all_grnas.csv is assumed to contain columns “gene_id,” “gene_name,” and “genome.” The column “gene_name” is assumed to give the ID of each gRNA; the remaining two columns are ignored. Additionally, moi is a string indicating the MOI of the dataset and can take values \"low\" or \"high\". Finally, extra_covariates is an optional data frame of extra covariates to pass to sceptre (see below). It is assumed that the data are stored in a single set of files (as opposed to multiple sets of files corresponding to, e.g., different samples). Below, we provide an example of initializing a sceptre_object from a set of Parse outputs.\n\ndirectory &lt;- paste0(system.file(\"extdata\", package = \"sceptredata\"),\n                    \"/parse_example/\")\ngene_mat_fp &lt;- paste0(directory, \"gene_mat.mtx\")\ngrna_mat_fp &lt;- paste0(directory, \"grna_mat.mtx\")\nall_genes_fp &lt;- paste0(directory, \"all_genes.csv\")\nall_grnas_fp &lt;- paste0(directory, \"all_grnas.csv\")\ngrna_target_data_frame &lt;- data.frame(\n   grna_id = c(\"guide_A\", \"guide_B\", \"guide_C\"),\n   grna_target = c(\"target-A\", \"target-B\", \"non-targeting\")\n)\nsceptre_object &lt;- import_data_from_parse(\n  gene_mat_fp = gene_mat_fp,\n  grna_mat_fp = grna_mat_fp,\n  all_genes_fp = all_genes_fp,\n  all_grnas_fp = all_grnas_fp,\n  moi = \"low\",\n  grna_target_data_frame = grna_target_data_frame\n)\n\nWe encourage Parse users to examine the example Parse data to ensure that their data match the example data. import_data_from_parse() is an experimental function, and the API of this function is subject to change. We expect the API of import_data_from_parse() to solidify as we learn more about the Parse CRISPR detect platform and the structure of the Parse program output.\n\n1.1.3 Add extra covariates\nimport_data_from_cellranger() and input_data_from_parse() compute the covariates grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito, and batch. Users may wish to supply additional covariates (e.g., cell cycle or cell type) to sceptre. To do so, users can pass a data frame extra_covariates containing additional covariates to import_data_from_cellranger() or input_data_from_parse(). Below, we simulate an additional covariate cell_type and pass this covariate as an argument to the data import function.\n\n# simulate an extra covariate, namely cell type\ncell_type &lt;- sample(\n  x = paste0(\"type_\", 1:3),\n  size = 45919,\n  replace = TRUE\n) |&gt; factor()\nextra_covariates &lt;- data.frame(cell_type = cell_type)\n\n# import data, passing the the extra covariates as an argument\nsceptre_object &lt;- import_data_from_cellranger(\n  directories = directories,\n  moi = \"high\",\n  grna_target_data_frame = grna_target_data_frame_highmoi,\n  extra_covariates = extra_covariates\n)\n\nThe additional covariate of cell_type is printed in the “covariates” field when we evaluate sceptre_object in the console.\n\nsceptre_object\n\nAn object of class sceptre_object.\n\nAttributes of the data:\n    • 45919 cells\n    • 526 responses\n    • High multiplicity-of-infection \n    • 70 targeting gRNAs (distributed across 35 targets) \n    • 25 non-targeting gRNAs \n    • 7 covariates (batch, cell_type, grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito)",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Import data</span>"
    ]
  },
  {
    "objectID": "import-data.html#import-data-from-a-collection-of-r-objects",
    "href": "import-data.html#import-data-from-a-collection-of-r-objects",
    "title": "1  Import data",
    "section": "\n1.2 Import data from a collection of R objects",
    "text": "1.2 Import data from a collection of R objects\nUsers also can import data into sceptre from a specified set of R objects. This data import strategy is most appropriate for users employing less standard data preprocessing pipelines for generating the response and gRNA count matrices. We use the high-MOI CRISPRi data as a working example. We can obtain these data in R matrix and data frame format as follows.\n\ndata(highmoi_example_data)\n# response matrix\nresponse_matrix &lt;- highmoi_example_data$response_matrix\n# grna matrix\ngrna_matrix &lt;- highmoi_example_data$grna_matrix\n# batch information\nextra_covariates &lt;- highmoi_example_data$extra_covariates\n# response names\nresponse_names &lt;- highmoi_example_data$gene_names\n# gRNA target data frame\ngrna_target_data_frame &lt;- grna_target_data_frame_highmoi\n\nWe call the function import_data() to import the data from a collection of R objects. import_data() takes several arguments: response_matrix, grna_matrix, grna_target_data_frame, moi, extra_covariates, and response_names. The following figure summarizes the main inputs to this function.\n\n\n\n\nThe main data objects involved in a single-cell CRISPR screen analysis: a response matrix, a gRNA matrix, a data frame of extra covariates (optional), and a gRNA target data frame.\n\n\n\nWe describe the inputs below.\n\n\nresponse_matrix is the matrix of response UMI counts. The responses should be in the rows and the cells in the columns. The row names of the response_matrix should be the response IDs. The first ten rows and columns of the example response_matrix are as follows.\n\nresponse_matrix[1:10,1:10]\n\n10 x 10 sparse Matrix of class \"dgTMatrix\"\n\nENSG00000069275 4 6 10 9 4 13 8 8 10 8\nENSG00000117222 2 1  . 1 1  . . .  . 1\nENSG00000117266 . .  . . .  . . .  . .\nENSG00000117280 . .  . 1 .  . . .  . 1\nENSG00000133059 . .  . . .  1 . 2  . 1\nENSG00000133065 . .  . . .  . . 2  . 1\nENSG00000133069 . .  . . .  . . .  . .\nENSG00000158711 . .  . . .  . . 1  . .\nENSG00000158715 . .  . . .  . . .  . .\nENSG00000162873 . .  . . .  . . .  . .\n\n\n\n\ngrna_matrix is the matrix of gRNA UMI counts. The gRNAs should be in the rows and the cells in the columns. The row names of grna_matrix should be the gRNA IDs. The first ten rows and columns of the example grna_matrix are as follows.\n\ngrna_matrix[1:10,1:10]\n\n10 x 10 sparse Matrix of class \"dgTMatrix\"\n\ngrna_CCGGGCG . 8 . . .  . . . . .\ngrna_TGGCGGC . . . . .  . . . . .\ngrna_AAGGCCG . . . . .  . . . . .\ngrna_GACGCCG . . . . .  . . . . .\ngrna_CACACCC . . . . . 25 . . . .\ngrna_GCTCACA . . . . .  . . . . .\ngrna_CTCTGAG . . . . .  . . . . .\ngrna_GCGCCCG . . . . .  . . . . .\ngrna_GAGCGTG . . . . .  . . . . .\ngrna_GCTCTGC . . . . .  . . . . .\n\n\nresponse_matrix and grna_matrix should be stored in one of the following formats: matrix, dgTMatrix, dgCMatrix, or dgRMatrix. Note that the columns of response_matrix and grna_matrix are assumed to correspond to the same ordering of cells. Users should make sure to preserve the consistency of column ordering. We recommend that users add cell barcodes as column names for response_matrix and grna_matrix, in which case sceptre checks the consistency of cell ordering.\n\n\ngrna_target_data_frame is the data frame mapping each gRNA to its target. The grna_target_data_frame that we pass to import_data() is exactly the same as the one that we pass to import_data_from_cellranger. See Section 1 of The whole game for more information about this argument.\n\ngrna_target_data_frame[c(1:4, 21:24, 80:83),]\n\n        grna_id      grna_target   chr     start       end\n1  grna_CCGGGCG  ENSG00000069482 chr11  68451943  68451958\n2  grna_TGGCGGC  ENSG00000069482 chr11  68451958  68451974\n3  grna_AAGGCCG  ENSG00000100316 chr22  39715775  39715790\n4  grna_GACGCCG  ENSG00000100316 chr22  39715790  39715806\n21 grna_TCTTGAC  candidate_enh_1  chr1 205720419 205720623\n22 grna_TGATCGC  candidate_enh_1  chr1 205720623 205720828\n23 grna_ATAGGAG candidate_enh_10 chr19  19475680  19475878\n24 grna_GCAGGCA candidate_enh_10 chr19  19475878  19476077\n80 grna_TATTCGT    non-targeting  &lt;NA&gt;        NA        NA\n81 grna_GACCTCC    non-targeting  &lt;NA&gt;        NA        NA\n82 grna_TTTCTCT    non-targeting  &lt;NA&gt;        NA        NA\n83 grna_AATGAGG    non-targeting  &lt;NA&gt;        NA        NA\n\n\n\n\nmoi is a string specifying the MOI of the dataset, either “high” or “low”. This argument serves the same function as it does in import_data_from_cellranger. See Section 1 of The whole game for more information.\n\nmoi &lt;- \"high\"\n\n\n\nextra_covariates (optional) is a data frame specifying cell-specific covariates beyond those that sceptre can compute. import_data() computes the covariates grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, and response_p_mito. import_data() does not compute batch, as import_data() does not have access to batch information. Thus, batch — alongside any other relevant covariates, such as cell type — should be included in the extra_covariates data frame. Note that the rows of extra_covariates are assumed to be in the same order as the columns of response_matrix and grna_matrix. We recommend users add cell barcodes as row names of extra_covariates, in which case sceptre will check the consistency of cell ordering.\n\nextra_covariates[c(1:3, 30001:30003),,drop = FALSE]\n\n      batch\n1        b1\n2        b1\n3        b1\n30001    b2\n30002    b2\n30003    b2\n\n\n\n\nresponse_names (optional) is a vector of human-readable response names. response_names is used to determine which of the responses (if any) are mitochondrial genes for the purpose of computing the response_p_mito covariate.\n\nhead(response_names)\n\n[1] \"NUCKS1\"  \"RBBP5\"   \"CDK18\"   \"RAB29\"   \"DSTYK\"   \"SLC41A1\"\n\n\n\n\nWe pass the arguments response_matrix, grna_matrix, grna_target_data_frame, moi, extra_covariates, and response_names to import_data(), which initializes a sceptre_object.\n\nsceptre_object &lt;- import_data(\n  response_matrix = response_matrix,\n  grna_matrix = grna_matrix,\n  grna_target_data_frame = grna_target_data_frame,\n  moi = moi,\n  extra_covariates = extra_covariates,\n  response_names = response_names\n)",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Import data</span>"
    ]
  },
  {
    "objectID": "import-data.html#multi-guide-vector-data",
    "href": "import-data.html#multi-guide-vector-data",
    "title": "1  Import data",
    "section": "\n1.3 Multi-guide vector data",
    "text": "1.3 Multi-guide vector data\ngRNAs are delivered to cells via a viral vector. In low-MOI screens the experimenter aims to deliver one viral vector to each cell; in high-MOI screens, by contrast, the experimenter aims to deliver multiple viral vectors (each harboring a different gRNA) to each cell. Some recent single-cell CRISPR screens involve a special design in which each viral vector harbors multiple gRNAs. For example, Replogle et al. (2022) conducted a screen in which each viral vector contained two gRNAs, each targeting the same site. In such “multi-guide vector” screens, the user should account for the vector that harbors each gRNA so as to ensure that the cellwise QC and association testing steps are carried out correctly. Users can pass vector information to sceptre by including a vector_id column in the grna_target_data_frame, which specifies the vector on which a given gRNA is located (Figure 1.1).\n\n\n\n\n\n\n\nFigure 1.1: Example gRNA target data frame for multi-guide vector data.\n\n\n\n\nsceptre employs a simple strategy for handling multi-guide vector data: the UMI counts of gRNAs contained on the same vector are summed, and the resulting quantity is treated as if it were the expression vector of an individual gRNA. The vector IDs should be nested within the gRNA targets. (In other words, each gRNA target can map to multiple vector IDs, but each vector ID should map to a single gRNA target.) Finally, the genomic coordinate columns chr, start, and end optionally can be included the gRNA target data frame, but rows containing the same value for vector_id also should contain the same value for chr, start, and end.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Import data</span>"
    ]
  },
  {
    "objectID": "import-data.html#accessing-the-fields-of-a-sceptre_object",
    "href": "import-data.html#accessing-the-fields-of-a-sceptre_object",
    "title": "1  Import data",
    "section": "\n1.4 Accessing the fields of a sceptre_object\n",
    "text": "1.4 Accessing the fields of a sceptre_object\n\nA sceptre_object is an S4 object. Like all S4 objects, a sceptre_object contains data, including raw data inputted by the user and processed data that sceptre generates by operating on the raw data. The data stored within a sceptre_object can be accessed via the @ operator (e.g., sceptre_object@foo). We recommend against accessing the data stored within a sceptre_object in this way. Instead, users should interact with a sceptre_object via the functions exported by the package. For example, the “getter” functions get_response_matrix(), get_grna_matrix(), and get_cell_covariates() return the response matrix, gRNA matrix, and cell covariates, respectively, of a sceptre_object.\n\nresponse_matrix &lt;- get_response_matrix(sceptre_object)\ngrna_matrix &lt;- get_grna_matrix(sceptre_object)\ncell_covariates &lt;- get_cell_covariates(sceptre_object)",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Import data</span>"
    ]
  },
  {
    "objectID": "import-data.html#sec-import_data_odm_ch_1",
    "href": "import-data.html#sec-import_data_odm_ch_1",
    "title": "1  Import data",
    "section": "\n1.5 Initializing an ondisc-backed sceptre-object",
    "text": "1.5 Initializing an ondisc-backed sceptre-object\nondisc is a companion R package to sceptre that — in conjunction with sceptre — enables users to analyze large-scale single-cell CRISPR screen data out-of-core on a laptop or distributed across multiple nodes on a computing cluster. An “ondisc-backed sceptre_object” is a special kind of sceptre_object in which the response and gRNA expression matrices are stored on-disk rather than in memory. We defer a detailed discussion of the ondisc package and large-scale single-cell CRISPR screen data analysis to Part II of this book (i.e., Chapter 7 — Chapter 9). Here, we briefly describe how to create an ondisc-backed sceptre_object. Users can create an ondisc-backed sceptre_object by calling a standard data import function (i.e., import_data() or import_data_from_cellranger()), setting the argument use_ondisc to TRUE and directory_to_write to the directory in which to write the disk-based gene and gRNA expression matrices. The table below summarizes which data import function one should call (and which arguments one should supply to that data import function) on the basis of the input data type and whether one wishes to create a standard sceptre_object or an ondisc-backed sceptre_object. (Note that initializing an ondisc-backed sceptre_object from the output of the Parse program is not yet implemented.)\n\n\n\n\n\n\n\nInput type\nStandard sceptre_object\n\n\nondisc-backed sceptre_object\n\n\n\n\nR matrices\nimport_data\nimport_data(\n  use_ondisc = TRUE,\n  directory_to_write = \"/path/\",\n)\n\n\n10X Cell Ranger\nimport_data_from_cellranger\nimport_data_from_cellranger(\n  use_ondisc = TRUE,\n  directory_to_write = \"/path/\"\n)\n\n\nParse\nimport_data_from_parse\nNot implemented\n\n\n\nFor example, below, we create an ondisc-backed sceptre_object to represent the high-MOI CRISPRi data, taking as input the output directories from cellranger count and setting directory_to_write to the temporary directory tempdir().\nsceptre_object &lt;- import_data_from_cellranger(\n  directories = directories,\n  moi = \"high\",\n  grna_target_data_frame = grna_target_data_frame_highmoi,\n  use_ondisc = TRUE,\n  directory_to_write = tempdir()\n)\nSee Section 7.1 and Section 9.3 for more information.\n\n\n\n\nReplogle, Joseph M, Reuben A Saunders, Angela N Pogson, Jeffrey A Hussmann, Alexander Lenail, Alina Guna, Lauren Mascibroda, et al. 2022. “Mapping Information-Rich Genotype-Phenotype Landscapes with Genome-Scale Perturb-Seq.” Cell 185 (14): 2559–75.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Import data</span>"
    ]
  },
  {
    "objectID": "set-analysis-parameters.html",
    "href": "set-analysis-parameters.html",
    "title": "2  Set analysis parameters",
    "section": "",
    "text": "2.1 Positive control pairs\nPositive control pairs are target-response pairs for which we know (or have strong reason to believe) that there is a regulatory relationship between the target and the response. We can use positive control pairs to verify that sceptre (or any association testing method for that matter) is sensitive (i.e., capable of detecting true associations) on the dataset under analysis. We use the function construct_positive_control_pairs() to construct the positive control pairs. construct_positive_control_pairs() takes as an argument a sceptre_object and returns a data frame with columns grna_target and response_id, where gRNA targets and response IDs with matching names are paired. We call construct_positive_control_pairs() on the high-MOI CRISPRi dataset and the low-MOI CRISPRko dataset. In both cases the positive control set consists of transcription start sites paired to the gene regulated by those transcription start sites.\npositive_control_pairs_highmoi &lt;- construct_positive_control_pairs(\n  sceptre_object = sceptre_object_highmoi\n)\nhead(positive_control_pairs_highmoi) # high MOI CRISPRi dataset\n\n      grna_target     response_id\n1 ENSG00000069482 ENSG00000069482\n2 ENSG00000100316 ENSG00000100316\n3 ENSG00000104131 ENSG00000104131\n4 ENSG00000122026 ENSG00000122026\n5 ENSG00000135821 ENSG00000135821\n6 ENSG00000147669 ENSG00000147669\npositive_control_pairs_lowmoi &lt;- construct_positive_control_pairs(\n  sceptre_object = sceptre_object_lowmoi\n)\nhead(positive_control_pairs_lowmoi) # low MOI CRISPRko dataset\n\n  grna_target response_id\n1       CMTM6       CMTM6\n2      IFNGR2      IFNGR2\n3        JAK2        JAK2\n4      NFKBIA      NFKBIA\n5       STAT1       STAT1\n6       STAT2       STAT2\nPositive control pairs need not consist exclusively of gene transcription start sites paired to target genes. For example, enhancer-gene links that have been validated previously (through, e.g., an arrayed CRISPR screen with bulk RNA-seq, or a bulk CRISPR screen with cell sorting) also can serve as positive control pairs. Users manually can append additional positive control pairs to the positive control pair data frame via a call to rbind(). For example, suppose we know on the high-MOI CRISPRi data that candidate_enh_1 regulates gene ENSG00000069482 and that candidate_enh_10 regulates gene ENSG00000135821. We can add these enhancer-gene links to the positive control pair data frame as follows.\n# construct data frame of additional positive control pairs\nadditional_positive_control_pairs &lt;-\n  data.frame(grna_target = c(\"candidate_enh_1\", \"candidate_enh_10\"),\n             response_id = c(\"ENSG00000069482\", \"ENSG00000135821\"))\n\n# append additional pairs to positive control data frame\npositive_control_pairs_highmoi_updated &lt;- rbind(\n  positive_control_pairs_highmoi,\n  additional_positive_control_pairs\n)\npositive_control_pairs_highmoi_updated\n\n        grna_target     response_id\n1   ENSG00000069482 ENSG00000069482\n2   ENSG00000100316 ENSG00000100316\n3   ENSG00000104131 ENSG00000104131\n4   ENSG00000122026 ENSG00000122026\n5   ENSG00000135821 ENSG00000135821\n6   ENSG00000147669 ENSG00000147669\n7   ENSG00000155380 ENSG00000155380\n8   ENSG00000176890 ENSG00000176890\n9   ENSG00000187840 ENSG00000187840\n10  ENSG00000196683 ENSG00000196683\n11  candidate_enh_1 ENSG00000069482\n12 candidate_enh_10 ENSG00000135821\nWe then could supply positive_control_pairs_highmoi_updated instead of positive_control_pairs_highmoi to set_analysis_parameters().",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Set analysis parameters</span>"
    ]
  },
  {
    "objectID": "set-analysis-parameters.html#sec-set_analysis_parameters_discovery_pairs",
    "href": "set-analysis-parameters.html#sec-set_analysis_parameters_discovery_pairs",
    "title": "2  Set analysis parameters",
    "section": "\n2.2 Discovery pairs",
    "text": "2.2 Discovery pairs\nDiscovery pairs are target-response pairs whose association status we do not know but seek to learn. Unlike positive control and negative control pairs, which serve a mainly technical purpose, discovery pairs are of primary scientific interest. sceptre provides two helper functions for constructing discovery pairs: construct_cis_pairs() and construct_trans_pairs().\n\n2.2.1 Construct cis pairs\nconstruct_cis_pairs() returns the set of target-response pairs for which the target and response are located on the same chromosome and in close physical proximity to one another. construct_cis_pairs() is a useful pair constructor function for screens that aim to map noncoding regulatory elements (e.g., enhancers or noncoding GWAS variants) to target genes or proteins in cis. construct_cis_pairs() assumes that the columns chr, start, and stop are present in the grna_target_data_frame, giving the chromosome, start position, and end position of the region that each gRNA targets. construct_cis_pairs() takes several arguments: sceptre_object (required) distance_threshold (optional), positive_control_pairs (optional), and response_position_data_frame (optional). By default, construct_cis_pairs() pairs each gRNA target to the set of responses on the same chromosome as that target and within distance_threshold bases of that target. (The default value of distance_threshold is 500,000 bases, or half a megabase.) The positive_control_pairs data frame optionally can be passed to construct_cis_pairs(), in which case the positive control targets (i.e., the entries within the grna_target column of positive_control_pairs) are excluded from the cis pairs. One may want to exclude these from the discovery analysis if these targets are intended for positive control purposes only.\nFinally, response_position_data_frame is an optional data frame containing the columns response_id, chr, and position, where chr and position give the genomic coordinate of each response_id. The default value of response_position_data_frame is gene_position_data_frame_grch38, which is a data frame that ships with sceptre that contains the genomic coordinate of the transcription start site of all genes in the human genome. We print several rows of gene_position_data_frame_grch38 below.\n\ngene_position_data_frame_grch38[c(1:4, 8001:8004),]\n\n       response_id    chr position\n            &lt;char&gt; &lt;fctr&gt;    &lt;int&gt;\n1: ENSG00000243485   chr1    29554\n2: ENSG00000237613   chr1    36081\n3: ENSG00000186092   chr1    65419\n4: ENSG00000239945   chr1    91105\n5: ENSG00000127328  chr12 69738681\n6: ENSG00000166268  chr12 69825227\n7: ENSG00000257241  chr12 69947081\n8: ENSG00000257139  chr12 70180338\n\n\ngene_position_data_frame_grch38 was derived from the GrCh38 (hg19) reference genome, which is the reference genome that all versions of cellranger count released since 2021 have used for alignment. Users can pass their own response_position_data_frame to construct_cis_pairs() if the gene_position_data_frame_grch38 data frame included within sceptre is inadequate for their analysis. For example, some users may wish to map enhancers to proteins in cis. Such users could construct the discovery set by coupling each enhancer to the set of proteins whose corresponding gene is in close physical proximity to that enhancer. In such an analysis response_position_data_frame would be a data frame mapping each protein to the chromosomal position of the transcription start site of its corresponding gene. Note that response_position_data_frame and the chr, start, and stop columns of the grna_target_data_frame should be defined with respect to the same reference genome, as construct_cis_pairs() implements its functionality by intersecting response_position_data_frame with grna_target_data_frame.\nWe use construct_cis_pairs() to construct the discovery pairs for the high-MOI CRISPRi dataset. We set distance_threshold to 5e6 (i.e., 5 megabases) so as to increase the number of pairs in the discovery set for illustration purposes.\n\ndiscovery_pairs_highmoi &lt;- construct_cis_pairs(\n  sceptre_object = sceptre_object_highmoi,\n  positive_control_pairs = positive_control_pairs_highmoi,\n  distance_threshold = 5e6\n)\n\ndiscovery_pairs_highmoi is a data frame with columns grna_target and response_id; each candidate enhancer is mapped to the set of genes in close proximity to that candidate enhancer.\n\ndiscovery_pairs_highmoi[c(1, 10, 20, 30, 40, 50),]\n\n       grna_target     response_id\n1  candidate_enh_1 ENSG00000174529\n10 candidate_enh_1 ENSG00000117280\n20 candidate_enh_2 ENSG00000143493\n30 candidate_enh_2 ENSG00000136643\n40 candidate_enh_3 ENSG00000142733\n50 candidate_enh_3 ENSG00000117748\n\n\n\n2.2.2 Construct trans pairs\nconstruct_trans_pairs() returns the entire set of possible target-response pairs. construct_trans_pairs() is a useful pair constructor function for analyses in which we seek to conduct a trans analysis, testing each target against each response. construct_trans_pairs() takes as arguments sceptre_object (required), positive_control_pairs (optional), and pairs_to_exclude (optional). By default construct_trans_pairs() returns a data frame with columns grna_target and response_id, where each gRNA target is mapped to each response ID.\nThe optional argument pairs_to_exclude enables the user to remove specific pairs from the trans set and takes values \"none\", \"pc_pairs\", or \"pairs_containing_pc_targets\". If pairs_to_exclude is set to \"none\" (the default), then no pairs are removed from the trans set. Next, if pairs_to_exclude is set to \"pc_pairs\" (and the positive_control_pairs data frame is passed), then then the positive control target-response pairs are excluded from the trans set. Finally, if pairs_to_exclude is set to \"pairs_containing_pc_targets\" (and positive_control_pairs is passed), then all pairs containing a positive control gRNA target are excluded from the trans pairs. (In this sense setting pairs_to_exclude to \"pairs_containing_pc_targets\" is stronger than setting pairs_to_exclude to \"pc_pairs\".) Typically, in gene-targeting (resp., noncoding-regulatory-element-targeting) screens, we set pairs_to_exclude to \"pc_pairs\" (resp., \"pairs_containing_pc_targets\"). Below, we call construct_trans_pairs() to construct the discovery set for the low-MOI CRISPRko data.\n\ndiscovery_pairs_lowmoi &lt;- construct_trans_pairs(\n  sceptre_object = sceptre_object_lowmoi,\n  positive_control_pairs = positive_control_pairs_lowmoi,\n  pairs_to_exclude = \"pc_pairs\"\n)\nhead(discovery_pairs_lowmoi)\n\n   grna_target response_id\n        &lt;char&gt;      &lt;char&gt;\n1:        ATF2       PCBP3\n2:        BRD4       PCBP3\n3:        CAV1       PCBP3\n4:       CD274       PCBP3\n5:        CD86       PCBP3\n6:       CMTM6       PCBP3\n\n\nWe also can use construct_trans_pairs() to construct a trans discovery set for the high-MOI, enhancer-targeting CRISPRi dataset. To this end we call construct_trans_pairs(), setting pairs_to_exclude to \"pairs_containing_pc_targets\" so as to exclude all positive control gRNA targets from the trans pairs.\n\ndiscovery_pairs_highmoi_trans &lt;- construct_trans_pairs(\n  sceptre_object = sceptre_object_highmoi,\n  positive_control_pairs = positive_control_pairs_highmoi,\n  pairs_to_exclude = \"pairs_containing_pc_targets\"\n)\n\nThe resulting data frame, discovery_pairs_highmoi_trans, maps each candidate enhancer to the entire set of genes.\n\nhead(discovery_pairs_highmoi_trans)\n\n        grna_target     response_id\n             &lt;char&gt;          &lt;char&gt;\n1:  candidate_enh_1 ENSG00000069275\n2: candidate_enh_10 ENSG00000069275\n3: candidate_enh_11 ENSG00000069275\n4: candidate_enh_12 ENSG00000069275\n5: candidate_enh_13 ENSG00000069275\n6: candidate_enh_14 ENSG00000069275\n\n\nSome users may wish to run both cis and trans analyses on their data. We recommend that such users carry out the sceptre pipeline twice: once using a cis discovery set and once using a trans discovery set. See Section B.7 for more details.\nThe discovery pairs data frame is optional and need not be specified. Users may want to refrain from passing a discovery pairs data frame when runing a control analysis, i.e. an analysis of the negative control pairs and/or positive control pairs exclusively.\n\n2.2.3 Reducing the multiplicity burden\nsceptre computes a p-value for each target-response pair in the discovery set. These p-values are subjected to a multiple testing correction procedure (by default, the Benjamini-Hochberg method) to produce a discovery set that controls some notion of aggregate type-I error (by default, the false discovery rate). See Section 2.9 for more details on multiple testing. The more pairs that are tested, the more stringest this multiplicity correction is. Therefore, including a large number of uninteresting or “null” pairs (i.e., pairs for which there is no relationship between the target and response) in the discovery set causes the power of the multiple testing correction procedure to decrease, resulting in fewer discoveries. If possible, it is good to restrict one’s attention to pairs that are promising or scientifically interesting a priori.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Set analysis parameters</span>"
    ]
  },
  {
    "objectID": "set-analysis-parameters.html#sec-set_analysis_parameters_side",
    "href": "set-analysis-parameters.html#sec-set_analysis_parameters_side",
    "title": "2  Set analysis parameters",
    "section": "\n2.3 Side",
    "text": "2.3 Side\nsceptre can run left-tailed, right-tailed, and two-tailed tests of association. Left-tailed tests assess a decrease in expression, right-tailed tests assess an increase in expression, and two-tailed tests assess an increase or decrease in expression. The parameter side controls the sidedness of the test and can take values \"left\", \"right\", or \"both\". (\"both\" indicates a two-tailed test.) Two-tailed tests typically are the best choice for trans analyses, as the direction of trans relationships generally is uncertain. For cis analyses, on the other hand, the sidedness of the test should be chosen on the basis of the type of genomic element targeted and the CRISPR perturbation modality. The following table summarizes whether a left- or right-tailed test is appropriate for a cis analysis as a function of these variables.\n\nRecommended sidedness of the test as a function of target element and CRISPR modality for cis analyses.\n\n\n\n\n\n\n\nTarget element\nCRISPR modality\nTesting for\nSidedness\n\n\n\nEnhancer\nCRISPRi or CRISPRko\nDecrease in expression\nLeft\n\n\nEnhancer\nCRISPRa\nIncrease in expression\nRight\n\n\nSilencer\nCRISPRi or CRISPRko\nIncrease in expression\nRight\n\n\nSilencer\nCRISPRa\nDecrease in expression\nLeft",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Set analysis parameters</span>"
    ]
  },
  {
    "objectID": "set-analysis-parameters.html#sec-grna_integration_strategy",
    "href": "set-analysis-parameters.html#sec-grna_integration_strategy",
    "title": "2  Set analysis parameters",
    "section": "\n2.4 gRNA integration strategy",
    "text": "2.4 gRNA integration strategy\nMultiple gRNAs typically are designed to target a given genomic element. The parameter grna_integration_strategy controls if and how gRNAs that target the same genomic element are combined. In most cases, users wish to test whether perturbation of a target impacts the responses to which the target is paired. In these cases, users need to choose a strategy for integrating information across gRNAs that share a given target. If users expect that gRNAs sharing a target will have broadly similar effects, then users should choose grna_integration_strategy = \"union\". If, on the other hand, users expect that gRNAs sharing a target will have substantially different effects (e.g. due to variable gRNA effectiveness), then users should choose grna_integration_strategy = \"bonferroni\". In some cases users may wish to test each individual gRNA against the responses to which its target is paired. For example, users may wish to assess the variability in the effects of different gRNAs with the same target. In these cases, users should choose grna_integration_strategy = \"singleton\".\n\n\n\n\nSchematic of the choices for gRNA integration strategy.\n\n\n\nThe default option for grna_integration_strategy is \"union\". This strategy constructs a “grouped gRNA” by combining all gRNAs that target a given genomic element via a union operation; this “grouped gRNA” is then tested for association against the responses to which the element is paired. We illustrate this grouping strategy using an example. Suppose that “gRNA 1” and “gRNA 2” target the same genomic element. Suppose that “gRNA 1” is present in the cells indexed 3, 6, 9 and that “gRNA 2” is present in the cells indexed 1, 4, 6, 10. The “grouped gRNA” formed combining “gRNA 1” and “gRNA 2” via the union operation is defined to be present in the cells indexed 1, 3, 4, 6, 9, 10. (See schematic below.) This “grouped gRNA” is then tested against responses as if it were a single gRNA.\n\n\n\n\nSchematic of the \"union\" gRNA grouping strategy. Blue (resp., white) squares indicate cells in which the gRNA is present (resp., absent).\n\n\n\nUsers who wish to run both a singleton analysis and a grouped analysis should consult Section B.7.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Set analysis parameters</span>"
    ]
  },
  {
    "objectID": "set-analysis-parameters.html#sec-set-analysis-parameters_control_group",
    "href": "set-analysis-parameters.html#sec-set-analysis-parameters_control_group",
    "title": "2  Set analysis parameters",
    "section": "\n2.5 Control group",
    "text": "2.5 Control group\nThe primary goal of sceptre is to test for association between a given gRNA target and response. control_group is a parameter related to the set of cells used to carry out this test of association. Suppose for simplicity that we are carrying out a singleton analysis, i.e. suppose that we are testing for association between an individual targeting gRNA and a response. We define the “treatment group” as the set of cells that contain the given targeting gRNA, and we define the “control group” as the set of cells against which the treatment group is compared to conduct the association test. There are two choices for the control group: the “complement set” and the “non-targeting (NT) cells.” The complement set consists of the cells that do not contain the given targeting gRNA; the NT cells, by contrast, consist of the cells that contain a non-targeting gRNA. (See schematic below.) sceptre tests for association between the given targeting gRNA and the response by testing for differential expression of the response across the treatment group and the control group. Users can select the control group to use by passing either \"complement\" or \"nt_cells\" to control_group.\n\n\n\n\nA schematic illustrating the difference between the “complement set” and “NT cells” control groups. The single-cell CRISPR screen experiment produces a pool of cells containing both targeting and non-targeting gRNAs (top). Suppose that we seek to test for association between a given targeting gRNA (e.g., gRNA \\(T_2\\)) and a given response. We first divide the cells into two groups: the treatment group (i.e., the cells containing gRNA \\(T_2\\)) and the control group. The control group either can consist of the cells not containing gRNA \\(T_2\\) (the “complement set”) or the cells containing a non-targeting gRNA (the “NT cells”). sceptre tests for differential expression of the given response across the treatment and control groups, yielding a p-value for the test of association between the given targeting gRNA and the given response.\n\n\n\nThe choice of the control group should be made on the basis of the MOI of the dataset and the type of genomic element being targeted. In high-MOI screens each cell contains multiple gRNAs. Very few (if any) cells contain exclusively NT gRNAs, and so the complement set is the only choice for the control group. In low-MOI screens there is more flexibility. The default choice for the control group is the NT cells, as we seek to compare the effect of the targeting gRNA to that of a “null” gRNA rather than to the average of the effects of all other gRNAs introduced in the pooled screen. However, the complement set is a reasonable choice for low-MOI enhancer-targeting screens, as gRNAs in enhancer-targeting screens tend to exert small and local effects, rendering the average effect over gRNAs in the complement set similar to that of a “null” gRNA. Thus, we recommend trying both the complement set and the NT cells for the control group in low-MOI enhancer-targeting screens and selecting between these options on the basis of their performance on the negative control and positive control data. The decision tree below summarizes the control group that we recommend selecting as a function of MOI and genomic element targeted.\n\n\n\n\nA decision tree summarizing the control group to select as a function of the MOI of the data and the genomic element targeted. The only option in high-MOI is the complement set. In low-MOI the NT cells are the default option; however, we recommend trying both the complement set and the NT cells for low-MOI enhancer-targeting screens.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Set analysis parameters</span>"
    ]
  },
  {
    "objectID": "set-analysis-parameters.html#sec-set_analysis_parameters_formula",
    "href": "set-analysis-parameters.html#sec-set_analysis_parameters_formula",
    "title": "2  Set analysis parameters",
    "section": "\n2.6 Formula",
    "text": "2.6 Formula\nThe parameter formula_object specifies how sceptre is to adjust for the cell-specific covariates. formula_object is optional; if not provided, set_analysis_parameters() constructs a default formula_object. The default formula_object is formed by summing over all covariates and log-transforming the count-based covariates. For example, the high-MOI CRISPRi data contain the cell-specific covariates response_n_nonzero, response_n_umis, grna_n_nonzero, grna_n_umis, response_p_mito, and batch. The first four of these covariates are count-based. Thus, the default formula object for this dataset is as follows:\n\nformula(~ log(response_n_nonzero) + log(response_n_umis) +\n          log(grna_n_nonzero) + log(grna_n_umis) + response_p_mito + batch)\n\nSimilarly, the low-MOI CRISPRko data contain the covariates response_n_nonzero, response_n_umis, grna_n_nonzero, grna_n_umis, response_p_mito, and bio_rep. The default formula object for the CRISPRko dataset is as follows:\n\nformula(~ log(response_n_nonzero) + log(response_n_umis) +\n          response_p_mito + bio_rep)\n\n(The covariates grna_n_nonzero and grna_n_umis by default are not included in the formula object, as grna_n_nonzero and grna_n_umis typically do not contain substantial information in low MOI after quality control.)\nUsers can specify a custom formula by passing a formula object to the argument formula_object in set_analysis_parameters(). User-specified formulas should be defined in terms of the cell-specific covariates, which can be viewed by evaluating the sceptre_object in the console.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Set analysis parameters</span>"
    ]
  },
  {
    "objectID": "set-analysis-parameters.html#sec-set_analysis_parameters_resampling_mech",
    "href": "set-analysis-parameters.html#sec-set_analysis_parameters_resampling_mech",
    "title": "2  Set analysis parameters",
    "section": "\n2.7 Resampling mechanism",
    "text": "2.7 Resampling mechanism\nThe parameter resampling_mechanism controls the inferential procedure that sceptre uses to compute a p-value for a target-response pair. Suppose for simplicity that we are carrying out a singleton gRNA analysis. There are three pieces of information relevant to testing for association between a given gRNA and response: (1) the vector of UMI counts of the response; (2) the “gRNA indicator vector,” where a given entry of the vector is set to “1” if the corresponding cell is part of the treatment group (i.e., it contains the gRNA) and “0” if it is part of the control group; and (3) the matrix of cell-specific covariates. First, sceptre regresses the response vector onto the gRNA indicator vector and covariate matrix via a negative binomial (NB) GLM. sceptre computes the z-score \\(z_\\textrm{obs}\\) corresponding to a test of the null hypothesis that the coefficient corresponding to the gRNA indicator vector in the fitted GLM is zero. Next, sceptre resamples the gRNA indicator vector B times, where B is some large integer (e.g., B = 5000). (We discuss exactly how the gRNA indicator vector is resampled below.) Finally, for each of the resampled gRNA indicator vectors, sceptre recomputes the z-score, producing B “null” z-scores \\(\\tilde z_1, \\dots, \\tilde z_B\\). The observed z-score \\(z_\\textrm{obs}\\) is compared to the null z-scores \\(\\tilde z_1, \\dots, \\tilde z_B\\) to compute a p-value.\n\n\n\n\n\n\n\n\nsceptre provides two procedures for resampling the gRNA indicator vector: permutations and conditional resampling (also known as the conditional randomization test). The permutation procedure involves randomly permuting the gRNA indicator vector B times. The conditional resampling procedure is slightly more complex (Barry et al. 2021). Briefly, the gRNA indicator vector is regressed onto the covariate matrix via logistic regression, yielding an estimate for the probability that each cell contains the gRNA as a function of the covariates. B synthetic gRNA indicator vectors are then sampled according to these estimated probabilities. The resampling mechanism can be specified by passing either permutations or crt (for conditional resampling) to the argument resampling_mechanism in set_analysis_parameters().\nPermutations and conditional resampling offer distinct advantages and disadvantages, although the differences can be subtle. The permutation approach is faster and slightly better at handling sparsity, while the conditional resampling approach is slightly better at handling confounding due to cell-specific covariates (see table below). In practice the two approaches often produce similar results; we recommend that users try both, provided that they have the bandwidth and compute to do so. The permutation (resp., conditional resampling) procedure is the default option in low-MOI (resp., high-MOI). (Note that both options are available in both MOI settings.)\n\n\n\n\n\n\n\nResampling procedure\nAdvantages\nDisadvantages\n\n\n\nPermutations\n\nFaster\nBetter at handling sparsity\n\n\nWorse at handling confounding\n\n\n\nConditional resampling\n\nBetter at handling confounding\n\n\nSlower\nWorse at handling sparsity\n\n\n\n\nResampling forms the foundation of statistical inference within the sceptre framework. In fact, “sceptre” is a loose acronym for “single cell perturbation analysis via resampling.” The resampling machinery of sceptre is reasonably fast due to several algorithmic advances, including the technique of resampling score statistics, a novel sparsity-exploiting algorithm for computing GLM score tests, and algorithms for sharing compute across permutation tests.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Set analysis parameters</span>"
    ]
  },
  {
    "objectID": "set-analysis-parameters.html#sec-set_analysis_parameters_parametric_curve",
    "href": "set-analysis-parameters.html#sec-set_analysis_parameters_parametric_curve",
    "title": "2  Set analysis parameters",
    "section": "\n2.8 Resampling approximation",
    "text": "2.8 Resampling approximation\nAs described above, for a given gRNA-response pair, sceptre computes an “observed” z-score \\(z_\\textrm{obs}\\) and a set of “null” z-scores \\(\\tilde z_1, \\dots, \\tilde z_B\\) (regardless of whether resampling_mechanism is set to \"permutations\" or \"crt\"). By default, sceptre fits a parametric density (specifically, a skew-normal density) to the distribution of null z-scores and then computes a p-value by evaluating the tail probability of the fitted density at the observed z-score \\(z_\\textrm{obs}\\) (see figure below). This default behavior corresponds to setting resampling_approximation to \"skew_normal\". The parametric density functionality can be deactivated by setting resampling_approximation to \"no_approximation\" in set_analysis_parameters(), in which case a p-value is computed by directly comparing the observed z-score to the null z-scores.\n\n\n\n\n\n\n\n\nWhen resampling_approximation is set to \"no_approximation\", sceptre must compute a greater number of “null” test statistics to maintain p-value precision. Thus, setting resampling_approximation to \"no_approximation\" increases compute (in some cases substantially). We recommend setting resampling_approximation to \"no_approximation\" when the negative control p-values exhibit miscalibration (see Section 5.4) and the number of pairs to be tested is less than ~10,000.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Set analysis parameters</span>"
    ]
  },
  {
    "objectID": "set-analysis-parameters.html#sec-multiple_testing",
    "href": "set-analysis-parameters.html#sec-multiple_testing",
    "title": "2  Set analysis parameters",
    "section": "\n2.9 Multiple testing method and multiple testing \\(\\alpha\\)\n",
    "text": "2.9 Multiple testing method and multiple testing \\(\\alpha\\)\n\nAfter sceptre is deployed to analyze the discovery pairs and negative control pairs, the resulting p-values are subjected to a multiplicity adjustment. The adjusted p-values are thresholded to call each pair as “significant” or “not significant.” The parameter multiple_testing_method controls the multiple testing method that is used to adjust the p-values. The default option is Benjamini-Hochberg (\"BH\"); other available methods can be viewed via a call to p.adjust.methods.\nThe parameter multiple_testing_alpha (default value 0.1) controls the level of the multiple testing procedure. If multiple_testing_method is set to a method that controls that false discovery rate (e.g., \"BH\" or \"BY\"), then multiple_testing_alpha is the nominal false discovery rate. If, on the other hand, multiple_testing_method is set to a method that controls the family-wise error rate (e.g., \"bonferroni\" or \"holm\"), then multiple_testing_alpha is the nominal family-wise error rate.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Set analysis parameters</span>"
    ]
  },
  {
    "objectID": "set-analysis-parameters.html#setting-the-analysis-parameters",
    "href": "set-analysis-parameters.html#setting-the-analysis-parameters",
    "title": "2  Set analysis parameters",
    "section": "\n2.10 Setting the analysis parameters",
    "text": "2.10 Setting the analysis parameters\nWe set the analysis parameters by calling set_analysis_parameters() on the sceptre_objects, passing discovery_pairs and positive_control_pairs (and, on the high-MOI CRISPRi data, side). We allow all other arguments to take default values.\n\n# high-MOI CRISPRi data\nsceptre_object_highmoi &lt;- set_analysis_parameters(\n  sceptre_object = sceptre_object_highmoi,\n  discovery_pairs = discovery_pairs_highmoi,\n  positive_control_pairs = positive_control_pairs_highmoi,\n  side = \"left\"\n)\n\n# low-MOI CRISPRko data\nsceptre_object_lowmoi &lt;- set_analysis_parameters(\n  sceptre_object = sceptre_object_lowmoi,\n  discovery_pairs = discovery_pairs_lowmoi,\n  positive_control_pairs = positive_control_pairs_lowmoi\n)\n\nWe can call print() on the resulting sceptre_object, which prints to the console a summary tracking the status of the analysis. Notice that the “Analysis parameters” field of the output contains information about the analysis parameters that we have selected (or that have been set by default).\n\nprint(sceptre_object_highmoi)\n\nAn object of class sceptre_object.\n\nAttributes of the data:\n    • 45919 cells\n    • 526 responses\n    • High multiplicity-of-infection \n    • 70 targeting gRNAs (distributed across 35 targets) \n    • 25 non-targeting gRNAs \n    • 6 covariates (batch, grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito)\n\nAnalysis status:\n    ✓ import_data()\n    ✓ set_analysis_parameters()\n    ✗ assign_grnas()\n    ✗ run_qc()\n    ✗ run_calibration_check()\n    ✗ run_power_check()\n    ✗ run_discovery_analysis()\n\nAnalysis parameters: \n    • Discovery pairs: data frame with 610 pairs\n    • Positive control pairs: data frame with 10 pairs\n    • Sidedness of test: left\n    • Resampling mechanism: conditional resampling\n    • gRNA integration strategy: union\n    • Resampling approximation: skew normal\n    • Multiple testing adjustment: BH at level 0.1\n    • N nonzero treatment cells threshold: not specified\n    • N nonzero control cells threshold: not specified\n    • Formula object: log(response_n_nonzero) + log(response_n_umis) + log(grna_n_nonzero) + log(grna_n_umis) + batch\n\n\n\n\n\n\nBarry, Timothy, Xuran Wang, John A. Morris, Kathryn Roeder, and Eugene Katsevich. 2021. “SCEPTRE improves calibration and sensitivity in single-cell CRISPR screen analysis.” Genome Biology 22 (1): 1–19.\n\n\nPapalexi, Efthymia, Eleni Mimitou, Andrew W. Butler, Samantha Foster, Bernadette Bracken, William M. Mauck III, Hans-Hermann Wessels, Bertrand Z. Yeung, Peter Smibert, and Rahul Satija. 2021. “Characterizing the molecular regulation of inhibitory immune checkpoints with multi-modal single-cell screens.” Nature Genetics 53 (3): 322–31.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Set analysis parameters</span>"
    ]
  },
  {
    "objectID": "assign-grnas.html",
    "href": "assign-grnas.html",
    "title": "3  Assign gRNAs",
    "section": "",
    "text": "3.1 Initialize the CRISPRi and CRISPRko sceptre_objects\nWe use the high-MOI CRISPRi and low-MOI CRISPRko data as running examples. We call import_data() and set_analysis_parameters() on the low-MOI CRISPRko data to initialize a sceptre_object called sceptre_object_lowmoi.\n# low-MOI CRISPRko data setup\n# 1. import data\ndata(lowmoi_example_data)\nsceptre_object_lowmoi &lt;- import_data(\n  response_matrix = lowmoi_example_data$response_matrix,\n  grna_matrix = lowmoi_example_data$grna_matrix,\n  extra_covariates = lowmoi_example_data$extra_covariates,\n  grna_target_data_frame = lowmoi_example_data$grna_target_data_frame,\n  moi = \"low\"\n)\n\n# 2. set analysis parameters\npositive_control_pairs &lt;- construct_positive_control_pairs(sceptre_object_lowmoi)\ndiscovery_pairs &lt;- construct_trans_pairs(\n  sceptre_object = sceptre_object_lowmoi,\n  positive_control_pairs = positive_control_pairs,\n  pairs_to_exclude = \"pc_pairs\"\n)\nsceptre_object_lowmoi &lt;- set_analysis_parameters(\n  sceptre_object = sceptre_object_lowmoi,\n  discovery_pairs = discovery_pairs,\n  positive_control_pairs = positive_control_pairs\n)\nWe do the same for the high-MOI CRISPRi data, creating sceptre_object_highmoi.\n# high-MOI CRISPRi setup\n# 1. import data\ndata(highmoi_example_data); data(grna_target_data_frame_highmoi)\nsceptre_object_highmoi &lt;- import_data(\n  response_matrix = highmoi_example_data$response_matrix,\n  grna_matrix = highmoi_example_data$grna_matrix,\n  grna_target_data_frame = grna_target_data_frame_highmoi,\n  moi = \"high\",\n  extra_covariates = highmoi_example_data$extra_covariates,\n  response_names = highmoi_example_data$gene_names\n)\n# 2. set analysis parameters\npositive_control_pairs &lt;- construct_positive_control_pairs(sceptre_object_highmoi)\ndiscovery_pairs &lt;- construct_cis_pairs(sceptre_object_highmoi,\n  positive_control_pairs = positive_control_pairs,\n  distance_threshold = 5e6\n)\nsceptre_object_highmoi &lt;- set_analysis_parameters(\n  sceptre_object = sceptre_object_highmoi,\n  discovery_pairs = discovery_pairs,\n  positive_control_pairs = positive_control_pairs,\n  side = \"left\"\n)\nWe are now ready to carry out the gRNA assignment step on both datasets.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Assign gRNAs</span>"
    ]
  },
  {
    "objectID": "assign-grnas.html#visualize-the-grna-count-distributions",
    "href": "assign-grnas.html#visualize-the-grna-count-distributions",
    "title": "3  Assign gRNAs",
    "section": "\n3.2 Visualize the gRNA count distributions",
    "text": "3.2 Visualize the gRNA count distributions\nA helpful first step in assigning gRNAs to cells is to visualize the gRNA UMI count distributions. As discussed in Section 3 of The whole game, we can use the function plot_grna_count_distributions() to plot the empirical UMI count distribution of one or more gRNAs. plot_grna_count_distributions() takes several arguments: sceptre_object (required), n_grnas_to_plot (optional), grnas_to_plot (optional), and threshold (optional). n_grnas_to_plot is an integer specifying the number of randomly selected gRNAs to plot. grnas_to_plot is a character vector specifying (by name) one or more specific gRNAs to plot. Finally, threshold is an integer specifying the location at which to draw a dotted vertical line. We call plot_grna_count_distributions() on the low-MOI CRISPRko data, plotting nine random gRNAs.\n\nplot_grna_count_distributions(\n  sceptre_object = sceptre_object_lowmoi,\n  n_grnas_to_plot = 9\n)\n\n\n\n\n\nHistograms of the gRNA count distributions for the low-MOI CRISPRko data.\n\n\n\nWe see that the gRNA count distributions exhibit generally bimodal behavior. As discussed in The whole game, this bimodality is due to the phenomenon of background contamination: gRNA reads sometimes map to cells that do not contain the corresponding gRNA. sceptre provides three methods for assigning gRNAs to cells, all of which account for background contamination.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Assign gRNAs</span>"
    ]
  },
  {
    "objectID": "assign-grnas.html#assign-grnas-to-cells",
    "href": "assign-grnas.html#assign-grnas-to-cells",
    "title": "3  Assign gRNAs",
    "section": "\n3.3 Assign gRNAs to cells",
    "text": "3.3 Assign gRNAs to cells\nWe assign gRNAs to cells to cells by calling the function assign_grnas(). assign_grnas() takes the arguments sceptre_object (required), method (optional), print_progress (optional), and parallel (optional). method is the gRNA assignment method and should be set to \"mixture\", \"maximum\", or \"thresholding\". print_progress (default TRUE) and parallel (default FALSE) are logical values specifying whether to print progress updates and run the function in parallel, respectively. Below, we describe the three gRNA assignment strategies in detail.\n\n3.3.1 Mixture method\nThe first gRNA assignment strategy is the “mixture” method, which involves assigning gRNAs to cells using a mixture model (Barry, Roeder, and Katsevich 2022). The mixture method is the default method for high-MOI screens and is an optional method for low-MOI screens. The method works as follows. First, we fit a latent variable Poisson GLM to the data, regressing the gRNA UMI count vector onto the (latent) gRNA indicator vector and cell-specific covariate matrix. (A given entry of the gRNA indicator vector is defined to be “1” if the gRNA is present in the corresponding cell and “0” otherwise.) We fit the latent variable Poisson GLM using a novel variant of the EM algorithm. The fitted model yields the probability that each cell contains the gRNA; we threshold these probabilities to assign the gRNA to cells. An advantage of the GLM-based mixture modeling approach is that it accounts for cell-specific covariates, such as sequencing depth and batch. For example, cells that are sequenced deeply (and thus have a large value for grna_n_umis) generally exhibit higher levels of ambient background contamination; sceptre controls for heterogeneity across cells due to sequencing depth and other factors.\nWe use the mixture assignment method to assign gRNAs to cells on both the high-MOI CRISPRi data and low-MOI CRISPRko data, saving the resulting outputs as sceptre_object_lowmoi_mixture and sceptre_object_highmoi_mixture, respectively.\n\n# high-MOI CRISPRi data\nsceptre_object_highmoi_mixture &lt;- assign_grnas(\n  sceptre_object = sceptre_object_highmoi,\n  method = \"mixture\", parallel = TRUE\n)\n\n\n# low-MOI CRISPRko data\nsceptre_object_lowmoi_mixture &lt;- assign_grnas(\n  sceptre_object = sceptre_object_lowmoi,\n  method = \"mixture\", parallel = TRUE\n)\n\nWe can pass optional, method-specific parameters to assign_grnas() to control precisely how the assignment method is deployed. The relevant parameters for the mixture method include formula_object, n_em_rep, n_nonzero_cells_cutoff, backup_threshold, and probability_threshold. formula_object is a formula object that specifies how sceptre is to adjust for the cell-specific covariates in the latent-variable gRNA count model. The default formula object is constructed by summing over all covariates and then log-transforming the count-based covariates. It is sometimes helpful to exclude covariates from the formula object so as to improve the speed of the gRNA assignment step. For example, we define a reduced formula object formula_object_reduced that includes only grna_n_nonzero and grna_n_umis, the two most important covariates for assigning gRNAs to cells.\n\nformula_object_reduced &lt;- formula(~ log(grna_n_nonzero) + log(grna_n_umis))\n\nn_em_rep is the number of times to run the EM algorithm using random starting estimates (default: n_em_rep = 5). Setting n_em_rep to a larger integer can improve the accuracy of the gRNA assignments at the cost of increasing compute. n_nonzero_cells_cutoff is the minimum number of cells that must exhibit nonzero expression of the gRNA to attempt fitting a mixture model to the gRNA count distribution (default: n_nonzero_cells_cutoff = 10). If the gRNA is expressed in fewer than n_nonzero_cells_cutoff cells, the gRNA instead is assigned to cells via the thresholding method, where the threshold used is backup_threshold (default: backup_threshold = 5). (See Section 3.3.3 for a detailed discussion of the thresholding method.) Finally, cells whose estimated probability of having received a gRNA exceeds probability_threshold are called as containing the gRNA (default: probability_threshold = 0.8). In practice probability_threshold typically does not impact the results considerably, but it is helpful to vary this parameter to ensure stability of the gRNA assignments to this choice.\nTo illustrate use of these method-specific parameters, we again call assign_grnas() to assign gRNAs to cells on the high-MOI CRISPRi data, this time setting formula_object to formula_object_reduced.\n\nsceptre_object_highmoi_mixture &lt;- assign_grnas(\n  sceptre_object = sceptre_object_highmoi,\n  formula_object = formula_object_reduced,\n  parallel = TRUE\n)\n\n\n3.3.2 Maximum method\nThe second gRNA assignment strategy is the “maximum” method. The maximum method is the default assignment method for low-MOI screens and is not available as an option for high-MOI screens. The maximum method assigns the gRNA that accounts for the greatest number of UMIs in a given cell to that cell. We apply the maximum method to the low-MOI CRISPRko data below.\n\nsceptre_object_lowmoi_maximum &lt;- assign_grnas(\n  sceptre_object = sceptre_object_lowmoi, \n  method = \"maximum\"\n)\n\nAn advantage of the maximum method relative to the mixture method is that the former is model-free (and thus robust to misspecification of the Poisson GLM). However, when using the maximum method, one must take care to identify cells that contain zero gRNAs or multiple gRNAs (so that these cells can be removed as part of cellwise quality control). In this context the maximum method allows for two optional arguments: umi_fraction_threshold (default: umi_fraction_threshold = 0.8) and min_grna_n_umis_threshold (default: min_grna_n_umis_threshold = 5). Cells for which the maximally expressed gRNA constitutes fewer than umi_fraction_threshold of the UMIs in that cell are flagged as containing multiple gRNAs. For example, if the maximally expressed gRNA in a given cell makes up 0.64 (or 64\\(\\%\\)) of the UMIs in that cell, and if umi_fraction_threshold = 0.8, then that cell is flagged as containing multiple gRNAs. Next, cells for which the total gRNA UMI count (i.e., n_grna_umis) is less than min_grna_n_umis_threshold are flagged as containing zero gRNAs. Cells containing multiple gRNAs or zero gRNAs are removed as part of low-MOI quality control step, as discussed in Chapter 4.\n\n3.3.3 Thresholding method\nThe third method for assigning gRNAs to cells is the \"thresholding\" method; this method is available in both low- and high-MOI settings. The thresholding method assigns a gRNA to a cell if the UMI count of the gRNA in the cell is greater than or equal to some integer threshold (by default 5). We apply the \"thresholding\" method to both CRISPRi and CRISPRko datasets as follows.\n\n# high-MOI CRISPRi data\nsceptre_object_highmoi_thresholding &lt;- assign_grnas(\n  sceptre_object = sceptre_object_highmoi,\n  method = \"thresholding\"\n)\n# low-MOI CRISPRko data\nsceptre_object_lowmoi_thresholding &lt;- assign_grnas(\n  sceptre_object = sceptre_object_lowmoi,\n  method = \"thresholding\"\n)\n\nThe thresholding method allows for one optional argument, namely the integer threshold threshold. One can set threshold to 1 to assign any gRNA expressed in a given cell to that cell. We assign gRNAs to cells on the CRISPRi data using a threshold of 1 below.\n\nsceptre_object_highmoi_thresholding &lt;- assign_grnas(\n  sceptre_object = sceptre_object_highmoi,\n  method = \"thresholding\",\n  threshold = 1\n)\n\nNote that setting threshold to 1 causes background contamination to be ignored.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Assign gRNAs</span>"
    ]
  },
  {
    "objectID": "assign-grnas.html#plotting-the-grna-assignments",
    "href": "assign-grnas.html#plotting-the-grna-assignments",
    "title": "3  Assign gRNAs",
    "section": "\n3.4 Plotting the gRNA assignments",
    "text": "3.4 Plotting the gRNA assignments\nWe can call plot() on the sceptre_object to render a plot summarizing the outcome of the gRNA-to-cell assignment step. plot() takes the arguments sceptre_object (required) n_grnas_to_plot (optional), grnas_to_plot (optional), and return_indiv_plots (optional). n_grnas_to_plot is the number of (randomly selected) gRNAs to plot; grnas_to_plot is a vector of names of one or more gRNAs to plot; and return_indiv_plots is a logical value indicating whether to return the constituent panels of the plot individually (TRUE) or combined into a single figure (FALSE; default).\nWe visualize the outcome of the gRNA-to-cell assignment step on the low-MOI CRISPRko data based on the maximum assignment strategy. We specifically plot the gRNAs “IFNGR2g2”, “STAT1g2”, and “STAT5Ag4”. (These gRNAs were selected arbitrarily for the purpose of illustrating the grnas_to_plot argument.)\n\ngrnas_to_plot &lt;- c(\"IFNGR2g2\", \"STAT1g2\", \"STAT5Ag4\")\nplot(sceptre_object_lowmoi_maximum, grnas_to_plot = grnas_to_plot)\n\n\n\n\n\nMaximum assignment method on the low-MOI CRISPRko data.\n\n\n\nSection 3 of The whole game describes how to interpret this plot. Briefly, the top panel displays the gRNA-to-cell assignments of several individual gRNAS, and the bottom left panel shows the number of cells per gRNA. Typically, the bottom right panel plots the number of gRNAs per cell, but the bottom right panel is not meaningful under the maximum assignment strategy and is thus omitted.\nIt is informative to compare the output of multiple gRNA assignment methods and check for consistency across methods. To this end we render a visualization of the gRNA-to-cell assignments on the same dataset, this time based on the mixture method.\n\nplot(sceptre_object_lowmoi_mixture, grnas_to_plot = grnas_to_plot)\n\n\n\n\n\nMixture assignment method on the low-MOI CRISPRko data.\n\n\n\nEncouragingly, the gRNA assignments appear to be highly concordant across the maximum and mixture methods. Suppose that we ultimately choose to use the mixture strategy to assign gRNAs to cells on the low-MOI CRISPRko dataset. We update sceptre_object_lowmoi as follows.\n\nsceptre_object_lowmoi &lt;- sceptre_object_lowmoi_mixture",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Assign gRNAs</span>"
    ]
  },
  {
    "objectID": "assign-grnas.html#returning-and-printing-the-grna-assignments",
    "href": "assign-grnas.html#returning-and-printing-the-grna-assignments",
    "title": "3  Assign gRNAs",
    "section": "\n3.5 Returning and printing the gRNA assignments",
    "text": "3.5 Returning and printing the gRNA assignments\nWe can obtain the gRNA-to-cell assignments by calling get_grna_assignments() on the sceptre_object.\n\ngrna_assignment_matrix &lt;- get_grna_assignments(\n  sceptre_object = sceptre_object_lowmoi\n)\n\ngrna_assignment_matrix is a sparse, logical matrix of gRNA assignments; gRNA IDs are in the rows and cells are in the columns. A given entry of the matrix is set to TRUE if the given gRNA was assigned to the given cell (and FALSE otherwise). We can determine the cells to which a given gRNA was assigned by indexing grna_assignment_matrix by row; conversely, we can determine the gRNAs that were assigned to a given cell by indexing grna_assignment_matrix by column. By default, get_grna_assignments() returns the gRNA-to-cell assignment matrix corresponding to the original gRNA expression matrix. We can set apply_cellwise_qc to TRUE to instead return the gRNA-to-cell assignment matrix corresponding to the gRNA expression matrix that has had cellwise quality control called on it. (The function run_qc() first must be called on the sceptre_object for the latter option to work.)\nFinally, we can call print() on sceptre_object_lowmoi to print a summary tracking the progress of the analysis. The field “gRNA-to-cell assignment information” presents information about the gRNA assignment step, including the selected assignment method, the mean number of cells per gRNA, and the mean number of gRNAs per cell.\n\nprint(sceptre_object_lowmoi)\n\nAn object of class sceptre_object.\n\nAttributes of the data:\n    • 20729 cells\n    • 299 responses\n    • Low multiplicity-of-infection \n    • 101 targeting gRNAs (distributed across 26 targets) \n    • 9 non-targeting gRNAs \n    • 6 covariates (bio_rep, grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito)\n\nAnalysis status:\n    ✓ import_data()\n    ✓ set_analysis_parameters()\n    ✓ assign_grnas()\n    ✗ run_qc()\n    ✗ run_calibration_check()\n    ✗ run_power_check()\n    ✗ run_discovery_analysis()\n\nAnalysis parameters: \n    • Discovery pairs: data frame with 7765 pairs\n    • Positive control pairs: data frame with 9 pairs\n    • Sidedness of test: both\n    • Control group: non-targeting cells\n    • Resampling mechanism: permutations\n    • gRNA integration strategy: union\n    • Resampling approximation: skew normal\n    • Multiple testing adjustment: BH at level 0.1\n    • N nonzero treatment cells threshold: not specified\n    • N nonzero control cells threshold: not specified\n    • Formula object: log(response_n_nonzero) + log(response_n_umis) + bio_rep\n\ngRNA-to-cell assignment information:\n    • Assignment method: mixture\n    • Mean N cells per gRNA: 205.07\n    • Mean N gRNAs per cell (MOI): 1.09 \n    • gRNA assignment formula object: log(response_n_nonzero) + log(response_n_umis) + log(grna_n_nonzero) + log(grna_n_umis) + bio_rep\n\n\n\n\n\n\nBarry, Timothy, Kathryn Roeder, and Eugene Katsevich. 2022. “Exponential family measurement error models for single-cell CRISPR screens.” arXiv.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Assign gRNAs</span>"
    ]
  },
  {
    "objectID": "run-qc.html",
    "href": "run-qc.html",
    "title": "4  Run quality control",
    "section": "",
    "text": "4.1 Plot the cell-specific covariates\nA helpful initial step in applying QC is to visualize the distribution of the cell-specific covariates. To this end we call the function plot_covariates(), which creates a histogram of the covariates response_n_nonzero, response_n_umis, and (if applicable) response_p_mito. Cellwise QC removes cells that lie in the extreme right tail of the response_p_mito distribution or that lie in the extreme left or right tail of the response_n_nonzero or response_n_umis distribution. To help guide the selection of QC thresholds, plot_covariates() plots candidate QC thresholds as vertical lines on the histograms. The optional arguments response_n_nonzero_range, response_n_umis_range, and p_mito_threshold control the location of these candidate QC thresholds. response_n_nonzero_range (resp., response_n_umis_range) is a length-two vector of quantiles (default: c(0.01, 0.99)) indicating the location at which to draw candidate QC thresholds on the response_n_nonzero (resp., response_n_umis) histogram. Next, p_mito_threshold is a single numeric value in the interval [0,1] specifying the location at which to draw a candidate QC threshold on the response_p_mito plot. We call plot_covariates() on the high-MOI CRISPRi sceptre_object (i.e., sceptre_object_highmoi), setting p_mito_threshold to 0.075.\nplot_covariates(sceptre_object_highmoi, p_mito_threshold = 0.075)\nPlot of covariates for high-MOI CRISPRi data.\nInspecting these plots (and tinkering with response_n_nonzero_range, response_n_umis_range, and p_mito_threshold as necessary) helps guide the selection of reasonable QC thresholds. In general it is good to clip long, asymmetric tails so as to remove outlier cells. The QC thresholds appear to be drawn at sensible locations on these data.\nWe also call plot_covariates() low-MOI CRISPRko data, again setting p_mito_threshold to 0.075.\nplot_covariates(sceptre_object_lowmoi, p_mito_threshold = 0.075)\nOutcome of QC on low-MOI CRISPRko data.\nThe low-MOI plot is broadly similar to its high-MOI counterpart. In particular, the QC thresholds appear to be drawn at sensible locations.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Run quality control</span>"
    ]
  },
  {
    "objectID": "run-qc.html#qc-parameters",
    "href": "run-qc.html#qc-parameters",
    "title": "4  Run quality control",
    "section": "\n4.2 QC parameters",
    "text": "4.2 QC parameters\nWe apply QC to a sceptre_object by calling the function run_qc(). run_qc() takes the arguments sceptre_object, response_n_umis_range, response_n_nonzero_range, p_mito_threshold, additional_cells_to_remove, n_nonzero_trt_thresh, and n_nonzero_cntrl_thresh. The only required argument among these is sceptre_object; the rest are set to reasonable defaults.\n\n4.2.1 Cellwise QC parameters\nThe parameters response_n_umis_range, response_n_nonzero_range, p_mito_threshold, and additional_cells_to_remove control cellwise QC. response_n_umis_range (resp., response_n_nonzero_range) is a length-two vector of quantiles (default c(0.01, 0.99)); cells whose response_n_umis (resp., response_n_nonzero) quantile falls outside this range are excluded. Next, p_mito_threshold is a number in the interval [0,1]; cells whose value for response_p_mito falls above this threshold likewise are excluded. (Note that p_mito_threshold is not a quantile but rather an absolute number). Finally, additional_cells_to_remove is an integer vector specifying the (1-based) indices of additional cells to remove. Cells flagged by additional_cells_to_remove are removed before applying any other cellwise QC filter.\n\n4.2.2 Pairwise QC parameters\nThe parameters n_nonzero_trt_thresh and n_nonzero_cntrl_thresh control pairwise QC (i.e., QC at the level of the target-response pair). Recall from Section 2.5 that for a given target-response pair, we divide the cells into treatment and control groups. The treatment group consists of the cells that contain a gRNA targeting the given target, and the control group consists of the cells against which the treatment cells are compared. (The control group can be either the complement set or NT cells; this choice is governed by the control_group parameter.) We define the “number of nonzero treatment cells” (resp., the “number of nonzero control cells”) as the number of cells in the treatment group (resp., control group) that contain nonzero expression of the response. (We sometimes use the shorthand n_nonzero_trt and n_nonzero_cntrl to refer to the number of nonzero treatment cells and control cells, respectively.) n_nonzero_trt and n_nonzero_cntrl are reasonable metrics of pair quality, with higher-quality pairs exhibiting larger values for n_nonzero_trt and n_nonzero_cntrl. The schematic below illustrates the definitions of n_nonzero_trt and n_nonzero_cntrl.\n\n\n\n\nDefinition of n_nonzero_trt and n_nonzero_cntrl. Each square represents a cell, and the integer within a square represents the UMI count of the response in the corresponding cell. Some cells belong to the treatment group (blue), and others belong to the control group (red). n_nonzero_trt (resp., n_nonzero_cntrl) is the number of cells in the treatment group (resp., control group) with nonzero expression of the response.\n\n\n\nsceptre tabulates n_nonzero_trt and n_nonzero_cntrl for each target-response pair. Pairs for which n_nonzero_trt is less than n_nonzero_trt_thresh or n_nonzero_cntrl is less than n_nonzero_cntrl_thresh are excluded. Both n_nonzero_trt_thresh and n_nonzero_cntrl_thresh are set to 7 by default. An important special case is to set n_nonzero_trt_thresh and n_nonzero_cntrl to 0; in this case all cells (regardless of expression level) are counted toward the n_nonzero_trt_thresh and n_nonzero_cntrl_thresh total.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Run quality control</span>"
    ]
  },
  {
    "objectID": "run-qc.html#run-qc",
    "href": "run-qc.html#run-qc",
    "title": "4  Run quality control",
    "section": "\n4.3 Run QC",
    "text": "4.3 Run QC\nWe call run_qc() on sceptre_object_highmoi and sceptre_object_lowmoi to run QC on the high-MOI CRISPRi and low-MOI CRISPRko data. In both cases we set p_mito_threshold to 0.075 but otherwise fall back on the default parameter values.\n\nsceptre_object_highmoi &lt;- run_qc(\n  sceptre_object = sceptre_object_highmoi,\n  p_mito_threshold = 0.075\n)\nsceptre_object_lowmoi &lt;- run_qc(\n  sceptre_object = sceptre_object_lowmoi,\n  p_mito_threshold = 0.075\n)\n\nWe can call the function plot() on the resulting sceptre_object to render a visualization of the outcome of the QC step. We call plot() on sceptre_object_lowmoi as an example.\n\nplot(sceptre_object_lowmoi)\n\n\n\n\n\nOutcome of applying cellwise (top) and pairwise (bottom) QC to the low-MOI CRISPRko data.\n\n\n\nWe described in Section 4 of The whole game how to interpret this figure. The top panel displays the percentage of cells removed (vertical axis) as a result of applying the different cellwise QC filters (horizontal axis). For example, over 20\\(\\%\\) of cells were removed because they contain zero or 2+ gRNAs, and about 2\\(\\%\\) of cells were removed because they exhibit extremely high or extremely values for response_n_nonzero. Note that the “zero or 2+ gRNAs” filter is applied only to low-MOI data. Next, the bottom panel plots the set of discovery target-response pairs, where the vertical (resp., horizontal) position of a given pair indicates its n_nonzero_cntrl (resp., n_nonzero_trt) value. Pairs with a sufficiently large value for n_nonzero_cntrl and n_nonzero_trt (colored in green) pass pairwise QC; all other pairs are removed.\nWe additionally can call plot_covariates() on a sceptre_object after run_qc() has been called on the sceptre_object. In this case the cellwise QC thresholds supplied to run_qc() are superimposed as vertical lines on the plot; the remaining arguments to plot_covariates() (e.g., response_n_umis_range, etc.) are ignored. Finally, we can call print() on sceptre_object_lowmoi to print a summary of the analysis status. The summary contains information about cellwise and pairwise QC; see the first entry under the “Attributes of the data” field and the second two entries under the “Analysis parameters” field.\n\nprint(sceptre_object_lowmoi)\n\nAn object of class sceptre_object.\n\nAttributes of the data:\n    • 20729 cells (15348 after cellwise QC)\n    • 299 responses\n    • Low multiplicity-of-infection \n    • 101 targeting gRNAs (distributed across 26 targets) \n    • 9 non-targeting gRNAs \n    • 6 covariates (bio_rep, grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito)\n\nAnalysis status:\n    ✓ import_data()\n    ✓ set_analysis_parameters()\n    ✓ assign_grnas()\n    ✓ run_qc()\n    ✗ run_calibration_check()\n    ✗ run_power_check()\n    ✗ run_discovery_analysis()\n\nAnalysis parameters: \n    • Discovery pairs: data frame with 7765 pairs (6205 after pairwise QC)\n    • Positive control pairs: data frame with 9 pairs (9 after pairwise QC)\n    • Sidedness of test: both\n    • Control group: non-targeting cells\n    • Resampling mechanism: permutations\n    • gRNA integration strategy: union\n    • Resampling approximation: skew normal\n    • Multiple testing adjustment: BH at level 0.1\n    • N nonzero treatment cells threshold: 7\n    • N nonzero control cells threshold: 7\n    • Formula object: log(response_n_nonzero) + log(response_n_umis) + bio_rep\n\ngRNA-to-cell assignment information:\n    • Assignment method: maximum\n    • Mean N cells per gRNA: 188.45\n    • Mean N gRNAs per cell (MOI): not computed when using \"maximum\" assignment method\n\n\nSome users might ask why sceptre does not implement response-wise QC (e.g., filtering out lowly expressed responses). The reason is that pairwise QC is in some sense stronger than response-wise QC. Suppose for example that a given response exhibits zero expression across cells. Target-response pairs containing this response will have n_nonzero_trt and n_nonzero_cntrl values of zero and thus be filtered out, in effect filtering out the response as well.\n\n\n\n\nBarry, Timothy, Kaishu Mason, Kathryn Roeder, and Eugene Katsevich. 2023. “Robust differential expression testing for single-cell CRISPR screens.” bioRxiv.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Run quality control</span>"
    ]
  },
  {
    "objectID": "run-calibration-check.html",
    "href": "run-calibration-check.html",
    "title": "5  Run calibration check",
    "section": "",
    "text": "5.1 Calibration check methodology\nWe begin by describing the methodology underlying the calibration check (Barry et al. 2023).",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Run calibration check</span>"
    ]
  },
  {
    "objectID": "run-calibration-check.html#calibration-check-methodology",
    "href": "run-calibration-check.html#calibration-check-methodology",
    "title": "5  Run calibration check",
    "section": "",
    "text": "5.1.1 Differential expression paradigm\nThe goal of the calibration check is to test for association between subsets of negative control gRNAs and responses. Suppose for simplicity that we are conducting a singleton analysis, i.e. suppose that we seek to test for association between an individual negative control gRNA and a response. The “treatment group” is the set of cells containing the given non-targeting gRNA, and the “control group” is the set of cells against which the treatment group is compared to carry out the test of association. The control group can be either the complement set or the NT cells. Within the context of the calibration check analysis, the complement set consists of the cells that do not contain the given non-targeting gRNA; the NT cells, on the other hand, consist of the cells that contain any non-targeting gRNA excluding the given non-targeting gRNA that we are testing for association against the response (see Figure 5.1). sceptre carries out the test of association by testing for differential expression of the response across the treatment and control groups, yielding a p-value.\n\n\n\n\n\n\n\nFigure 5.1: A schematic illustrating the differential expression paradigm of the calibration check analysis. The single-cell CRISPR screen experiment produces a pool of cells; in this example the cells contain targeting gRNAs and three non-targeting gRNAs (labeled NT\\(_1\\), NT\\(_2\\), and NT\\(_3\\)). Suppose that we seek to test for association between a given non-targeting gRNA (e.g., NT\\(_2\\)) and a response. First, we divide the cells into treatment and control groups, where the treatment group consists of the cells that contain NT\\(_2\\), and the control group can be either the complement set or the NT cells. Within the context of the calibration check analysis, the complement set consists of all cells that do not contain NT\\(_2\\); the NT cells, on the other hand, consist of cells that contain a non-targeting gRNA excluding NT\\(_2\\). (Thus, in this example, the NT cells consist of cells that contain NT\\(_1\\) or NT\\(_3\\).) sceptre tests for differential expression of the given response across the treatment and control groups, yielding a p-value for the test of association bewteen the given non-targeting gRNA and the response.\n\n\n\n\n\n5.1.2 Constructing the negative control pairs\nThe calibration check involves forming a set of negative control target-response pairs and then testing these pairs for association to ensure control of the false discovery rate. sceptre automatically constructs the negative control pairs, and it does so in such a way that the negative control pairs are highly similar to the discovery pairs, the difference being that the negative control pairs are devoid of biological signal. sceptre builds the negative control pairs as follows. First, sceptre forms “negative control groups” by randomly grouping together distinct sets of negative control gRNAs. For example, in a screen containing nine negative control gRNAs (labeled NT1- NT9), gRNAs NT2, NT5, and NT7 might be assigned randomly to one group, gRNAs NT3, NT6, and NT9 might be assigned randomly to another group, and so on. (See schematic below). The number of negative control gRNAs per group (by default) is set equal to the median number of gRNAs per discovery target. For example, in a screen in which each discovery target is targeted by three gRNAs, each negative control group is formed by randomly putting together three negative control gRNAs. The negative control gRNA groups can (and often do) overlap; for example, a given NT gRNA (e.g., NT2) could be a part of multiple negative control groups.\n\n\n\n\nA schematic illustrating how the negative control target response pairs are constructed. First, negative control gRNA groups are formed by randomly assembling negative control gRNAs into groups of size one or more. Next, the negative control gRNA groups are randomly paired to responses.\n\n\n\nIn a singleton analysis (i.e., an analysis in which we seek to test for association between individual gRNAs and responses), each negative control gRNA is placed into its own negative control group of size one. (Recall from Section 2.4 that we can prompt sceptre to run a singleton analysis by setting grna_integration_strategy to \"singleton\" in set_analysis_parameters()). We often use the term “negative control target” interchangeably with “negative control gRNA group.”\nAfter forming the negative control targets, sceptre constructs the set of negative control pairs by randomly pairing the negative control targets to the responses. The number of negative control pairs that sceptre constructs is set equal to the number of pairs in the discovery set (after QC is applied to the discovery pairs). Moreover, the negative control pairs are subjected to the same pairwise QC as the discovery pairs. In this sense the negative control pairs are “matched” to the discovery pairs in three respects: (1) the number of gRNAs contained within each target is the same across the negative control and discovery pairs; (2) the negative control pairs are subjected to the same pairwise QC as the discovery pairs; (3) the number of negative control pairs is equal to the number of discovery pairs.\n\n5.1.3 Analyzing the negative control pairs\nThe calibration check entails testing for association between the negative control targets and the responses to which the negative control targets have been paired. If grna_integration_strategy is set to \"singleton\", the analysis proceeds as described in Section 5.1.1. If grna_integration_strategy is set to \"union\" (the default), negative control gRNAs contained within a given negative control target are combined via the union operation; this combined gRNA is then tested for association against the responses as if it were a singleton gRNA. Consider again Figure 5.1. Suppose that NT1 and NT2 constitute a given negative control target, and suppose we seek to test for association between this negative control target and a given response. The “treatment group” in this case would be the cells containing either NT1 or NT2. Meanwhile, the “complement set” would consist of cells that do not contain NT1 or NT2. Finally, the “NT cells” would consist of cells containing NT3.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Run calibration check</span>"
    ]
  },
  {
    "objectID": "run-calibration-check.html#sec-run-calibration-check_running_the_calibration_check",
    "href": "run-calibration-check.html#sec-run-calibration-check_running_the_calibration_check",
    "title": "5  Run calibration check",
    "section": "\n5.2 Running the calibration check",
    "text": "5.2 Running the calibration check\nWe carry out the calibration check by calling the function run_calibration_check() on the sceptre_object. run_calibration_check() takes the arguments sceptre_object (required), n_calibration_pairs (optional), calibration_group_size (optional), print_progress (optional), and parallel (optional), and output_amount (optional). n_calibration_pairs is the number of negative control target-response pairs to test for association. By default n_calibration_pairs is set to the number of discovery target-response pairs that passes pairwise QC. Next, calibration_group_size is the number of negative control gRNAs to put together to construct each negative control target. By default calibration_group_size is set to the median number of gRNAs per discovery target. Finally, print_progress and parallel control whether to print updates to the console and run the computation in parallel, respectively. We describe the output_amount argument in a subsequent section. Below, we run the calibration check on the high-MOI CRISPRi and low-MOI CRISPRko data, setting parallel to TRUE.\n\nsceptre_object_highmoi &lt;- run_calibration_check(\n  sceptre_object = sceptre_object_highmoi,\n  parallel = TRUE\n)\nsceptre_object_lowmoi &lt;- run_calibration_check(\n  sceptre_object = sceptre_object_lowmoi,\n  parallel = TRUE\n)\n\nWe can plot the outcome of the calibration check by calling plot() on the resulting sceptre_object. We plot the outcome of the calibration check on the low-MOI CRISPRko data.\n\nplot(sceptre_object_lowmoi)\n\n\n\n\n\nOutcome of the calibration check on the low-MOI CRISPRko data.\n\n\n\nWe described Section 5 of The whole game how to interpret this figure. Briefly, the upper left (resp., right) plot is a QQ plot of the negative control p-values on an untransformed (resp., transformed) scale; the p-values should lie predominantly along the diagonal line. The lower left plot is a histogram of the estimated (log-2) fold changes; the histogram should be symmetric and centered about zero. Finally, the lower right panel is a text box displaying the number of false discoveries made on the negative control pairs (after applying the multiple testing adjustment) and the mean estimated (log-2) fold change. Both of these numbers ideally should be close to zero. (It is OK if the number of false discoveries is nonzero; see next section.)\nWe can obtain a data frame containing the results by calling get_result on the sceptre_object, setting analysis to \"run_calibration_check\".\n\ncalibration_result &lt;- get_result(\n  sceptre_object = sceptre_object_lowmoi,\n  analysis = \"run_calibration_check\"\n)\nhead(calibration_result)\n\n    response_id          grna_target n_nonzero_trt n_nonzero_cntrl pass_qc\n         &lt;char&gt;               &lt;char&gt;         &lt;int&gt;           &lt;int&gt;  &lt;lgcl&gt;\n1:       SLC8B1  NTg4&NTg7&NTg8&NTg9           236             162    TRUE\n2:       UBE2L6 NTg1&NTg5&NTg7&NTg10           982             812    TRUE\n3:       TMEM37  NTg3&NTg4&NTg5&NTg9            46              18    TRUE\n4:       PARPBP NTg3&NTg8&NTg9&NTg10            51              61    TRUE\n5:       MTMR10 NTg1&NTg3&NTg8&NTg10            87             250    TRUE\n6: RP11-799D4.4  NTg2&NTg3&NTg4&NTg7            25              44    TRUE\n        p_value log_2_fold_change significant\n          &lt;num&gt;             &lt;num&gt;      &lt;lgcl&gt;\n1: 0.0000955005        0.23780413       FALSE\n2: 0.0003396914        0.05625781       FALSE\n3: 0.0004477911        0.56398692       FALSE\n4: 0.0010338764        0.53570790       FALSE\n5: 0.0010732514       -0.39425294       FALSE\n6: 0.0011500039       -0.64984993       FALSE\n\n\nEach row of this data frame corresponds to a negative control target-response pair. The columns response_id and grna_target indicate the response and target that make up a given negative control target-response pair. The individual non-targeting gRNAs that form a negative control target are listed, concatenated into a string via the ampersand (“&”) separator. (For example, the negative control gRNA target “NTg4&NTg7&NTg8&NTg9” was formed by combining the negative control gRNAs NTg4, NTg7, NTg8, and NTg9.) The remaining columns of the data frame are as follows: n_nonzero_trt (the number of nonzero treatment cells of a given pair), n_nonzero_cntrl (the number of nonzero control cells of a given pair), pass_qc (whether a given pair passes pairwise QC), p_value (the p-value of a given pair), log_2_fold_change (the estimated log-2 fold change of a given pair), and significant (whether a given pair is called as significant after applying the multiple testing correction adjustment).",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Run calibration check</span>"
    ]
  },
  {
    "objectID": "run-calibration-check.html#diagnosing-miscalibration",
    "href": "run-calibration-check.html#diagnosing-miscalibration",
    "title": "5  Run calibration check",
    "section": "\n5.3 Diagnosing miscalibration",
    "text": "5.3 Diagnosing miscalibration\nThe negative control p-values may demonstrate miscalibration, which is a deviation of the p-values from the expected uniform distribution under the null hypothesis. Indicators of miscalibration include (i) the presence of points that lie considerably above or below the diagonal line on the negative control QQ plots and (ii) a large number of false discoveries on the negative control data. Miscalibration is problematic because it suggests that sceptre does not control the rate of false discoveries on the dataset under analysis. Miscalibration can be more or less severe; the table below provides a rough guideline for interpreting miscalibration severity as a function of the number of false discoveries made on the negative control data.\n\n\nTable 5.1: Calibration quality as a (rough) function of the number of false discoveries made on the negative control data in the calibration check analysis.\n\n\n\nNumber of false discoveries\nCalibration quality\n\n\n\n0-1\nExcellent calibration\n\n\n2-6\nMild miscalibration\n\n\n7-14\nModerate miscalibration\n\n\n15+\nSevere miscalibration\n\n\n\n\n\n\nThere are three main sources of miscalibration in single-cell CRISPR screen analysis (Barry et al. 2023): sparsity, the omission of relevant covariates, and misspecification of the negative binomial model. Sparsity — the presence of a large proportion of zeros in the response UMI count matrix — can cause the skew-normal approximation to the distribution of the null test statistics to break down, resulting in miscalibrated p-values. Additionally, the omission of important covariates (such as batch or biological replicate) from the model or misspecification of the underlying negative binomial GLM (due, for example, to the presence of outlier cells) also can lead to miscalibration. Pairwise and cellwise QC (Chapter 4) provide the first line of defense against sparsity and model misspecification, respectively. Furthermore, the resampling methodology of sceptre protects against misspecification of the negative binomial GLM. In spite of these safeguards, sceptre may still exhibit miscalibration on some datasets.\nTo provide an example of miscalibration, we again run the calibration check on the high-MOI CRISPRi data, this time setting formula_object to formula(~log(grna_n_umis)), thereby excluding batch, response_n_umis, and other important covariates.\n\nsceptre_object_highmoi &lt;- sceptre_object_highmoi |&gt;\n  set_analysis_parameters(\n    discovery_pairs = discovery_pairs,\n    positive_control_pairs = positive_control_pairs,\n    side = \"left\",\n    formula_object = formula(~ log(grna_n_umis))\n  ) |&gt; \n  assign_grnas(parallel = TRUE) |&gt;\n  run_qc()\n\nsceptre_object_highmoi &lt;- run_calibration_check(\n  sceptre_object = sceptre_object_highmoi,\n  parallel = TRUE\n)\n\nWe create a plot to visualize the outcome of the calibration check analysis.\n\nplot(sceptre_object_highmoi)\n\n\n\n\n\nRemoving several covariates results in mild miscalibration on the high-MOI CRISPRi data.\n\n\n\nThe negative control p-values no longer lie completely along the diagonal line in the QQ plots; a handful of p-values in the tail of the distribution, for example, trends markedly above the diagonal. Moreover, sceptre has made five false discoveries. This is an example of mild miscalibration, per Table 5.1.\nWhat should one do in the event that sceptre exhibits miscalibration? If the miscalibration is mild, we recommend proceeding to the next steps of the pipeline (i.e., the power check and discovery analysis). We note that it may not possible to obtain perfect calibration (using sceptre or any other method) on a given dataset, as the dataset may pose fundamental challenges to calibration that are unresolvable. Moreover, it may not be preferable to obtain perfect calibration either, as a mild reduction in miscalibration sometimes leads to a substantial loss of power. If the miscalibration is moderate to severe, we recommend attempting to alleviate the miscalibration using one or more of the strategies described below.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Run calibration check</span>"
    ]
  },
  {
    "objectID": "run-calibration-check.html#sec-improving_calibration",
    "href": "run-calibration-check.html#sec-improving_calibration",
    "title": "5  Run calibration check",
    "section": "\n5.4 Improving calibration",
    "text": "5.4 Improving calibration\nThere are several concrete steps that users can take to improve the calibration of sceptre. We list five of the most important strategies here, ordered roughly from most to least promising. These strategies need not be applied one-at-a-time and instead can be mixed and matched.\n\n\nDeactivate the parametric curve fitting functionality. sceptre by default computes the p-value for a given target-response pair by fitting a parametric curve (specifically, a skew-normal density) to the distribution of null test statistics and then evaluating the tail probability of the fitted curve at the observed test statistic (Section 2.8). If the parametric curve provides a poor fit to the distribution of the null test statistics, the resulting p-value can be miscalibrated. Users can deactivate the parametric curve fitting functionality of sceptre and instead return an exact p-value by setting resampling_approximation to \"no_approximation\" in set_analysis_parameters(), as follows.\n\nsceptre_object_highmoi &lt;- sceptre_object_highmoi |&gt;\n  set_analysis_parameters(\n    discovery_pairs = discovery_pairs,\n    positive_control_pairs = positive_control_pairs,\n    side = \"left\",\n    resampling_approximation = \"no_approximation\"\n  )\n\nThe calibration check, power check, and discovery analyses all run more slowly when resampling_approximation is set to \"no_approximation\", as sceptre must compute a greater number of null test statistics to preserve adequate precision of the p-values. Thus, setting resampling_approximation to \"no_approximation\" may not be a feasible strategy for users seeking to test a large number (e.g., 10,000+) of pairs. Users should consider using the permutation test (resampling_mechaism = \"permutations\") rather than the conditional randomization test (resampling_mechanism = \"crt\") when setting resampling_approximation to \"no_approximation\" to improve speed.\n\nsceptre_object_highmoi &lt;- sceptre_object_highmoi |&gt;\n  set_analysis_parameters(\n    discovery_pairs = discovery_pairs,\n    positive_control_pairs = positive_control_pairs,\n    side = \"left\",\n    resampling_approximation = \"no_approximation\", # slows down the code\n    resampling_mechanism = \"permutations\" # speeds up the code\n  )\n\n\nAdd additional covariates. sceptre may be miscalibrated because important covariates are missing. Users should consider whether any additional covariates are relevant and, if so, add these covariates to the sceptre_object via import_data() or import_data_from_cellranger(). For example, cell type should be included as a covariate if the data contain multiple cell types. Batch, biological replicate, and cell cycle also may be relevant. (sceptre does not currently provide functionality for imputing cell type or cycle.)\n\nTighten the QC thresholds. Users can tighten the cellwise and pairwise QC thresholds to remove outlier cells and target-response pairs with a low effective sample size, respectively, thereby ameliorating challenges to calibration due to sparsity and model misspecification. Below, we increase n_nonzero_trt_thresh and n_nonzero_cntrl_thresh to 15; the default value for these parameters is 7. We additionally set response_n_umis_range to c(0.05, 0.95), which clips the response_n_umis distribution at the fifth and ninety-fifth percentiles (as opposed the the first and ninety-ninth percentiles, which is the default).\n\nsceptre_object_highmoi &lt;- sceptre_object_highmoi |&gt;\n  run_qc(\n    n_nonzero_trt_thresh = 15L,\n    n_nonzero_cntrl_thresh = 15L,\n    response_n_umis_range = c(0.05, 0.95)\n  )\n\n\n\nChange the resampling mechanism or the control group. sceptre provides two options for the resampling mechanism (namely, \"permutations\" or \"crt\"; see Section 2.7) and two options for the control group (namely, \"complement_set\" or \"nt_cells\"; see Section 2.5). (Note that \"nt_cells\" is available as an option only in low-MOI screens.) Switching the resampling mechanism and/or the control group may improve calibration. Below, we set the resampling mechanism to \"crt\" and the control group to \"complement_set\" on the low-MOI CRISPRko data; these choices are the opposites of the defaults.\n\nsceptre_object_lowmoi &lt;- sceptre_object_lowmoi |&gt;\n  set_analysis_parameters(\n    sceptre_object = sceptre_object_lowmoi,\n    discovery_pairs = discovery_pairs_lowmoi,\n    positive_control_pairs = positive_control_pairs_lowmoi,\n    resampling_mechanism = \"crt\",\n    control_group = \"complement_set\"\n  )\n\n\n\nTest fewer pairs. Obtaining good calibration becomes increasingly challenging as the number of target-response pairs in the discovery set grows. This is because the p-values must maintain uniformity further and further out into the tail of the distribution. A simple strategy to improve calibration is to reduce the number of target-response pairs by more selectively choosing pairs for inclusion in the discovery set. For example, we could construct the discovery set for the high-MOI CRISPRi data by coupling each candidate enhancer to the set of genes within one megabase of that candidate enhancer (as opposed to five megabases, as we have done previously). This change reduces the number of pairs in the discovery set (before applying QC) from 610 to 353, which makes obtaining good calibration considerably easier.\n\ndiscovery_pairs &lt;- construct_cis_pairs(sceptre_object_highmoi,\n  positive_control_pairs = positive_control_pairs,\n  distance_threshold = 1e6 # previous value: 5e6\n)\nsceptre_object_highmoi &lt;- sceptre_object_highmoi |&gt;\n  set_analysis_parameters(\n    discovery_pairs = discovery_pairs,\n    positive_control_pairs = positive_control_pairs,\n    side = \"left\"\n  )\n\nUsers also could more aggressively prioritize pairs for inclusion in the discovery set by leveraging orthogonal information, such as ATAC-seq or ChIP-seq data.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Run calibration check</span>"
    ]
  },
  {
    "objectID": "run-calibration-check.html#sec-run_calibration_check_output_amount",
    "href": "run-calibration-check.html#sec-run_calibration_check_output_amount",
    "title": "5  Run calibration check",
    "section": "\n5.5 The output_amount argument",
    "text": "5.5 The output_amount argument\n\n\n\n\n\n\nNote\n\n\n\nMost users can safely skip this section.\n\n\nThe function run_calibration_check() has the optional argument output_amount, which controls the amount of information that run_calibration_check() returns. output_amount can be set to 1, 2, or 3, with 1 (the default) returning the least information, 2 returning an intermediate amount of information, and 3 returning the most information. Setting output_amount to 2 causes several additional columns to be appended to the calibration check result data frame. To illustrate, we again run the calibration check on the low-MOI CRISPRko data, this time setting output_amount to 2.\n\nsceptre_object_lowmoi &lt;- run_calibration_check(sceptre_object_lowmoi,\n  parallel = TRUE,\n  output_amount = 2\n)\n\n\nsceptre_object_lowmoi |&gt;\n  get_result(analysis = \"run_calibration_check\") |&gt; \n  head()\n\n    response_id          grna_target n_nonzero_trt n_nonzero_cntrl pass_qc\n         &lt;char&gt;               &lt;char&gt;         &lt;int&gt;           &lt;int&gt;  &lt;lgcl&gt;\n1:       SLC8B1  NTg4&NTg7&NTg8&NTg9           236             162    TRUE\n2:       UBE2L6 NTg1&NTg5&NTg7&NTg10           982             812    TRUE\n3:       TMEM37  NTg3&NTg4&NTg5&NTg9            46              18    TRUE\n4:       PARPBP NTg3&NTg8&NTg9&NTg10            51              61    TRUE\n5:       MTMR10 NTg1&NTg3&NTg8&NTg10            87             250    TRUE\n6: RP11-799D4.4  NTg2&NTg3&NTg4&NTg7            25              44    TRUE\n        p_value log_2_fold_change stage    z_orig         xi    omega\n          &lt;num&gt;             &lt;num&gt; &lt;int&gt;     &lt;num&gt;      &lt;num&gt;    &lt;num&gt;\n1: 0.0000955005        0.23780413     2  3.923777  0.2540283 1.040114\n2: 0.0003396914        0.05625781     2  3.694460 -0.2677594 1.059273\n3: 0.0004477911        0.56398692     2  3.327821 -0.4200504 1.018417\n4: 0.0010338764        0.53570790     2  3.387342 -0.7116245 1.180715\n5: 0.0010732514       -0.39425294     2 -3.177835 -0.6407830 1.187394\n6: 0.0011500039       -0.64984993     2 -3.224238  0.2756485 1.027669\n        alpha significant\n        &lt;num&gt;      &lt;lgcl&gt;\n1: -0.3198038       FALSE\n2:  0.3626879       FALSE\n3:  0.4496051       FALSE\n4:  0.8571695       FALSE\n5:  0.8827759       FALSE\n6: -0.3098954       FALSE\n\n\nTo explain what the additional columns represent, we must first provide further details about how the sceptre methodology works. sceptre uses an adaptive resampling scheme to reduce compute. For a given target-response pair, sceptre first computes the observed z-score \\(z_\\textrm{obs}\\) and a small number \\(B_1\\) of null z-scores (where \\(B_1 \\approx 500\\)). The original z-score is compared to the null z-scores to compute a “stage 1” p-value \\(p_1\\). If \\(p_1\\) falls below some threshold (set to 0.02), then sceptre computes a large number \\(B_2\\) of fresh null z-scores (where \\(B_2 \\approx 5,000\\)). A skew-normal distribution is fit to the \\(B_2\\) fresh null z-scores, and a “stage 2” p-value \\(p_2\\) is computed by evaluating the tail probability of the fitted skew-normal distribution at the observed z-score. The goodness of fit of the skew-normal distribution is assessed. If the fit is poor, then sceptre computes a third set of \\(B_3\\) null z-scores (where \\(B_3 \\approx 25,000\\)), and a “stage 3” p-value is computed by comparing the original z-score to this third set of null z-scores.\nThe columns appended to the result data frame when output_amount is set to 2 are as follows: z_orig, stage, xi, omega, and alpha. z_orig is the original z-score. stage is the stage at which the p-value was computed, either 1, 2, or 3. And xi, omega, and alpha are the fitted values of the skew-normal distribution. (The latter three parameters are relevant only when stage is 2; when stage is 1 or 3, these parameters are set to NA.)\nFinally, we can set output_amount to 3, which causes the null z-scores to be appended to the result data frame. The null z-scores are labeled z_null_1, z_null_2, z_null_3, etc.\n\nsceptre_object_lowmoi &lt;- run_calibration_check(sceptre_object_lowmoi,\n  parallel = TRUE,\n  output_amount = 3\n)\ncalibration_result &lt;- get_result(\n  sceptre_object = sceptre_object_lowmoi,\n  analysis = \"run_calibration_check\"\n)\n\n\ncalibration_result[1, ] |&gt;\n  colnames() |&gt;\n  head(20)\n\n [1] \"response_id\"       \"grna_target\"       \"n_nonzero_trt\"    \n [4] \"n_nonzero_cntrl\"   \"pass_qc\"           \"p_value\"          \n [7] \"log_2_fold_change\" \"stage\"             \"z_orig\"           \n[10] \"xi\"                \"omega\"             \"alpha\"            \n[13] \"z_null_1\"          \"z_null_2\"          \"z_null_3\"         \n[16] \"z_null_4\"          \"z_null_5\"          \"z_null_6\"         \n[19] \"z_null_7\"          \"z_null_8\"         \n\n\nFinally, we can call print() on the updated sceptre_object to print a summary of the status of the analysis.\n\nprint(sceptre_object_lowmoi)\n\nAn object of class sceptre_object.\n\nAttributes of the data:\n    • 20729 cells (15348 after cellwise QC)\n    • 299 responses\n    • Low multiplicity-of-infection \n    • 101 targeting gRNAs (distributed across 26 targets) \n    • 9 non-targeting gRNAs \n    • 6 covariates (bio_rep, grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito)\n\nAnalysis status:\n    ✓ import_data()\n    ✓ set_analysis_parameters()\n    ✓ assign_grnas()\n    ✓ run_qc()\n    ✓ run_calibration_check()\n    ✗ run_power_check()\n    ✗ run_discovery_analysis()\n\nAnalysis parameters: \n    • Discovery pairs: data frame with 7765 pairs (6205 after pairwise QC)\n    • Positive control pairs: data frame with 9 pairs (9 after pairwise QC)\n    • Sidedness of test: both\n    • Control group: non-targeting cells\n    • Resampling mechanism: permutations\n    • gRNA integration strategy: union\n    • Resampling approximation: skew normal\n    • Multiple testing adjustment: BH at level 0.1\n    • N nonzero treatment cells threshold: 7\n    • N nonzero control cells threshold: 7\n    • Formula object: log(response_n_nonzero) + log(response_n_umis) + bio_rep\n\ngRNA-to-cell assignment information:\n    • Assignment method: maximum\n    • Mean N cells per gRNA: 188.45\n    • Mean N gRNAs per cell (MOI): not computed when using \"maximum\" assignment method\n\nSummary of results:\n    • N negative control pairs called as significant: 0/6205\n    • Mean log-2 FC for negative control pairs: -0.0027\n\n\nThe the first two entries under the field “Summary of results” provide information about the outcome of the calibration check.\n\n\n\n\nBarry, Timothy, Kaishu Mason, Kathryn Roeder, and Eugene Katsevich. 2023. “Robust differential expression testing for single-cell CRISPR screens.” bioRxiv.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Run calibration check</span>"
    ]
  },
  {
    "objectID": "run-power-check-and-discovery-analysis.html",
    "href": "run-power-check-and-discovery-analysis.html",
    "title": "6  Run power check and discovery analysis",
    "section": "",
    "text": "6.1 Run power check\nWe run the power check by calling the function run_power_check(), which takes the arguments sceptre_object (required), output_amount (optional), print_progress (optional), and parallel (optional). output_amount controls the amount of information that run_power_check() returns; see Section 5.5 of Run calibration check for more information about this argument. print_progress and parallel are logical values indicating whether to print progress updates and run the computation in parallel, respectively. We run the power check on the low-MOI CRISPRko data.\nsceptre_object_lowmoi &lt;- run_power_check(\n  sceptre_object = sceptre_object_lowmoi,\n  parallel = TRUE\n)\nWe call plot() on the resulting sceptre_object to visualize the outcome of the power check.\nplot(sceptre_object_lowmoi)\nPower check results on the low-MOI CRISPRko data.\nWe described how to interpret this plot in Section 6 of The whole game. Briefly, each point represents a pair, and the vertical position of a given point indicates the p-value of the corresponding pair. Points in the left (resp., right) column are positive control (resp, negative control) pairs. The positive control p-values should be generally smaller (i.e., more significant) than the negative control p-values.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Run power check and discovery analysis</span>"
    ]
  },
  {
    "objectID": "run-power-check-and-discovery-analysis.html#run-discovery-analysis",
    "href": "run-power-check-and-discovery-analysis.html#run-discovery-analysis",
    "title": "6  Run power check and discovery analysis",
    "section": "\n6.2 Run discovery analysis",
    "text": "6.2 Run discovery analysis\nWe run the discovery analysis by calling the function run_discovery_analysis(), which takes the same arguments as run_power_check(). We illustrate this function on the low-MOI CRISPRko data.\n\nsceptre_object_lowmoi &lt;- run_discovery_analysis(\n  sceptre_object = sceptre_object_lowmoi,\n  parallel = TRUE\n)\n\nWe can visualize the outcome of the discovery analysis by calling plot() on the resulting sceptre_object.\n\nplot(sceptre_object_lowmoi)\n\n\n\n\n\nDiscovery analysis results on the low-MOI CRISPRko data.\n\n\n\nWe described how to interpret this plot in Section 7 of The whole game. Briefly, the top left (resp. right) panel is a QQ plot of the negative control p-values and the discovery p-values plotted on an untransformed (resp., transformed) scale. The bottom left panel plots the p-value of each discovery pair against its log-2-fold-change. Finally, the bottom right panel displays the number of discoveries that sceptre makes on the discovery set (after applying the multiplicity correction).",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Run power check and discovery analysis</span>"
    ]
  },
  {
    "objectID": "run-power-check-and-discovery-analysis.html#visualizing-the-results-for-individual-pairs",
    "href": "run-power-check-and-discovery-analysis.html#visualizing-the-results-for-individual-pairs",
    "title": "6  Run power check and discovery analysis",
    "section": "\n6.3 Visualizing the results for individual pairs",
    "text": "6.3 Visualizing the results for individual pairs\nWe can visualize the results for an individual target-response pair by calling the function plot_response_grna_target_pair(). plot_response_grna_target_pair() takes as input a sceptre_object, a response ID response_id, and a gRNA target grna_target. plot_response_grna_target_pair() creates two side-by-side violin plots depicting the expression level of the response. The left (resp., right) violin plot shows the expression level of the response in treatment (resp., control) cells. (When control_group is set to \"nt_cells\", the control cells are those containing an NT gRNA, whereas when control_group is set to \"complement\", the control cells are those that do not contain a gRNA targeting the given site.) The response expression vector is normalized by dividing by the library size (i.e., response_n_umis), adding a pseudo-count of 1, and then taking a log transformation. Finally, if the given pair has been analyzed (either as part of the power check or the discovery analysis), a p-value for the test of association between the target and response is displayed.\nTo illustrate use of this function, we create the above-described plot for two pairs: the positive control pair consisting of gRNA target “CMTM6” and response “CMTM6”, and the discovery pair consisting of gRNA target “STAT3” and response “ACADVL.” We use plot_grid() from cowplot to render the plots side-by-side.\n\npc_pair &lt;- plot_response_grna_target_pair(sceptre_object = sceptre_object_lowmoi,\n                                          response_id = \"CMTM6\",\n                                          grna_target = \"CMTM6\")\ndisc_pair &lt;- plot_response_grna_target_pair(sceptre_object = sceptre_object_lowmoi,\n                                            response_id = \"ACADVL\",\n                                            grna_target = \"STAT3\")\nplot_grid(pc_pair, disc_pair)\n\n\n\n\n\nA visualization of the results for two pairs.\n\n\n\nFinally, if grna_integration_strategy has been set to \"singleton\", then an individual gRNA ID should be passed to grna_target in lieu of of a gRNA target.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Run power check and discovery analysis</span>"
    ]
  },
  {
    "objectID": "run-power-check-and-discovery-analysis.html#inspecting-the-results",
    "href": "run-power-check-and-discovery-analysis.html#inspecting-the-results",
    "title": "6  Run power check and discovery analysis",
    "section": "\n6.4 Inspecting the results",
    "text": "6.4 Inspecting the results\nWe can obtain a data frame containing the results by calling get_result() on the sceptre_object, setting the parameter analysis to the name of the function whose results we are querying. For example, we can obtain the discovery results as follows.\n\ndiscovery_result &lt;- get_result(\n  sceptre_object = sceptre_object_lowmoi,\n  analysis = \"run_discovery_analysis\"\n)\nhead(discovery_result)\n\n   response_id grna_target n_nonzero_trt n_nonzero_cntrl pass_qc       p_value\n        &lt;char&gt;      &lt;char&gt;         &lt;int&gt;           &lt;int&gt;  &lt;lgcl&gt;         &lt;num&gt;\n1:        JAK2       STAT1           112            1557    TRUE 1.000000e-250\n2:       PSMB9      IFNGR1           873            1801    TRUE 3.381202e-155\n3:       PSMB9        JAK2           706            1801    TRUE 4.456437e-145\n4:       STAT1      IFNGR2           821            1819    TRUE 1.918728e-127\n5:       STAT1      IFNGR1           898            1819    TRUE 7.934591e-127\n6:       STAT1        JAK2           714            1819    TRUE 1.342549e-122\n   log_2_fold_change significant\n               &lt;num&gt;      &lt;lgcl&gt;\n1:        -1.3840723        TRUE\n2:        -0.8561766        TRUE\n3:        -0.9410000        TRUE\n4:        -0.6669393        TRUE\n5:        -0.6371647        TRUE\n6:        -0.7134929        TRUE\n\n\nThe data frame discovery_result contains the columns response_id, grna_target, n_nonzero_trt, n_nonzero_cntrl, pass_qc, p_value, log_2_fold_change, and significant; see Section 5.2 of Run calibration check for a description of these columns. The rows are ordered according to p_value. Pairs called as significant are stored in the top rows of the data frame; pairs called as insignificant are stored in the middle rows; and pairs filtered out by pairwise QC are stored in the bottom rows. (The latter pairs have a value of NA in the p_value, log_2_fold_change, and significant columns.)\nThe format of the result data frame is slightly different when we use the “singleton” gRNA integration strategy rather than the default “union” strategy. To illustrate, we again analyze the low-MOI CRISPRko data, this time setting grna_integration_strategy to \"singleton\" in set_analysis_parameters(). We then call assign_grnas(), run_qc(), and run_discovery_analysis().\n\nsceptre_object_lowmoi_singleton &lt;- sceptre_object_lowmoi |&gt;\n  set_analysis_parameters(\n    discovery_pairs = discovery_pairs_lowmoi,\n    positive_control_pairs = positive_control_pairs_lowmoi,\n    grna_integration_strategy = \"singleton\"\n  ) |&gt;\n  assign_grnas() |&gt;\n  run_qc(p_mito_threshold = 0.075) |&gt;\n  run_discovery_analysis(parallel = TRUE)\n\nThe result data frame obtained via get_result() contains the additional column grna_id. Each row of this data frame corresponds to an individual gRNA-response pair (as opposed to target-response pair).\n\ndiscovery_result &lt;- get_result(\n  sceptre_object = sceptre_object_lowmoi_singleton,\n  analysis = \"run_discovery_analysis\"\n)\nhead(discovery_result)\n\n   response_id  grna_id grna_target n_nonzero_trt n_nonzero_cntrl pass_qc\n        &lt;char&gt;   &lt;char&gt;      &lt;char&gt;         &lt;int&gt;           &lt;int&gt;  &lt;lgcl&gt;\n1:        JAK2 IFNGR1g3      IFNGR1           141            1557    TRUE\n2:        JAK2   IRF1g4        IRF1            94            1557    TRUE\n3:       PSMB9 IFNGR1g3      IFNGR1           304            1801    TRUE\n4:       STAT1 IFNGR2g2      IFNGR2           280            1819    TRUE\n5:      UBE2L6 IFNGR2g1      IFNGR2           375            1794    TRUE\n6:       PSMB9 IFNGR2g1      IFNGR2           384            1801    TRUE\n         p_value log_2_fold_change significant\n           &lt;num&gt;             &lt;num&gt;      &lt;lgcl&gt;\n1: 1.000000e-250        -1.5869800        TRUE\n2: 1.000000e-250        -1.7962142        TRUE\n3: 1.000000e-250        -1.2386121        TRUE\n4: 1.000000e-250        -0.7611831        TRUE\n5: 1.000000e-250        -0.8712660        TRUE\n6: 9.742212e-106        -1.2076649        TRUE\n\n\nWe can filter for a given target to view the p-values of the individual gRNAs targeting that target. For example, we filter the result data frame for rows containing response ID “PSMB9” and gRNA target “IFNGR2,” displaying the columns response_id, grna_id, grna_target, p_value, significant, and n_nonzero_trt.\n\ndiscovery_result |&gt;\n  filter(response_id == \"PSMB9\", grna_target == \"IFNGR2\") |&gt;\n  select(response_id, grna_id, grna_target, p_value, significant, n_nonzero_trt)\n\n   response_id  grna_id grna_target       p_value significant n_nonzero_trt\n        &lt;char&gt;   &lt;char&gt;      &lt;char&gt;         &lt;num&gt;      &lt;lgcl&gt;         &lt;int&gt;\n1:       PSMB9 IFNGR2g1      IFNGR2 9.742212e-106        TRUE           384\n2:       PSMB9 IFNGR2g2      IFNGR2  9.280088e-50        TRUE           286\n3:       PSMB9 IFNGR2g3      IFNGR2  1.424416e-17        TRUE           115\n4:       PSMB9 IFNGR2g4      IFNGR2  3.200000e-02       FALSE            12\n\n\nThe individual gRNAs that target “IFNGR2” are “IFNGR2g1,” “IFNGR2g2,” IFNGR2g3,” and “IFNGR2g4.” All produce a significant association except “IFNGR2g4.” The latter likely does not produce a significant association because the pair consisting of gRNA IFNGR2g4 and response PSMB9 has a smaller effective sample size than the other pairs (as quantified by n_nonzero_trt).\nWe additionally can call print() on the updated sceptre_object to print information about the status of the analysis to the console.\n\nprint(sceptre_object_lowmoi)\n\nAn object of class sceptre_object.\n\nAttributes of the data:\n    • 20729 cells (15348 after cellwise QC)\n    • 299 responses\n    • Low multiplicity-of-infection \n    • 101 targeting gRNAs (distributed across 26 targets) \n    • 9 non-targeting gRNAs \n    • 6 covariates (bio_rep, grna_n_nonzero, grna_n_umis, response_n_nonzero, response_n_umis, response_p_mito)\n\nAnalysis status:\n    ✓ import_data()\n    ✓ set_analysis_parameters()\n    ✓ assign_grnas()\n    ✓ run_qc()\n    ✓ run_calibration_check()\n    ✓ run_power_check()\n    ✓ run_discovery_analysis()\n\nAnalysis parameters: \n    • Discovery pairs: data frame with 7765 pairs (6205 after pairwise QC)\n    • Positive control pairs: data frame with 9 pairs (9 after pairwise QC)\n    • Sidedness of test: both\n    • Control group: non-targeting cells\n    • Resampling mechanism: permutations\n    • gRNA integration strategy: union\n    • Fit parametric curve: TRUE\n    • Multiple testing adjustment: BH at level 0.1\n    • N nonzero treatment cells threshold: 7\n    • N nonzero control cells threshold: 7\n    • Formula object: log(response_n_nonzero) + log(response_n_umis) + bio_rep\n\ngRNA-to-cell assignment information:\n    • Assignment method: maximum\n    • Mean N cells per gRNA: 193.73\n    • Mean N gRNAs per cell (MOI): not computed when using \"maximum\" assignment method\n\nSummary of results:\n    • N negative control pairs called as significant: 0/6205\n    • Mean log-2 FC for negative control pairs: -0.0027\n    • Median positive control p-value: 1.3e-18\n    • N discovery pairs called as significant: 453/6205\n\n\nThe third and fourth entries under the field “Summary of results” provide information about the power check and discovery analysis, respectively.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Run power check and discovery analysis</span>"
    ]
  },
  {
    "objectID": "run-power-check-and-discovery-analysis.html#writing-the-outputs-to-a-directory",
    "href": "run-power-check-and-discovery-analysis.html#writing-the-outputs-to-a-directory",
    "title": "6  Run power check and discovery analysis",
    "section": "\n6.5 Writing the outputs to a directory",
    "text": "6.5 Writing the outputs to a directory\nWe can write all outputs (i.e., results and plots) of an analysis to a directory on disk via the function write_outputs_to_directory(). See Section 8 of The whole game for a description of this function.",
    "crumbs": [
      "Part I. Introduction to sceptre",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Run power check and discovery analysis</span>"
    ]
  },
  {
    "objectID": "at-scale.html",
    "href": "at-scale.html",
    "title": "7  Introduction to the Nextflow pipeline",
    "section": "",
    "text": "Software installation\nThe examples in this chapter depend on several software packages. First, users should install ondisc onto their local machine. ondisc has the Bioconductor dependency Rhdf5lib, which we recommend downloading and installing from source (before installing ondisc).\nR, local\n\n# install.packages(\"BiocManager\")\nBiocManager::install(\"Rhdf5lib\", type = \"source\") # Rhdf5lib\ndevtools::install_github(\"timothy-barry/ondisc\") # ondisc\nNext, users should install both sceptre and ondisc onto their cluster.\nR, cluster\n\ndevtools::install_github(\"katsevich-lab/sceptre\") # sceptre\n# install.packages(\"BiocManager\")\nBiocManager::install(\"Rhdf5lib\", type = \"source\") # Rhdf5lib\ndevtools::install_github(\"timothy-barry/ondisc\") # ondisc\nFinally, users should install Nextflow onto their local machine and their cluster. Instructions for installing Nextflow are available in the addendum to Part II of the book (Section 9.1).",
    "crumbs": [
      "Part II. At-scale sceptre",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to the Nextflow pipeline</span>"
    ]
  },
  {
    "objectID": "at-scale.html#sec-import_data_into_odm_backed_sceptre_object",
    "href": "at-scale.html#sec-import_data_into_odm_backed_sceptre_object",
    "title": "7  Introduction to the Nextflow pipeline",
    "section": "\n7.1 Import data into an ondisc-backed sceptre object (local machine)",
    "text": "7.1 Import data into an ondisc-backed sceptre object (local machine)\nThe first step is to import the data into an ondisc-backed sceptre object. To import data outputted by one or more calls to cellranger count, we call the function import_data_from_cellranger(), setting the argument use_ondisc to TRUE. Additionally, we set directory_to_write to a string indicating the directory in which to write the backing .odm files, which are the files that will contain the gene and gRNA expression matrices. In the example below we set directory_to_write to \"~/sceptre_data\", although any valid file path will do. Finally, we set moi to the MOI of the dataset, grna_target_data_frame to the gRNA target data frame, and directories to the set of directories outputted by one or more calls to cellranger count. (The latter three arguments were described in depth in Section 1 of The whole game.)\n\nlibrary(sceptre)\nlibrary(sceptredata)\n\n# set the arguments\ndirectories &lt;- paste0(\n  system.file(\"extdata\", package = \"sceptredata\"),\n  \"/highmoi_example/gem_group_\", 1:2\n)\ndata(grna_target_data_frame_highmoi)\ndirectory_to_write &lt;- \"~/sceptre_data\"\n\n\n# call the data import function\nsceptre_object &lt;- import_data_from_cellranger(\n  directories = directories,\n  moi = \"high\",\n  grna_target_data_frame = grna_target_data_frame_highmoi,\n  use_ondisc = TRUE,\n  directory_to_write = directory_to_write\n)\n\nimport_data_from_cellranger() (with use_ondisc set to TRUE) converts the inputted .mtx files into .odm files, with one .odm file generated per modality. The .odm files contain the same information as the .mtx files, but the data are stored in a much more efficient format for single-cell CRISPR screen analysis. Additionally, import_data_from_cellranger() computes the cell-specific covariates (e.g., response_n_umis, response_p_mito, batch, etc.). Importantly, import_data_from_cellranger() uses only a few gigabytes of memory, even when the input data are tens of gigabytes in size.\nCalling list.files() on directory_to_write shows that two files have been created in this directory: gene.odm, the file storing the gene expression matrix, and grna.odm, the file storing the gRNA expression matrix.\n\nlist.files(directory_to_write, full.names = TRUE)\n\n\n\n[1] \"gene.odm\" \"grna.odm\"\n\n\nUsers alternately can create an ondisc-backed sceptre_object from a collection of R objects by calling import_data(), setting use_ondisc to TRUE. (See ?import_data() and Section 1.5 for more information.) We recommend calling import_data_from_cellranger() in place of import_data() when possible, as the former can handle arbitrarily large matrices and is more memory-efficient, while the latter only can handle matrices that contain fewer than ~2.1 billion nonzero entries.",
    "crumbs": [
      "Part II. At-scale sceptre",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to the Nextflow pipeline</span>"
    ]
  },
  {
    "objectID": "at-scale.html#explore-the-data-local-machine",
    "href": "at-scale.html#explore-the-data-local-machine",
    "title": "7  Introduction to the Nextflow pipeline",
    "section": "\n7.2 Explore the data (local machine)",
    "text": "7.2 Explore the data (local machine)\nThe next step — which is optional but generally helpful — is to explore the data within the R console. There are three relevant functions in this context: get_cell_covariates(), get_response_matrix(), and get_grna_matrix(). get_cell_covariates() returns the cell-specific covariates that were computed as part of the data import step.\n\ncell_covariates &lt;- get_cell_covariates(sceptre_object)\nhead(cell_covariates)\n\n   response_n_umis response_n_nonzero response_p_mito grna_n_umis\n             &lt;int&gt;              &lt;int&gt;           &lt;num&gt;       &lt;int&gt;\n1:             830                171      0.04096386          24\n2:             737                160      0.05563094           8\n3:            1172                199      0.03412969           6\n4:             787                168      0.04574333           8\n5:             653                128      0.04594181          14\n6:             879                177      0.02957907          25\n   grna_n_nonzero   batch\n            &lt;int&gt;  &lt;fctr&gt;\n1:              3 batch_1\n2:              1 batch_1\n3:              1 batch_1\n4:              1 batch_1\n5:              1 batch_1\n6:              1 batch_1\n\n\nNext, get_response_matrix() and get_grna_matrix() return the response and gRNA matrix, respectively. We call get_response_matrix() below.\n\nresponse_matrix &lt;- get_response_matrix(sceptre_object)\n\nresponse_matrix is an object of class odm, which is an integer-valued expression matrix backed by an .odm file. Evaluating response_matrix in the console prints the number of features and cells contained within the matrix, as well as the file path to the backing .odm file. The “Backing file” field is machine-specific.\n\nresponse_matrix\n\nAn object of class odm with the following attributes:\n    • 526 features\n    • 45919 cells\n    • Backing file: /Users/tib163/sceptre_data/gene.odm\n\n\nodm objects support many of the key operators that standard R matrices support. For example, one can obtain the feature IDs of an odm object by calling rownames().\n\nresponse_ids &lt;- rownames(response_matrix)\nhead(response_ids)\n\n[1] \"ENSG00000069275\" \"ENSG00000117222\" \"ENSG00000117266\" \"ENSG00000117280\"\n[5] \"ENSG00000133059\" \"ENSG00000133065\"\n\n\nAdditionally, one can use the bracket operator (i.e, [, ]) to load a given row of the expression matrix into memory. For example, response_matrix[\"ENSG00000069275\",] loads the expression vector corresponding to the gene “ENSG00000069275” into memory.\n\nexpression_vector &lt;- response_matrix[\"ENSG00000069275\",]\nhead(expression_vector)\n\n[1]  4  6 10  9  4 13\n\n\nodm objects take up very little space, as the expression data are stored on disk rather than in memory. For example, response_matrix takes up only 40 kilobytes (or 0.04 megabytes) of memory.\n\nobject.size(response_matrix) |&gt; format(units = \"Kb\")\n\n[1] \"38.6 Kb\"",
    "crumbs": [
      "Part II. At-scale sceptre",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to the Nextflow pipeline</span>"
    ]
  },
  {
    "objectID": "at-scale.html#sec-at_scale_set_analysis_parameters",
    "href": "at-scale.html#sec-at_scale_set_analysis_parameters",
    "title": "7  Introduction to the Nextflow pipeline",
    "section": "\n7.3 Set the analysis parameters (local machine)",
    "text": "7.3 Set the analysis parameters (local machine)\nThe third step is to set the analysis parameters. We proceed more or less exactly as described in Section 2 of The whole game. We seek to conduct a trans analysis of the high-MOI CRISPRi data. Hence, we construct the positive control and discovery pairs using the functions construct_positive_control_pairs() and construct_trans_pairs(), respectively.\n\n# positive control pairs\npositive_control_pairs &lt;- construct_positive_control_pairs(\n  sceptre_object = sceptre_object\n)\n# discovery pairs\ndiscovery_pairs &lt;- construct_trans_pairs(\n  sceptre_object = sceptre_object,\n  positive_control_pairs = positive_control_pairs,\n  pairs_to_exclude = \"pairs_containing_pc_targets\"\n)\n\nNext, we set the analysis parameters via a call to set_analysis_parameters(). We set resampling_mechanism to \"permutations\" (as opposed to the default of \"crt\" in high-MOI), as \"permutations\" currently is the only option available for resampling_mechanism for an ondisc-backed sceptre_object. Additionally, we set side to \"both\" to conduct a two-tailed test, as we do not have a strong prior as to whether the perturbations will lead to an increase or decrease in the expression of the genes in trans.\n\nsceptre_object &lt;- set_analysis_parameters(\n  sceptre_object = sceptre_object,\n  discovery_pairs = discovery_pairs,\n  positive_control_pairs = positive_control_pairs,\n  side = \"both\",\n  resampling_mechanism = \"permutations\"\n)\n\nThis step is optional; users instead can specify the analysis parameters on the command line as arguments to the Nextflow pipeline.\n\n\n\n\n\n\nTip\n\n\n\nThe standard interface to the sceptre Nextflow pipeline is designed to handle up to 10 million pairs (which is quite a large analysis!). Users interested in analyzing more than 10 million pairs (in particular, in the context of a massive-scale trans analysis) should consult Section 8.4.",
    "crumbs": [
      "Part II. At-scale sceptre",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to the Nextflow pipeline</span>"
    ]
  },
  {
    "objectID": "at-scale.html#write-the-ondisc-backed-sceptre_object-to-disk-local-machine",
    "href": "at-scale.html#write-the-ondisc-backed-sceptre_object-to-disk-local-machine",
    "title": "7  Introduction to the Nextflow pipeline",
    "section": "\n7.4 Write the ondisc-backed sceptre_object to disk (local machine)",
    "text": "7.4 Write the ondisc-backed sceptre_object to disk (local machine)\nThe next step is to write the ondisc-backed sceptre_object to disk. To this end, we call the function write_ondisc_backed_sceptre_object(), passing sceptre_object and directory_to_write as arguments. The sceptre_object is saved within directory_to_write as sceptre_object.rds. directory_to_write can be any directory.\n\nwrite_ondisc_backed_sceptre_object(\n  sceptre_object = sceptre_object,\n  directory_to_write = directory_to_write\n)\n\ndirectory_to_write now contains three files: gene.odm, grna.odm, and sceptre_object.rds.\n\nlist.files(directory_to_write)\n\n\n\n[1] \"gene.odm\"           \"grna.odm\"           \"sceptre_object.rds\"",
    "crumbs": [
      "Part II. At-scale sceptre",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to the Nextflow pipeline</span>"
    ]
  },
  {
    "objectID": "at-scale.html#call-the-trial-nextflow-pipeline-local-machine",
    "href": "at-scale.html#call-the-trial-nextflow-pipeline-local-machine",
    "title": "7  Introduction to the Nextflow pipeline",
    "section": "\n7.5 Call the trial Nextflow pipeline (local machine)",
    "text": "7.5 Call the trial Nextflow pipeline (local machine)\nThe next step is to invoke the Nextflow pipeline on the local machine to analyze a small subset of the data. This small-scale analysis — which we call a “trial” analysis — enables us to verify that the pipeline is in working order. A Nextflow launch script for the example high-MOI data is as follows.\n\n\nlaunch_script.sh\n\n#!/bin/bash\n# Limit NF driver to 4 GB memory\nexport NXF_OPTS=\"-Xms500M -Xmx4G\"\n\n##########################\n# REQUIRED INPUT ARGUMENTS\n##########################\ndata_directory=$HOME\"/sceptre_data/\"\n# sceptre object\nsceptre_object_fp=$data_directory\"sceptre_object.rds\"\n# response ODM\nresponse_odm_fp=$data_directory\"gene.odm\"\n# grna ODM\ngrna_odm_fp=$data_directory\"grna.odm\"\n\n###################\n# OUTPUT DIRECTORY:\n##################\noutput_directory=$HOME\"/sceptre_outputs\"\n\n#################\n# Invoke pipeline\n#################\nnextflow run timothy-barry/sceptre-pipeline -r main \\\n --sceptre_object_fp $sceptre_object_fp \\\n --response_odm_fp $response_odm_fp \\\n --grna_odm_fp $grna_odm_fp \\\n --output_directory $output_directory \\\n --grna_assignment_method mixture \\\n --pair_pod_size 1000 \\\n --grna_pod_size 25 \\\n --trial\n\nWe will describe the structure of this launch script in detail shortly. For the time being, note that the --trial flag on the last line tells Nextflow to run the trial pipeline as opposed to the full-scale pipeline. Users can copy and paste the above script into a file called launch_script.sh. Alternately, users can access launch_script.sh by git cloning the sceptre-pipeline directory and then changing directories into the examples subdirectory, as follows.\n\n\nterminal\n\ngit clone git@github.com:timothy-barry/sceptre-pipeline.git\ncd sceptre-pipeline/examples\n\nWe run the pipeline by calling bash on launch_script.sh:\n\n\nterminal\n\nbash launch_script.sh\n# alternately: ./launch_script.sh\n\nIf the pipeline runs correctly, the terminal output looks something like the following.\n\n\n\n\nNextflow output for the trial pipeline on a local machine.\n\n\n\nThe results of the pipeline are stored in ~/sceptre_outputs. Calling list.files on ~/sceptre_outputs shows that the directory contains all of the standard sceptre outputs, including the analysis summary text file (analysis_summary.txt), the plot files (e.g., plot_assign_grnas.png, etc.), and the result files (e.g., results_run_discovery_analysis.rds, etc.).\n\nlist.files(\"~/sceptre_outputs\")\n\n\n\n [1] \"analysis_summary.txt\"               \"plot_assign_grnas.png\"             \n [3] \"plot_covariates.png\"                \"plot_grna_count_distributions.png\" \n [5] \"plot_run_calibration_check.png\"     \"plot_run_discovery_analysis.png\"   \n [7] \"plot_run_power_check.png\"           \"plot_run_qc.png\"                   \n [9] \"results_run_calibration_check.rds\"  \"results_run_discovery_analysis.rds\"\n[11] \"results_run_power_check.rds\"        \"grna_assignment_matrix.rds\"        \n\n\nAn inspection of analysis_summary.txt indicates that 97 negative control pairs and 97 discovery pairs were analyzed. The trial Nextflow pipeline randomly samples 100 pairs from the discovery set, 100 pairs from the negative control set, and 100 pairs from the positive control set and subjects these pairs to analysis. (Some of the pairs may be filtered out by pairwise QC. Moreover, if any of the sets contains fewer than 100 pairs, then that entire set of pairs is analyzed.) If the trial pipeline runs without issue, one can proceed to the next step.\n\n\n\n\n\n\nTip\n\n\n\nThe trial pipeline is purely for computational purposes. Statistical performance in the context of the trial pipeline is not necessarily reflective of statistical performance in the context of the full-scale pipeline.",
    "crumbs": [
      "Part II. At-scale sceptre",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to the Nextflow pipeline</span>"
    ]
  },
  {
    "objectID": "at-scale.html#sec-push_data_to_cluster",
    "href": "at-scale.html#sec-push_data_to_cluster",
    "title": "7  Introduction to the Nextflow pipeline",
    "section": "\n7.6 Push the data to the cluster",
    "text": "7.6 Push the data to the cluster\nThe next step is to push the data to the cluster. The following block of code creates a directory ~/sceptre_data on the cluster. It then copies the contents of ~/sceptre_data (on the local machine) into ~/sceptre_data (on the cluster). The strings “username” and “cluster_address” should be replaced by one’s username and cluster address, respectively.\n\n\nterminal\n\nssh username@cluster_address \"mkdir -p ~/sceptre_data\"\nscp -r ~/sceptre_data username@cluster_address:~/\n\nWe optionally can load and explore the data on the cluster. The function read_ondisc_backed_sceptre_object() loads an ondisc-backed sceptre_object, taking sceptre_object_fp (i.e., the file path to sceptre_object.rds), response_odm_file_fp (i.e., the file path to the response .odm file), and grna_odm_file_fp (i.e., the file path to the gRNA .odm file) as arguments. We briefly explore the sceptre_object to verify that looks the same on the cluster as on the local machine.\n\n\n\nR, cluster\n\nlibrary(sceptre)\ndata_dir &lt;- \"~/sceptre_data/\"\nsceptre_object &lt;- read_ondisc_backed_sceptre_object( \n  sceptre_object_fp = paste0(data_dir, \"sceptre_object.rds\"),\n  response_odm_file_fp = paste0(data_dir, \"gene.odm\"),\n  grna_odm_file_fp = paste0(data_dir, \"grna.odm\")\n)\nresponse_matrix &lt;- get_response_matrix(sceptre_object)\nexpression_vector &lt;- response_matrix[\"ENSG00000069275\",]\n# etc...\n\n\n\n\n\n\n\n\nNote\n\n\n\nWe saved the example data to the home directory for convenience. On most clusters there is a dedicated “data” directory. Best practices dictate that users store their data in the dedicated data directory, especially when the data are large.\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe first six steps of the Nextflow-based pipeline (i.e., Section 7.1 – Section 7.6) can be carried out entirely on the cluster, bypassing the local machine. If the output directories from cellranger count are stored on the cluster, the user can import the data into an ondisc-backed sceptre_object, set the analysis parameters, and write the updated sceptre_object to disk on the cluster as follows.\n\nShow code# on cluster\n# import data\nsceptre_object &lt;- import_data_from_cellranger(\n  directories = directories,\n  moi = \"high\",\n  grna_target_data_frame = grna_target_data_frame_highmoi,\n  use_ondisc = TRUE,\n  directory_to_write = directory_to_write\n)\n# set analysis parameters (define discovery_pairs, positive_control_pairs)\nsceptre_object &lt;- set_analysis_parameters(\n  sceptre_object = sceptre_object,\n  discovery_pairs = discovery_pairs,\n  positive_control_pairs = positive_control_pairs,\n  side = \"both\",\n  resampling_mechanism = \"permutations\"\n)\n# write updated sceptre_object to disk\nwrite_ondisc_backed_sceptre_object(\n  sceptre_object = sceptre_object,\n  directory_to_write = directory_to_write\n)\n\n\nThe above script should require only a few (e.g., 3 – 4) gigabytes of memory, even if the input data are tens of gigabytes in size. This approach, though streamlined, is less interactive than the local-machine-based approach outlined in sections Section 7.1 – Section 7.6.",
    "crumbs": [
      "Part II. At-scale sceptre",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to the Nextflow pipeline</span>"
    ]
  },
  {
    "objectID": "at-scale.html#call-the-trial-pipeline-cluster",
    "href": "at-scale.html#call-the-trial-pipeline-cluster",
    "title": "7  Introduction to the Nextflow pipeline",
    "section": "\n7.7 Call the trial pipeline (cluster)",
    "text": "7.7 Call the trial pipeline (cluster)\nThe next step is to call the trial pipeline on the cluster. First, we download the launch_script.sh submission script onto the cluster using the same command as before.\n\n\nterminal, cluster\n\ngit clone git@github.com:timothy-barry/sceptre-pipeline.git\ncd sceptre-pipeline/examples\n\nWe launch the pipeline by submitting launch_script.sh to the scheduler. For example, on a Sun Grid Engine (SGE) cluster, one would use the qsub command.\n\n\nterminal, cluster\n\nqsub launch_script.sh\n\nOn SLURM cluster, on the other hand, one would use the sbatch command.\n\n\nterminal, cluster\n\nsbatch launch_script.sh\n\nlaunch_script.sh launches the Nextflow driver, which is a process that runs throughout the duration of the pipeline and manages the submission of all the other processes. Depending on their cluster, users may need to specify a time and/or memory allocation request at the top of launch_script.sh. The Nextflow driver of the trial pipeline requires fewer than 30 minutes of wall time and four gigabytes of memory. More details are available in Section 8.2.\nImportantly, we are able to launch the pipeline using essentially the same command on our local machine as on the cluster. This is one of the advantages of Nextflow: it provides a layer of abstraction between the logic of the pipeline and the execution environment. Thus, we can develop (or debug, etc.) a pipeline on our local machine and then run it at scale on the cluster without modification.\nThe pipeline outputs are written to the directory ~/sceptre_outputs. Again, all of the standard sceptre outputs — e.g., analysis_summary.txt, results_run_discovery_analysis.rds, etc. — are contained within this directory. In fact, the ~/sceptre_outputs directory on the cluster should match exactly the ~/sceptre_outputs directory on the local machine. We can view analysis_summary.txt, for example, by calling cat on this file:\n\n\nterminal, cluster\n\ncat analysis_summary.txt",
    "crumbs": [
      "Part II. At-scale sceptre",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to the Nextflow pipeline</span>"
    ]
  },
  {
    "objectID": "at-scale.html#sec-call_full_pipeline",
    "href": "at-scale.html#sec-call_full_pipeline",
    "title": "7  Introduction to the Nextflow pipeline",
    "section": "\n7.8 Call the full pipeline (cluster)",
    "text": "7.8 Call the full pipeline (cluster)\nThe final step is to run the full pipeline on the cluster. To this end, we modify launch_script.sh, removing the --trial flag from the last line of the script. We can do this on the cluster by calling nano launch_script.sh, deleting the --trial flag, and saving the updated script. launch_script.sh now should look as follows.\n\nShow code#!/bin/bash\n# Limit NF driver to 4 GB memory\nexport NXF_OPTS=\"-Xms500M -Xmx4G\"\n\n##########################\n# REQUIRED INPUT ARGUMENTS\n##########################\ndata_directory=$HOME\"/sceptre_data/\"\n# sceptre object\nsceptre_object_fp=$data_directory\"sceptre_object.rds\"\n# response ODM\nresponse_odm_fp=$data_directory\"gene.odm\"\n# grna ODM\ngrna_odm_fp=$data_directory\"grna.odm\"\n\n###################\n# OUTPUT DIRECTORY:\n##################\noutput_directory=$HOME\"/sceptre_outputs\"\n\n#################\n# Invoke pipeline\n#################\nnextflow run timothy-barry/sceptre-pipeline -r main -resume \\\n --sceptre_object_fp $sceptre_object_fp \\\n --response_odm_fp $response_odm_fp \\\n --grna_odm_fp $grna_odm_fp \\\n --output_directory $output_directory \\\n --pair_pod_size 1000 \\\n --grna_pod_size 25 \\\n\n\nFinally, we can launch the full pipeline by calling qsub (or sbatch, depending on the scheduler) on launch_script.sh:\n\n\nterminal, cluster\n\nqsub launch_script.sh\n# or sbatch launch_script.sh\n\nThe outputs are written to ~/sceptre_outputs. (The previous outputs are overwritten.) We can download the output directory onto our local machine as follows.\n\n\nterminal, local\n\nscp -r username@cluster_address:~/sceptre_outputs ~/\n\nAgain, “username” and “cluster_address” should be replaced by one’s username and cluster address, respectively. An exploration of ~/sceptre_outputs on the local machine shows that we have successfully carried out a full trans analysis of the example high-MOI CRISPRi data.",
    "crumbs": [
      "Part II. At-scale sceptre",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to the Nextflow pipeline</span>"
    ]
  },
  {
    "objectID": "at-scale.html#sec-incremental_pipeline",
    "href": "at-scale.html#sec-incremental_pipeline",
    "title": "7  Introduction to the Nextflow pipeline",
    "section": "\n7.9 Stepping through the pipeline incrementally",
    "text": "7.9 Stepping through the pipeline incrementally\nThe sceptre Nextflow pipeline consists of six distinct steps, depicted below.\n\n\n\n\n\n\n\nFigure 7.1: The sceptre Nextflow pipeline\n\n\n\n\nThe Nextflow pipeline is nearly the same as the pipeline introduced in The whole game. The difference is that the “Import data” step is not part of this pipeline (as we import the data into an ondisc-backed sceptre object prior to calling the Nextflow pipeline), and likewise the “Write outputs to directory” step is not part of this pipeline (as the Nextflow pipeline automatically writes results to the output directory at the end of each step). Furthermore, there is some redundancy built into the pipeline with respect to “Set analysis parameters:” users either can set the analysis parameters within the R console before writing the sceptre_object to disk (as described in Section 7.3), or users can specify the analysis parameters on the command line when invoking the Nextflow pipeline. The former typically is easier than the latter.\nWe can advance through the Nextflow pipeline one step at a time by specifying the pipeline_stop argument. pipeline_stop takes six possible values: set_analysis_parameters, assign_grnas, run_qc, run_calibration_check, run_power_check, and run_discovery_analysis. When pipeline_stop is specified, the Nextflow pipeline runs through all the steps of the pipeline up to and including pipeline_stop. For example, if we set pipeline_stop to run_calibration_check, the Nextflow pipeline carries out the steps “Set analysis parameters,” “Assign gRNAs,” “Run quality control,” and “Run calibration check” and then stops. The default value of pipeline_stop is run_discovery_analysis, and so the Nextflow pipeline by default runs through to completion.\nWe provide an example of using the pipeline_stop argument below. This example can be carried out either on the local machine or on the cluster. First, let us remove the ~/sceptre_outputs directory.\n\n\nterminal\n\nrm -r ~/sceptre_outputs\n\nWe modify launch_script.sh, adding the line --pipeline_stop assign_grnas to the script. This line tells Nextflow to stop at the “Assign gRNAs” step.\n\nShow code#!/bin/bash\n# Limit NF driver to 4 GB memory\nexport NXF_OPTS=\"-Xms500M -Xmx4G\"\n\n##########################\n# REQUIRED INPUT ARGUMENTS\n##########################\ndata_directory=$HOME\"/sceptre_data/\"\n# sceptre object\nsceptre_object_fp=$data_directory\"sceptre_object.rds\"\n# response ODM\nresponse_odm_fp=$data_directory\"gene.odm\"\n# grna ODM\ngrna_odm_fp=$data_directory\"grna.odm\"\n\n###################\n# OUTPUT DIRECTORY:\n##################\noutput_directory=$HOME\"/sceptre_outputs\"\n\n#################\n# Invoke pipeline\n#################\nnextflow run timothy-barry/sceptre-pipeline -r main -resume \\\n --sceptre_object_fp $sceptre_object_fp \\\n --response_odm_fp $response_odm_fp \\\n --grna_odm_fp $grna_odm_fp \\\n --output_directory $output_directory \\\n --pair_pod_size 1000 \\\n --grna_pod_size 25 \\\n --pipeline_stop assign_grnas\n\n\nWe then launch the pipeline (via bash launch_script.sh, qsub launch_script.sh, or sbatch launch_script.sh, etc.) and examine the outputs directory. We see (via an inspection of analysis_summary.txt, for example) that “Set analysis parameters” and “Assign gRNAs” have completed, but that the other pipeline steps have not yet run.\nSuppose now that want to run the next step in the pipeline, namely “Run quality control.” To this end, we update launch_script.sh, changing the line --pipeline_stop assign_grnas to --pipeline_stop run_qc. Additionally, we add the line -resume to the launch script. The -resume flag in effect tells Nextflow to skip over all steps preceeding “Run QC” (including “Assign gRNAs”), as these steps already have been run.\n\nShow code#!/bin/bash\n# Limit NF driver to 4 GB memory\nexport NXF_OPTS=\"-Xms500M -Xmx4G\"\n\n##########################\n# REQUIRED INPUT ARGUMENTS\n##########################\ndata_directory=$HOME\"/sceptre_data/\"\n# sceptre object\nsceptre_object_fp=$data_directory\"sceptre_object.rds\"\n# response ODM\nresponse_odm_fp=$data_directory\"gene.odm\"\n# grna ODM\ngrna_odm_fp=$data_directory\"grna.odm\"\n\n###################\n# OUTPUT DIRECTORY:\n##################\noutput_directory=$HOME\"/sceptre_outputs\"\n\n#################\n# Invoke pipeline\n#################\nnextflow run timothy-barry/sceptre-pipeline -r main -resume \\\n --sceptre_object_fp $sceptre_object_fp \\\n --response_odm_fp $response_odm_fp \\\n --grna_odm_fp $grna_odm_fp \\\n --output_directory $output_directory \\\n --pair_pod_size 1000 \\\n --grna_pod_size 25 \\\n --pipeline_stop run_qc \\\n -resume\n\n\n\n\n\n\nNextflow output when the -resume flag is used.\n\n\n\nWe launch the updated pipeline; the terminal is displayed output above. The “Assign gRNAs” step has not been recomputed, as indicated by the “cached” string next to the assign_grnas process. In conclusion, --pipeline_stop and -resume enable us to step through the Nextflow pipeline incrementally, verifying that a given step of the pipeline has run correctly before proceeding to the next step. If a given step of the pipeline produces an unexpected or suboptimal result, we can update the arguments passed to that step of the pipeline to try to improve the result, as described in the next chapter.",
    "crumbs": [
      "Part II. At-scale sceptre",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction to the Nextflow pipeline</span>"
    ]
  },
  {
    "objectID": "pipeline-details.html",
    "href": "pipeline-details.html",
    "title": "\n8  A deeper dive into the Nextflow pipeline\n",
    "section": "",
    "text": "8.1 Cluster architecture and Nextflow pipeline structure\nA computing cluster is of a collection of computers, also known as nodes, that work in concert to carry out a large computation. Figure 8.1 illustrates the structure of a typical computing cluster. The cluster contains dozens or even hundreds of nodes, with each node harboring multiple processors. Processors are the core units that execute code. Furthermore, all nodes are linked to a common storage area where files are kept. For instance, specific data files like gene.odm, grna.odm, and sceptre_object.rds are stored in this shared space.\nThe process of performing a computation on a cluster involves several steps. Initially, each processor loads only the part of the data that it needs for its portion of the overall computation. Then, each processor processes this part of the data and saves the results back to the shared storage area. Once all processors complete their tasks, another processor retrieves these results from the shared space and merges them into a final result. Typically, the processors are spread across different nodes and thus do not directly interact with each other; rather, they coordinate through the shared storage space. This method of distributing tasks among independent processors and later combining their outputs is known as a scatter-gather operation. The sceptre Nextflow pipeline consists of multiple scatter-gather chained together.\nFigure 8.1: A model of the architecture of a standard computing cluster. There are several nodes, each of which contains multiple processors and is connected to the shared storage space. The data — as stored within the gene.odm, grna.odm, and sceptre_object.rds files — are contained in the shared storage space.\nA graph illustrating the flow of information through the sceptre Nextflow pipeline is depicted in Figure 8.2. The steps of the pipeline as outlined in Figure 7.1 (i.e., “set analysis parameters,” “assign gRNAs,” “run quality control,” “run calibration check,” “run power check,” and “run discovery analysis”) are all present in the graph. The computation is parallelized at four points: “assign gRNAs,” “run calibration check,” “run power check,” and “run discovery analysis.” The “assign gRNAs” step is parallelized according to the following scatter-gather strategy. First, the gRNAs are partitioned into p distinct “pods.” For example, if the data contain 100 gRNAs, and if p = 5 pods are in use, then each pod is assigned 20 distinct gRNAs. Next, each pod is mapped to one of p processors, and each processor performs the gRNA-to-cell assignments for the gRNAs within the pod to which it has been assigned. Finally, the gRNA-to-cell assignments are combined across pods, yielding a single binary gRNA-to-cell assignment matrix. The user selects the number of gRNAs to assign to each pod, which in turn determines the number of pods p.\nFigure 8.2: A graph illustrating the flow of information through the sceptre Nextflow pipeline. The pipeline consists of several scatter-gather operations chained together, with parallelization at the gRNA assignment and association testing steps.\nThe “run calibration check,” “run power check,” and “run discovery analysis” steps are parallelized using a similar strategy. First, the target-response pairs are partitioned into r distinct pods. Next, the pods are mapped to r processors, and each processor carries out the target-to-response association tests for the pairs in the pod to which it has been assigned. Finally, the results are combined across pods, and a multiplicity correction (e.g., the BH procedure) is applied to the entire set of p-values. Again, the user selects the number of pairs to assign to each pod, which in turn determines r. In summary the gRNA-to-cell assignments are parallelized at the level of the gRNA, and the target-to-response association tests are parallelized at the level of the target-response pair. (If the “maximum” gRNA assignment strategy is used, then the gRNA-to-cell assignment step is not parallelized. Rather, the gRNA-to-cell assignments are carried out “behind the scenes” as part of the data import step.)",
    "crumbs": [
      "Part II. At-scale sceptre",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A deeper dive into the Nextflow pipeline</span>"
    ]
  },
  {
    "objectID": "pipeline-details.html#sec-anatomy_of_launch_script",
    "href": "pipeline-details.html#sec-anatomy_of_launch_script",
    "title": "\n8  A deeper dive into the Nextflow pipeline\n",
    "section": "\n8.2 Anatomy of a pipeline launch script",
    "text": "8.2 Anatomy of a pipeline launch script\nAn example sceptre Nextflow pipeline launch script is as follows.\n\n\nlaunch_script.sh\n\n#$ -l m_mem_free=4G\n#$ -pe openmp 2\nexport NXF_OPTS=\"-Xms500M -Xmx4G\"\n\n##########################\n# REQUIRED INPUT ARGUMENTS\n##########################\ndata_directory=$HOME\"/sceptre_data/\"\n# sceptre object\nsceptre_object_fp=$data_directory\"sceptre_object.rds\"\n# response ODM\nresponse_odm_fp=$data_directory\"gene.odm\"\n# grna ODM\ngrna_odm_fp=$data_directory\"grna.odm\"\n\n###################\n# OUTPUT DIRECTORY:\n##################\noutput_directory=$HOME\"/sceptre_outputs\"\n\n#################\n# Invoke pipeline\n#################\nnextflow run timothy-barry/sceptre-pipeline -r main \\\n --sceptre_object_fp $sceptre_object_fp \\\n --response_odm_fp $response_odm_fp \\\n --grna_odm_fp $grna_odm_fp \\\n --output_directory $output_directory \\\n --grna_assignment_method mixture \\\n --response_n_umis_range_lower 0.05 \\\n --response_n_umis_range_uppper 0.95 \\\n --grna_integration_strategy singleton \\\n --pair_pod_size 1000 \\\n --grna_pod_size 25 \\\n --combine_assign_grnas_memory 8GB \\\n --combine_assign_grnas_time 5m\n\nWe describe each component of this script line-by-line. The first few lines relate to resource requests for the driver process. We request four gigabytes of memory (#$ -l m_mem_free=4G) and two CPUs (#$ -pe openmp 2) for the driver. Additionally, we specify that the “Java virtual machine” — the application responsible for executing the driver — is to use no fewer than 500 megabytes of memory and no more than to four gigabytes of memory via the line export NXF_OPTS=\"-Xms500M -Xmx4G\". (This line is optional, but it helps prevent the Nextflow driver from using too much memory.) Finally, the scheduler may require us to submit a wall time request, in which case we should include a wall time request at the top of launch_script.sh; the relevant command on SGE is #$ -l h_rt. If we were on a SLURM cluster instead of an SGE cluster, the first few lines of launch_script.sh would look roughly as follows:\n#SBATCH --ntasks=1\n#SBATCH --cpus-per-task=2\n#SBATCH --mem=4G\n#SBATCH --time=05:00:00\nexport NXF_OPTS=\"-Xms500M -Xmx4G\"\nNext, we set the variables sceptre_object_fp, response_odm_fp, and grna_odm_fp to the file paths of the sceptre_object.rds file, the gene.odm file, and the grna.odm file, respectively. We also set output_directory to the file path of the directory in which to write the results. These variables are defined in terms of $HOME as opposed to the shorthand ~, as $HOME contains the absolute file path to the home directory, and Nextflow is more adept at handling absolute file paths than relative file paths.\nFinally, we invoke the Nextflow pipeline via the command nextflow run timothy-barry/sceptre-pipeline -r main. (timothy-barry/sceptre-pipeline is the current location of the sceptre Nextflow pipeline on Github; we plan to move the pipeline into the nf-core repository in the future.) We specify arguments to the pipeline via the syntax --argument value, where argument is the name of an argument and value is the value to assign to the argument. In the above script we organize the arguments such that each argument is on its own line, but this is not necessary. The sceptre pipeline has four required arguments: sceptre_object_fp, response_odm_fp, grna_odm_fp, and output_directory (described above). The pipeline additionally supports a variety of optional arguments. About half of the optional arguments are “statistical” in that they govern how the statistical methods are to be deployed to analyze the data. For example, above, we indicate that the pipeline is to use the “mixture” method to assign gRNAs to cells via --grna_assignment_method. Additionally, we alter the default cellwise QC thresholds via --response_n_umis_range_lower 0.05 and --response_n_umis_range_uppper 0.95. Finally, we indicate that the pipeline is to use the “singleton” gRNA integration strategy via --grna_integration_strategy singleton.\nThe other half of the optional arguments are “computational” in that they control how the computation is organized and executed. For example, we set the gRNA pod size to 25 and the target-response pair pod size to 1,000 via –pair_pod_size 1000 and –-grna_pod_size 25, respectively. (The gRNA pod size and pair pod size correspond to p and r in Figure 8.2). Each process in the pipeline submits a time and memory allocation request to the scheduler. These resource requests are set to reasonable defaults, but we manually can override the defaults for a given process (or processes) on the command line. For example, we request eight gigabytes of memory and five minutes of wall time for the “Combine assign gRNAs” process via –-combine_assign_grnas_memory 8GB and –-combine_assign_grnas_time 5m, respectively.\n\n\n\n\n\n\nTip\n\n\n\nAll of the sceptre Nextflow pipeline arguments are enumerated and described in Section 9.2 of the addendum to Part II of this book. We recommend that users skim through this section and reference it as needed.",
    "crumbs": [
      "Part II. At-scale sceptre",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A deeper dive into the Nextflow pipeline</span>"
    ]
  },
  {
    "objectID": "pipeline-details.html#example-workflows",
    "href": "pipeline-details.html#example-workflows",
    "title": "\n8  A deeper dive into the Nextflow pipeline\n",
    "section": "\n8.3 Example workflows",
    "text": "8.3 Example workflows\nWe describe a few common workflows in the context of the sceptre Nextflow pipeline.\n\n8.3.1 Tweaking the pipeline arguments using the intermediate results\nA common workflow is to advance through the pipeline one step at a time (Section 7.9), adjusting the input arguments as necessary on the basis of the intermediate outputs. For example, suppose that we decide to implement an aggressive cellwise QC strategy, setting --response_n_umis_range_lower and --response_n_umis_range_uppper to0.2 and 0.8, respectively, so as to clip the tails of the response_n_umis distribution at the 20th percentile and 80 percentile. Additionally, we set --pipeline_stop to run_qc to stop the pipeline at the “Run QC” step.\n\nShow code#!/bin/bash\n# Limit NF driver to 4 GB memory\nexport NXF_OPTS=\"-Xms500M -Xmx4G\"\n\n##########################\n# REQUIRED INPUT ARGUMENTS\n##########################\ndata_directory=$HOME\"/sceptre_data/\"\n# sceptre object\nsceptre_object_fp=$data_directory\"sceptre_object.rds\"\n# response ODM\nresponse_odm_fp=$data_directory\"gene.odm\"\n# grna ODM\ngrna_odm_fp=$data_directory\"grna.odm\"\n\n###################\n# OUTPUT DIRECTORY:\n##################\noutput_directory=$HOME\"/sceptre_outputs\"\n\n#################\n# Invoke pipeline\n#################\nnextflow run timothy-barry/sceptre-pipeline -r main \\\n --sceptre_object_fp $sceptre_object_fp \\\n --response_odm_fp $response_odm_fp \\\n --grna_odm_fp $grna_odm_fp \\\n --output_directory $output_directory \\\n --pair_pod_size 1000 \\\n --grna_pod_size 25 \\\n --response_n_umis_range_lower 0.2 \\\n --response_n_umis_range_uppper 0.8 \\\n --pipeline_stop run_qc\n\n\nWe launch the pipeline.\n\n\nterminal\n\nqsub launch.sh # or sbatch or bash, etc.\n\nAn inspection of the “Response N UMIs” panel of plot_covariates.png suggests that we have clipped the tails a too extreme a location.\n\n\n\n\nAggressive cellwise QC strategy.\n\n\n\nThus, we relax the cellwise QC thresholds slightly, setting --response_n_umis_range_lower and --response_n_umis_range_uppper to0.1 and 0.9, respectively. Additionally, we pass the -resume flag to the pipeline to avoid recomputing the gRNA-to-cell assignments.\n\nShow code#!/bin/bash\n# Limit NF driver to 4 GB memory\nexport NXF_OPTS=\"-Xms500M -Xmx4G\"\n\n##########################\n# REQUIRED INPUT ARGUMENTS\n##########################\ndata_directory=$HOME\"/sceptre_data/\"\n# sceptre object\nsceptre_object_fp=$data_directory\"sceptre_object.rds\"\n# response ODM\nresponse_odm_fp=$data_directory\"gene.odm\"\n# grna ODM\ngrna_odm_fp=$data_directory\"grna.odm\"\n\n###################\n# OUTPUT DIRECTORY:\n##################\noutput_directory=$HOME\"/sceptre_outputs\"\n\n#################\n# Invoke pipeline\n#################\nnextflow run timothy-barry/sceptre-pipeline -r main \\\n --sceptre_object_fp $sceptre_object_fp \\\n --response_odm_fp $response_odm_fp \\\n --grna_odm_fp $grna_odm_fp \\\n --output_directory $output_directory \\\n --pair_pod_size 1000 \\\n --grna_pod_size 25 \\\n --response_n_umis_range_lower 0.1 \\\n --response_n_umis_range_uppper 0.9 \\\n --pipeline_stop run_qc \\\n -resume\n\n\nThis approach — i.e., passing a set of candidate arguments to the pipeline, examining the output of the pipeline, and then updating the candidate arguments as necessary — is applicable to all steps of the pipeline.\n\n8.3.2 Debugging the pipeline\nThe Nextflow pipeline may fail. This most commonly occurs when a process has exceeded its time and/or memory allocation. We provide an example of a pipeline failure and show how to resolve the failure. Consider the following submission script, in which we request only one MB of memory for the “Run association analysis” processes.\n\nShow code#!/bin/bash\n# Limit NF driver to 4 GB memory\nexport NXF_OPTS=\"-Xms500M -Xmx4G\"\n\n##########################\n# REQUIRED INPUT ARGUMENTS\n##########################\ndata_directory=$HOME\"/sceptre_data/\"\n# sceptre object\nsceptre_object_fp=$data_directory\"sceptre_object.rds\"\n# response ODM\nresponse_odm_fp=$data_directory\"gene.odm\"\n# grna ODM\ngrna_odm_fp=$data_directory\"grna.odm\"\n\n###################\n# OUTPUT DIRECTORY:\n##################\noutput_directory=$HOME\"/sceptre_outputs\"\n\n#################\n# Invoke pipeline\n#################\nnextflow run timothy-barry/sceptre-pipeline -r main -resume \\\n --sceptre_object_fp $sceptre_object_fp \\\n --response_odm_fp $response_odm_fp \\\n --grna_odm_fp $grna_odm_fp \\\n --output_directory $output_directory \\\n --pair_pod_size 1000 \\\n --grna_pod_size 25 \\\n --run_association_analysis_memory 1MB\n\n\nWe submit this script to the scheduler.\n\n\nterminal, cluster\n\nqsub launch.sh # or sbatch, etc\n\nThe job fails with the following log file.\n\n\n\n\nLog file for failed Nextflow pipeline.\n\n\n\nWe see that there was an error executing the process run_analysis_subworkflow_calibration_check:run_association_analysis, which is the calibration check process. Moreover, the process failed with exit code of 140, which, on an SGE cluster, indicates that the process exceeded its memory allocation. To resolve this issue, we increase the memory request of the “Run association analysis” processes to 4GB, as follows.\n\nShow code#!/bin/bash\n# Limit NF driver to 4 GB memory\nexport NXF_OPTS=\"-Xms500M -Xmx4G\"\n\n##########################\n# REQUIRED INPUT ARGUMENTS\n##########################\ndata_directory=$HOME\"/sceptre_data/\"\n# sceptre object\nsceptre_object_fp=$data_directory\"sceptre_object.rds\"\n# response ODM\nresponse_odm_fp=$data_directory\"gene.odm\"\n# grna ODM\ngrna_odm_fp=$data_directory\"grna.odm\"\n\n###################\n# OUTPUT DIRECTORY:\n##################\noutput_directory=$HOME\"/sceptre_outputs\"\n\n#################\n# Invoke pipeline\n#################\nnextflow run timothy-barry/sceptre-pipeline -r main -resume \\\n --sceptre_object_fp $sceptre_object_fp \\\n --response_odm_fp $response_odm_fp \\\n --grna_odm_fp $grna_odm_fp \\\n --output_directory $output_directory \\\n --pair_pod_size 1000 \\\n --grna_pod_size 25 \\\n --run_association_analysis_memory 4GB\n\n\nNow, the pipeline runs without issue. Determining the exact cause of a pipeline failure may take some sleuthing. In addition to examining the log file associated with the driver process, investigating the specific job that failed — through, e.g., a call to qacct on SGE or sacct on SLURM — can provide helpful information.\n\n8.3.3 Skipping the calibration check\nOne can skip the calibration check and proceed straight to the power check and discovery analysis by setting --n_calibration_pairs to 0, as follows.\n\nShow code#!/bin/bash\n# Limit NF driver to 4 GB memory\nexport NXF_OPTS=\"-Xms500M -Xmx4G\"\n\n##########################\n# REQUIRED INPUT ARGUMENTS\n##########################\ndata_directory=$HOME\"/sceptre_data/\"\n# sceptre object\nsceptre_object_fp=$data_directory\"sceptre_object.rds\"\n# response ODM\nresponse_odm_fp=$data_directory\"gene.odm\"\n# grna ODM\ngrna_odm_fp=$data_directory\"grna.odm\"\n\n###################\n# OUTPUT DIRECTORY:\n##################\noutput_directory=$HOME\"/sceptre_outputs\"\n\n#################\n# Invoke pipeline\n#################\nnextflow run timothy-barry/sceptre-pipeline -r main -resume \\\n --sceptre_object_fp $sceptre_object_fp \\\n --response_odm_fp $response_odm_fp \\\n --grna_odm_fp $grna_odm_fp \\\n --output_directory $output_directory \\\n --pair_pod_size 1000 \\\n --grna_pod_size 25 \\\n --n_calibration_pairs 0",
    "crumbs": [
      "Part II. At-scale sceptre",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A deeper dive into the Nextflow pipeline</span>"
    ]
  },
  {
    "objectID": "pipeline-details.html#sec-massive_scale_trans_analysis",
    "href": "pipeline-details.html#sec-massive_scale_trans_analysis",
    "title": "\n8  A deeper dive into the Nextflow pipeline\n",
    "section": "\n8.4 Massive-scale trans analysis",
    "text": "8.4 Massive-scale trans analysis\nThe sceptre Nextflow pipeline provides a special option for carrying out a massive-scale trans analysis in which each target is tested for association against each response. We call this special option the trans interface to the pipeline. The trans interface is an appropriate strategy for conducting a trans analysis when the number of trans pairs (i.e., the number of targets times the number of responses) exceeds 10 million, which is the maximum number of pairs that the standard interface to the Nextflow pipeline (as described in Section 7.1 — Section 7.8) can handle.\n\n8.4.1 Software installation\nThe trans interface to the pipeline depends on the arrow R package. arrow is a package for efficiently storing and manipulating large R data frames. We use arrow to store the results data frame (i.e., the data frame containing the p-values, estimated log fold changes, etc.). We recommend installing arrow both locally and on the cluster. Users can use the standard install.packages() function to install arrow locally.\n\n\nR, local\n\ninstall.packages(\"arrow\")\n\nUsers can install arrow on the cluster as follows.\n\n\nR, cluster\n\nSys.setenv('NOT_CRAN' = 'true')\ninstall.packages('arrow', repos='http://cran.us.r-project.org')\n\n\n8.4.2 Pipeline structure\nFigure 8.3 displays the flow of information through the Nextflow pipeline in the context the trans interface. The trans interface differs from the standard interface (as depicted in Figure 8.2) in several ways. First, the trans interface does not involve carrying out a calibration check. (Indeed, we typically are less concerned about stringent calibration of the p-values far out into the tail of the distribution in the context of a massive-scale trans analysis.) Next, the trans interface does not distinguish between positive control pairs and discovery pairs; rather, all target-response pairs are analyzed as part of the discovery analysis step. Moreover, the trans interface separates cellwise QC from pairwise QC; cellwise QC is carried out immediately after the gRNA assignment step, while pairwise QC is performed as part of the discovery analysis step. Finally, the trans interface is parallelized at two points: the gRNA assignment step and the discovery analysis step.\n\n\n\n\n\n\n\nFigure 8.3: A graph illustrating the flow of information through the Nextflow pipeline in the context of a massive-scale trans analysis.\n\n\n\n\n\n8.4.3 Preparing and launching a massive-scale trans analysis\nUsing the trans interface to the Nextflow pipeline is similar to using the standard interface. In particular, one proceeds through the sequence of steps as outlined in sections Section 7.1 — Section 7.8, with two small modifications. First, in setting the analysis parameters within the R console (Section 7.3), one does not specify a set of discovery pairs or positive control pairs to analyze. Rather, one leaves these arguments blank, as follows.\n\nsceptre_object &lt;- set_analysis_parameters(\n  sceptre_object = sceptre_object,\n  side = \"both\",\n  resampling_mechanism = \"permutations\"\n)\n\n(If one does specify a discovery pairs data frame or a positive control pairs data frame, these data frames are ignored.) Second, when invoking the Nextflow pipeline on the command line, one sets --discovery_pairs to trans, which tells the pipeline to run a trans discovery analysis. An example launch script is as follows. (See final line.)\n\nShow code#!/bin/bash\n# Limit NF driver to 4 GB memory\nexport NXF_OPTS=\"-Xms500M -Xmx4G\"\n\n##########################\n# REQUIRED INPUT ARGUMENTS\n##########################\ndata_directory=$HOME\"/sceptre_data/\"\n# sceptre object\nsceptre_object_fp=$data_directory\"sceptre_object.rds\"\n# response ODM\nresponse_odm_fp=$data_directory\"gene.odm\"\n# grna ODM\ngrna_odm_fp=$data_directory\"grna.odm\"\n\n###################\n# OUTPUT DIRECTORY:\n##################\noutput_directory=$HOME\"/sceptre_outputs\"\n\n#################\n# Invoke pipeline\n#################\nnextflow run timothy-barry/sceptre-pipeline -r main \\\n --sceptre_object_fp $sceptre_object_fp \\\n --response_odm_fp $response_odm_fp \\\n --grna_odm_fp $grna_odm_fp \\\n --output_directory $output_directory \\\n --discovery_pairs trans\n\n\nFinally, one launches the pipeline as normal:\n\n\nterminal, local or cluster\n\nqsub launch_script.sh\n# or sbatch launch_script.sh\n\nThe --pipeline_stop argument takes four values in the context of the trans interface: set_analysis_parameters, assign_grnas, run_qc, and run_discovery_analysis. (run_power_check and run_discovery_analysis are not available as options.)\n\n8.4.4 Working with the outputs\nThe outputs of the pipeline are written to output_directory, which, in the above script, is set to ~/sceptre_outputs. We used the trans interface to the Nextflow pipeline to conduct a trans analysis of one of the datasets published in Replogle et al. (2022). In particular, we analyzed the so-called “rd7” dataset, which contains 616,184 cells, 36,601 genes, and 5,086 targeting gRNAs spread across 2,384 genomic targets. (The code used to analyze these data is not shown in this book.) Upon completing the analysis, the Nextflow pipeline writes the following files to the ~/sceptre_outputs directory.\n\nlist.files(\"~/sceptre_outputs\")\n\n\n\n[1] \"analysis_summary.txt\"              \"plot_covariates.png\"              \n[3] \"grna_assignment_matrix.rds\"        \"plot_grna_count_distributions.png\"\n[5] \"plot_assign_grnas.png\"             \"trans_results\"                    \n[7] \"plot_cellwise_qc.png\"              \"response_to_pod_map.rds\"          \n\n\nThe files contained within this directory are similar to those outputted by the standard interface. In particular, analysis_summary.txt is a text file summarizing the analysis, grna_assignment_matrix.rds is a sparse, logical matrix containing the gRNA-to-cell assignments, etc. The trans interface to the pipeline does not (currently) render plots corresponding to the calibration check, power check, or discovery analysis. (Indeed, the trans interface does not carry out a calibration check or a dedicated positive control analysis, and the discovery analysis might be so large that the corresponding plot is challenging to render.)\nThe results of the discovery analysis are stored within the subdirectory trans_results. The results are distributed across multiple parquet files, which is the file type used by the arrow package to store data. We print a few of the parquet files below.\n\nlist.files(\"~/sceptre_outputs/trans_results\") |&gt; head(10)\n\n\n\n [1] \"result_1.parquet\"  \"result_10.parquet\" \"result_11.parquet\"\n [4] \"result_13.parquet\" \"result_14.parquet\" \"result_15.parquet\"\n [7] \"result_16.parquet\" \"result_17.parquet\" \"result_18.parquet\"\n[10] \"result_19.parquet\"\n\n\nEach parquet file stores the results for a distinct set of target-response pairs. The simplest way to interact with the results is to call the arrow function open_dataset() on the “trans_results” directory, as follows.\n\nlibrary(arrow)\nlibrary(dplyr)\nds &lt;- open_dataset(\"~/sceptre_outputs/trans_results/\")\n\nds is an object of class \"FileSystemDataset\", which is an arrow class representing a data frame stored on-disk (as opposed to in-memory). We can interact with ds as if it were a standard R data frame using the dplyr verbs. For example, a common operation is to obtain the p-value and log fold change for all pairs containing a given target. We can do this as follows.\n\nds |&gt;\n  filter(grna_target == \"ENSG00000094914\") |&gt; \n  select(p_value, log_2_fold_change, response_id) |&gt;\n  arrange(p_value) |&gt;\n  collect() |&gt;\n  head()\n\n\n\n      response_id      p_value log_2_fold_change\n1 ENSG00000183833 2.636215e-05         2.3685055\n2 ENSG00000103037 3.272519e-05         1.4391586\n3 ENSG00000106034 8.000000e-05         2.6024898\n4 ENSG00000213015 9.815693e-05         0.4922026\n5 ENSG00000100097 1.034180e-04         0.1332239\n6 ENSG00000067560 1.911778e-04         0.2658772\n\n\nThe converse operation is to obtain the p-value and log fold change for all pairs containing a given response. We can do that as follows.\n\nds |&gt;\n  filter(response_id == \"ENSG00000130024\") |&gt; \n  select(p_value, log_2_fold_change, grna_target) |&gt;\n  arrange(p_value) |&gt;\n  collect() |&gt;\n  head()\n\n\n\n      grna_target      p_value log_2_fold_change\n1 ENSG00000120948 1.627334e-09         0.3498972\n2 ENSG00000165819 3.809799e-07        -1.3201363\n3 ENSG00000175390 8.907555e-06         2.1186307\n4 ENSG00000110713 4.895796e-05         0.9468392\n5 ENSG00000146457 5.699367e-05        -0.6973474\n6 ENSG00000110321 7.144978e-05         0.7306015\n\n\nThe final verb in the chain of verbs always should be collect(), which tells arrow to load the data frame into memory. Finally, we can load an individual parqet file into memory as a standard R data frame using the read_parquet() function. The file response_to_pod_map.rds — stored within the output directory — contains a data frame mapping each response to the .parquet file that contains the results for pairs consisting of that response.\n\nresult_1 &lt;- read_parquet(\n  \"~/sceptre_outputs/trans_results/result_1.parquet\"\n  )\n\nWe recommend that users consult the dplyr package and arrow package for more information on interracting with an arrow data frame using dplyr verbs.\n\n\n\n\n\n\nNote\n\n\n\nThe trans interface to the Nextflow pipeline does not perform a multiplicity correction on the p-values. In particular, the p-values in the results data frame are unadjusted, and the results data frame does not contain a column significant indicating whether a given pair has been called as significant. Additionally, the set_analysis_parameter() arguments multiple_testing_method and multiple_testing_alpha are ignored.\n\n\n\n\n\n\nReplogle, Joseph M, Reuben A Saunders, Angela N Pogson, Jeffrey A Hussmann, Alexander Lenail, Alina Guna, Lauren Mascibroda, et al. 2022. “Mapping Information-Rich Genotype-Phenotype Landscapes with Genome-Scale Perturb-Seq.” Cell 185 (14): 2559–75.",
    "crumbs": [
      "Part II. At-scale sceptre",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A deeper dive into the Nextflow pipeline</span>"
    ]
  },
  {
    "objectID": "pipeline-args.html",
    "href": "pipeline-args.html",
    "title": "9  Addendum: Nextflow installation, pipeline arguments",
    "section": "",
    "text": "9.1 Downloading, installing, and configuring Nextflow\nNextflow is a powerful and increasingly popular tool for orchestrating complex bioinformatic workflows. Users will need to install Nextflow on their local machine and on their cluster to work through the examples in this book. We encourage users to consult the extensive and high-quality Nextflow documentation for guidance on using Nextflow. Here, we briefly describe how to download, install, and configure Nextflow. Users should carry out the following sequence of steps twice: once on their local machine and once on their cluster.",
    "crumbs": [
      "Part II. At-scale sceptre",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Addendum: Nextflow installation, pipeline arguments</span>"
    ]
  },
  {
    "objectID": "pipeline-args.html#sec-install_nextflow",
    "href": "pipeline-args.html#sec-install_nextflow",
    "title": "9  Addendum: Nextflow installation, pipeline arguments",
    "section": "",
    "text": "9.1.1 Download and installation\n\nInstall SDKMAN!, a system for installing and managing software.\n\n\n\nterminal\n\ncurl -s \"https://get.sdkman.io\" | bash\n\n\nClose and open a new instance of terminal. Install Java. Nextflow requires a specific distribution of Java, which can be installed as follows.\n\n\n\nterminal\n\nsdk install java 17.0.6-amzn\n\nIf this fails, try the following instead.\n\n\nterminal\n\nsdk install java 17.0.6-tem\n\nYou can ensure that Java is installed via the following command.\n\n\nterminal\n\njava -version \n\nYou should see something like the output below. Ensure that the version of Java (as printed on the first line of the output) is greater than or equal to 17.0.0. (Note: the minimum version of Java required by Nextflow may have increased since the time of writing.)\n\n\nterminal\n\nopenjdk version \"17.0.6\" 2023-01-17 LTS\nOpenJDK Runtime Environment Corretto-17.0.6.10.1 (build 17.0.6+10-LTS)\nOpenJDK 64-Bit Server VM Corretto-17.0.6.10.1 (build 17.0.6+10-LTS, mixed mode, sharing)\n\n\nCreate a directory in which to store the Nextflow executable. We create a directory called bin in our home directory for this purpose, although the Nextflow executable can be stored in any directory.\n\n\n\nterminal\n\nmkdir -p ~/bin\n\n\nClose and open a new instance of terminal. Change directories to ~/bin and intall the Nextflow binary.\n\n\n\nterminal\n\ncd ~/bin\nwget -qO- https://get.nextflow.io | bash\n# alternately: curl -s https://get.nextflow.io | bash\n\nThis creates a binary called nextflow in the current directory.\n\nMake the nextflow binary an executable by running the following command.\n\n\n\nterminal\n\nchmod +x nextflow\n\n(Note: The installed binary may already be executable; in this case chmod does nothing.)\n\nAdd nextflow to your linux path. One way to do this is as follows. First, open .bash_profile (via, for example, nano ~/.bash_profile). Next, add the following line to .bash_profile: export PATH=\"~/bin/:$PATH\". Finally, save .bash_profile, close the terminal, and open a new terminal. When you enter nextflow -version on the command line, you should see an output similar to the following.\n\n\n\nterminal\n\nN E X T F L O W\nversion 23.10.1 build 5891\ncreated 12-01-2024 22:01 UTC (17:01 EDT)\ncite doi:10.1038/nbt.3820\nhttp://nextflow.io\n\nThis indicates that Nextflow has been installed successfully.\n\n9.1.2 Configuration\nNextflow should work without further configuration on a local machine. Configuring Nextflow to run on a cluster is somewhat more involved. First, create a Nextflow config file, which is a file that specifies how Nextflow is to interact with the scheduler on your cluster.\n\n\nterminal, cluster\n\ntouch ~/.nextflow/config\n\nThe following is an example of a basic Nextflow config file.\n\n\n~/.nextflow/config\n\nprocess.executor = 'sge' # or 'slurm', etc.\nexecutor.queueSize = 100\nexecutor.submitRateLimit = '25 sec'\nworkDir = 'path/to/directory/work'\nprocess.queue = 'name of queue'\n\nprocess.executor specifies the type of scheduler that your cluster uses. Options include 'sge' for a Sun Grid Engine (i.e., qsub-based) scheduler and 'slurm' for a SLURM (i.e., sbatch-based) scheduler. Next, executor.queueSize specifies the maximum number of jobs that can be queued simultaneously. Moreover, executor.submitRateLimit specifies the maximum number of jobs that can be submitted per unit time to the scheduler. For example, '25 sec' limits the submission rate to 25 jobs per second. Additionally, workDir is a file path to the “work” directory, which is a directory that stores intermediate files. It is reasonable to create the “work” directory as a subdirectory of the dedicated “data” directory on your cluster. Finally, it may be necessary to specify a the name of a queue (or partition) in which to run the jobs via the process.queue option.\nLike many Nextflow pipelines, the sceptre Nextflow pipeline uses the time and memory process directives to request a given amount of wall time and memory per process. Not all schedulers require that the user issue a wall time and/or memory allocation request when submitting a job. However, if your scheduler has this requirement, then Nextflow should be configured on your cluster such that the scheduler recognizes the time and memory process directives within a Nextflow script. It may be necessary to manually configure these directives using the process.clusterOptions setting within your Nextflow config file. For example, on an SGE scheduler, you may need to add the following line to your ~/.nextflow/config file to ensure that the scheduler correctly handles memory allocation requests.\nprocess.clusterOptions = { task.memory ? \"-l m_mem_free=${task.memory.toGiga()}G\" : \"\" }\nThe corresponding command for a SLURM scheduler is as follows.\nprocess.clusterOptions = { task.memory ? \"--mem=${task.memory.toGiga()}G\" : \"\" }\nConfiguring Nextflow on a given cluster often takes a bit of effort, but fortunately, this task only needs to be completed once. For help with Nextflow configuration, we recommend reading through the Nextflow documentation, contacting a cluster administrator, pinging the (very helpful and responsive) Nextflow community (for example on Github issues), or consulting with ChatGPT (seriously; it seems to know a lot about Nextflow). Finally, a couple helpful blog posts on the Nextflow website are located here and here.",
    "crumbs": [
      "Part II. At-scale sceptre",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Addendum: Nextflow installation, pipeline arguments</span>"
    ]
  },
  {
    "objectID": "pipeline-args.html#sec-nf_pipeline_args",
    "href": "pipeline-args.html#sec-nf_pipeline_args",
    "title": "9  Addendum: Nextflow installation, pipeline arguments",
    "section": "\n9.2 Arguments to the Nextflow pipeline",
    "text": "9.2 Arguments to the Nextflow pipeline\nWe enumerate and describe each of the command line arguments that can be passed to the sceptre Nextflow pipeline. We partition the arguments into “statistical” (Section 9.2.1) and “computational” (Section 9.2.2) categories.\n\n9.2.1 Statistical arguments\nWithin the “statistical” category, we further divide the arguments into subcategories based on the step within the pipeline to which the argument applies.\nInput/output parameters\nThese basic parameters relate to the inputs and outputs of the pipeline. File paths should be absolute rather than relative. (Thus, users should specify file paths in terms of $HOME rather than the shorthand ~.)\n\n--sceptre_object_fp: file path to the sceptre_object.rds file.\n–-response_odm_fp: file path to the .odm file corresponding to the response modality (typically gene.odm).\n–-grna_odm_fp: file path to the grna.odm file.\n–-output_directory: file path to the directory in which to write the outputs.\n--pipeline_stop: the step at which to stop the pipeline, one of set_analysis_parameters, assign_grnas, run_qc, run_calibration_check, run_power_check, or run_discovery_analysis. If not supplied, defaults to run_discovery_analysis, causing the pipeline to run through to completion. (The available options in the context of a massive-scale trans analysis are set_analysis_parameters, assign_grnas, run_qc, and run_discovery_analysis.)\n--trial: a flag that tells Nextflow to run the trial pipeline (as opposed to the full pipeline).\n\nSet analysis parameters\nUsers can set the analysis parameters within the R console as part of the data import step (Section 7.3) or on the command line via the following arguments. Analysis parameters set on the command line take precedence over those set within the R console.\n\n--side: the sidedness of the statistical test, one of left, right, or both (see Section 2.3).\n--grna_integration_strategy: the gRNA integration strategy, one of union, singleton, or bonferroni (see Section 2.4).\n--control_group: the control group for the association test, one of nt_cells or complement (see Section 2.5).\n--formula_object: the formula to adjust for the covariates in the association analysis (see Section 2.6). formula_object should be a file path to an RDS file containing a formula object. For example, below, we create the formula object formula(~response_n_umis + response_n_nonzero) and save this formula object to the file ~/formula_object.rds.\n\n\n\nterminal\n\nRscript -e \"x &lt;- formula(~response_n_umis + response_n_nonzero);\n            saveRDS(x, '~/formula_object.rds')\"\n\nWe then can pass this formula object as an argument to the pipeline via --formula_object $HOME\"/formula_object.rds\".\n\n--resampling_approximation: the approximation to use to the null distribution of test statistics, one of skew_normal or no_approximation (see Section 2.8).\n--multiple_testing_method: the multiple testing correction procedure to adjust the p-values, one of BH, bonferroni, holm, hochberg, hommel, BY, fdr, or none (see Section 2.9).\n--multiple_testing_alpha: the nominal level of the multiple testing procedure. multiple_testing_alpha should a number in the interval [0,1] (for example 0.1 or 0.05; see Section 2.9).\n\n--discovery_pairs: the discovery pairs to analyze (see Section 2.2). discovery_pairs should be a file path to an RDS file containing the discovery pairs. Below, we create a discovery pairs data frame and save this data frame to the file ~/discovery_pairs.rds.\n  Rscript -e \"x &lt;- data.frame(grna_target = c('candidate_enh_1', 'candidate_enh_2'),\n                              response_id = c('ENSG00000174529', 'ENSG00000143493'));\n              saveRDS(x, '~/discovery_pairs.rds')\"\nWe then can pass this argument to the pipeline via --discovery_pairs $HOME\"/discovery_pairs.rds\". To run a massive-scale trans analysis, users should pass --discovery_pairs trans; see Section 8.4 for details.\n\n--positive_control_pairs: the positive control pairs to analyze (see Section 2.1). This argument works similarly to the discovery_pairs argument.\n\nAssign gRNAs\nThe most important argument related to gRNA assignment is grna_assignment_method:\n\n\n--grna_assignment_method: a string indicating the gRNA assignment method (one of mixture, maximum, or thresholding).\n\nThe following arguments pertain to the “mixture” assignment strategy (see Section 3.3.1).\n\n--n_em_rep: the number of times to run the EM algorithm over randomly initialized starting values. n_em_rep should be a positive integer (e.g., 5 or 15).\n--n_nonzero_cells_cutoff: the number of cells that must contain nonzero expression of the gRNA to attempt fitting the mixture model. n_nonzero_cells_cutoff should be a positive integer.\n--backup_threshold: the threshold to use to assign the gRNA to cells if the mixture model fails. backup_threshold should be a positive integer.\n--probability_threshold: the value at which the posterior perturbation probability of each cell is thresholded to assign the gRNA to cells. probability_threshold should be a number in the interval [0,1] (for example 0.5 or 0.8).\n--grna_assignment_formula: the formula to adjust for covariates in the gRNA mixture model. This argument works similarly to the formula_object argument (described above).\n\nThe following two arguments relate to the “maximum” assignment strategy (Section 3.3.2).\n\n--umi_fraction_threshold: a cell is flagged as containing multiple gRNAs if the maximally expressed gRNA constitutes less than umi_fraction_threshold of the UMIs in that cell. umi_fraction_threshold should be a number in the interval [0,1].\n--min_grna_n_umis_threshold: a cell is flagged as containing zero gRNAs if the total UMI count across gRNAs (i.e., n_grna_umis) in that cell is less than min_grna_n_umis_threshold. min_grna_n_umis_threshold should be a non-negative integer.\n\nThe final argument relates to the “thresholding” assignment method (Section 3.3.3).\n\n\n--threshold: the threshold used to assign gRNAs to cells in the context of the thresholding method. threshold should be a positive integer.\n\nRun quality control\nThe following five arguments relate to cellwise QC (see Section 4.2.1). All of these arguments should be supplied as a number in the interval [0,1] (for example 0.01 or 0.05).\n\n--response_n_umis_range_lower: a percentile indicating the location at which to clip the left tail of the response_n_umis distribution.\n--response_n_umis_range_upper: a percentile indicating the location at which to clip the right tail of the response_n_umis distribution.\n--response_n_nonzero_range_lower: a percentile indicating the location at which to clip the left tail of the response_n_nonzero distribution.\n--response_n_nonzero_range_upper: a percentile indicating the location at which to clip the right tail of the response_n_nonzero distribution.\n--p_mito_threshold: an absolute number (i.e., not a percentile) indicating the location at which to clip the right tail of the response_p_mito distribution.\n\nThe following two arguments relate to pairwise QC (see Section 4.2.2). Both arguments should be supplied as a non-negative integer (for example 7 or 10).\n\n--n_nonzero_trt_thresh: the minimum number of nonzero treatment cells that a pair must contain to be retained.\n--n_nonzero_cntrl_thresh: the minimum number of nonzero control cells that a pair must contain to be retained.\n\nRun calibration check\nTwo arguments control the calibration check analysis (see Section 5.2).\n\nn_calibration_pairs: the number of negative control target-response pairs to analyze within the calibration check. n_calibration_pairs should be a non-negative integer. Setting n_calibration_pairs to 0 skips the calibration check.\ncalibration_group_size: the number of individual negative control gRNAs to combine to form a negative control target. calibration_group_size should be a positive integer.\n\n9.2.2 Computational arguments\nWithin the “computational” category, we further divide the arguments into subcategories based on whether the argument relates to parallelization, wall time requests, or memory requests.\nDegree of parallelization\nTwo arguments that control the degree of parallelization: grna_pod_size and pair_pod_size. The former argument relates to the gRNA-to-cell assignment step, and the latter argument relates to the target-to-response association testing steps (i.e., the calibration check, the power check, and the discovery analysis).\n\n--grna_pod_size: the number of gRNAs to assign to each pod. Setting grna_pod_size to a large number (e.g., 500) reduces the amount of parallelization, while setting grna_pod_size to a small number (e.g., 10) increases the amount of parallelization. By default grna_pod_size is set to 150. grna_pod_size should be a positive integer.\n--pair_pod_size: the number of target-response pairs to assign to each pod for each of the association analyses (i.e., calibration check, power check, and discovery analysis). Setting pair_pod_size to a large (resp., small) number reduces (resp., increases) the amount of parallelization. By default pair_pod_size is set to 25000 (500000 for a massive-scale trans analysis). pair_pod_size should be a positive integer.\n\nWall time requests\nEach process within the sceptre Nextflow pipeline submits a wall time request to the scheduler. The wall time requests are set to conservative defaults, and most users will not need to interact with parameters related to time allocation. However, users may need to increase the wall time request of a given process if that process has been killed by the scheduler because it exceeded its time limit. Conversely, users might find that a given process spends too much time in the queue, in which case users might consider decreasing the wall time request of that process so as to increase its priority. All arguments related to time allocation should be supplied in the format Xu, where X is a positive number and u is a unit of time. For example 5s, 5m, and 5h indicate five seconds, five minutes, and five hours, respectively.\n\n--set_analysis_parameters_time: the amount of time requested for the “Set analysis parameters” process; default 15m (i.e., 15 minutes).\n--prepare_assign_grnas_time: the amount of time requested for the “Prepare assign gRNAs” process; default 15m.\n--assign_grnas_time_per_grna: the amount of time requested per gRNA for the “Assign gRNAs” process; default 2s. assign_grnas_time_per_grna and grna_pod_size are multiplied to calculate the total amount of time requested for the “Assign gRNAs” process. For example, if assign_grnas_time_per_grna is set to 5s, and if grna_pod_size is set to 200, then 1000 seconds (i.e., ~17 minutes) is requested for the “Assign gRNAs” process.\n--combine_assign_grnas_time: the amount of time requested for the “Combine assign gRNAs” process; default 15m.\n--run_qc_time: the amount of time requested for the “Run QC” process; default 60m.\n--prepare_association_analysis_time: the amount of time requested for the “Prepare association analysis” process; default 15m.\n--run_association_analysis_time_per_pair: the amount of time requested per pair for the “Run calibration check,” “Run power check,” and “Run discovery analysis” processes; default 0.05s. run_association_analysis_time_per_pair and pair_pod_size are multiplied to calculate the total amount of time requested for the association analysis processes.\n--combine_association_analysis_time: the amount of time requested for the “Combine calibration check,” “Combine power check,” and “Combine discovery analysis” processes; default 15m.\n\nMemory requests\nEach process within the Nextflow pipeline likewise submits a memory request to the scheduler. Again, the memory requests are set to conservative defaults. However, users may need to increase the memory request of a given process if that process has been killed because it ran out of memory. Arguments related to memory allocation should be provided in the format Yu, where Y is a number and u is a unit of data size. For example, 5GB and 5MB denote five gigabytes and five megabytes, respectively.\n\n--set_analysis_parameters_memory: the amount of memory requested for the “Set analysis parameters” process; default 4GB (i.e., four gigabytes).\n--prepare_assign_grnas_memory: the amount of memory requested for the “Prepare assign gRNAs” process; default 4GB.\n--assign_grnas_memory: the amount of memory requested for the “Assign gRNAs” process; default 4GB.\n--combine_assign_grnas_memory: the amount of memory requested for the “Combine assign gRNAs” process; default 4GB.\n--run_qc_memory: the amount of memory requested for the “Run QC” process; default 8GB (4GB when running a massive-scale trans analysis).\n--prepare_association_analysis_memory: the amount of memory requested for the “Prepare association analysis” process; default 4GB.\n--run_association_analysis_memory: the amount of memory requested for the “Run association analysis” processes; default 4GB.\n--combine_association_analysis_memory: the amount of memory requested for the “Combine association analysis” processes; default 4GB.\n\nMiscellaneous\n\n\n--use_parquet: a boolean (i.e., true or false) indicating whether to write the results as parquet files (true) or RDS files (false) in the context of a massive-scale trans analysis (Section 8.4).",
    "crumbs": [
      "Part II. At-scale sceptre",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Addendum: Nextflow installation, pipeline arguments</span>"
    ]
  },
  {
    "objectID": "pipeline-args.html#sec-analyze_odm_within_r",
    "href": "pipeline-args.html#sec-analyze_odm_within_r",
    "title": "9  Addendum: Nextflow installation, pipeline arguments",
    "section": "\n9.3 Analyzing an ondisc-backed sceptre_object within the R console",
    "text": "9.3 Analyzing an ondisc-backed sceptre_object within the R console\nUsers can analyze an ondisc-backed sceptre_object within the R console (as opposed to via the Nextflow pipeline). This solution is most appropriate when the data are big but the number of target-response pairs to be analyzed is not too large. Below, we use the function import_data_from_cellranger() (setting use_ondisc to TRUE) to create an ondisc-backed sceptre_object containing the example high-MOI data. We then proceed through a minimal version of the pipeline normally.\n\n# create an ondisc-backed sceptre object\nlibrary(sceptre)\nlibrary(sceptredata)\ndirectories &lt;- paste0(\n  system.file(\"extdata\", package = \"sceptredata\"),\n  \"/highmoi_example/gem_group_\", 1:2\n)\ndata(grna_target_data_frame_highmoi)\nsceptre_object &lt;- import_data_from_cellranger(\n  directories = directories,\n  moi = \"high\",\n  grna_target_data_frame = grna_target_data_frame_highmoi,\n  use_ondisc = TRUE,\n  directory_to_write = tempdir()\n)\n\n# apply the pipeline functions to the sceptre_object in order\ndiscovery_pairs &lt;- construct_cis_pairs(sceptre_object)\nsceptre_object &lt;- sceptre_object |&gt;\n  set_analysis_parameters(discovery_pairs = discovery_pairs,\n                          resampling_mechanism = \"permutations\") |&gt;\n  run_discovery_analysis()\n\nNext, to analyze the example low-MOI CRISPRko data, we first create an ondisc-backed sceptre_object from a collection of R objects via the function import_data() (setting use_ondisc to TRUE). We then proceed through the pipeline in the standard way.\n\ndata(lowmoi_example_data)\nsceptre_object &lt;- import_data(\n  response_matrix = lowmoi_example_data$response_matrix,\n  grna_matrix = lowmoi_example_data$grna_matrix,\n  extra_covariates = lowmoi_example_data$extra_covariates,\n  grna_target_data_frame = lowmoi_example_data$grna_target_data_frame,\n  moi = \"low\",\n  use_ondisc = TRUE,\n  directory_to_write = tempdir()\n)\n\n# apply the pipeline functions to the sceptre_object in order\ndiscovery_pairs &lt;- construct_trans_pairs(sceptre_object)\nsceptre_object &lt;- sceptre_object |&gt;\n  set_analysis_parameters(discovery_pairs = discovery_pairs) |&gt;\n  run_discovery_analysis()\n\nSee Section 1.5 for more information about creating an ondisc-backed sceptre_object.",
    "crumbs": [
      "Part II. At-scale sceptre",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Addendum: Nextflow installation, pipeline arguments</span>"
    ]
  },
  {
    "objectID": "glossary.html",
    "href": "glossary.html",
    "title": "Appendix A — Glossary",
    "section": "",
    "text": "A.1 Assay design\nThe following terms describe the design of pooled single-cell CRISPR screen assays, where the goal is to perturb a set of genomic targets and measure the effects of these perturbations on a set of molecular phenotypes.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Glossary</span>"
    ]
  },
  {
    "objectID": "glossary.html#assay-design",
    "href": "glossary.html#assay-design",
    "title": "Appendix A — Glossary",
    "section": "",
    "text": "Perturbation: A change to the genome of a cell carried out by the CRISPR-Cas9 system or one of its variants. Common perturbations include CRISPRko (knockout via nuclease-active Cas9), CRISPRi (inactivation via dCas9 tethered to a repressive domain), CRISPRa (activation via dCas9 tethered to an activating domain).\nGuide RNA (gRNA): An RNA guiding the Cas9 (or one of its variants) to its target in order to perturb it.\nTarget: The genomic element targeted by a gRNA. Possible targets include gene transcription start sites and noncoding elements such as enhancers, silencers, and noncoding GWAS variants. Typically, multiple gRNAs are designed to perturb a given target.\nTargeting gRNA: A gRNA that is intended to perturb a genomic target.\nNon-targeting gRNA: A gRNA whose barcode sequence either does not map anywhere in the genome or maps to a location whose perturbation is known to have no effect. Non-targeting gRNAs serve as negative controls.\nResponse: A molecular phenotype readout in the single-cell CRISPR screen, whose response to CRISPR perturbation is of interest. Possible responses include genes, proteins, and chromatin-derived features.\nMultiplicity of infection (MOI): The MOI of a screen can be categorized as low or high and also can also be numerically quantified. A high-MOI (respectively, low-MOI) dataset is one in which the experimenter has aimed to insert multiple gRNAs (respectively, a single gRNA) into each cell. Quantitatively, the MOI of a screen is the average number of gRNAs delivered per cell. For example, an MOI of 10 means that on average each cell receives 10 gRNAs.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Glossary</span>"
    ]
  },
  {
    "objectID": "glossary.html#hypothesis-construction",
    "href": "glossary.html#hypothesis-construction",
    "title": "Appendix A — Glossary",
    "section": "\nA.2 Hypothesis construction",
    "text": "A.2 Hypothesis construction\nThe main statistical task in single-cell CRISPR screen analysis is to test hypotheses of the form: Does perturbing a target impact a response? We use the following terminology to describe the construction of such hypotheses.\n\n\nTarget-response pair: A pair consisting of a target and a response. For example, a target-response pair could be a specific enhancer couppled to a specific gene. Each target-response pair corresponds to a hypothesis to be tested: Does perturbing the target impact the response?\nNegative control pair: A target-response pair in which the target consits of one or more non-targeting gRNAs. Negative control pairs are used to assess the calibration of a statistical analysis method.\nPositive control pair: A target-response pair in which the target is a genomic element known to have an effect on the response. For example, a positive control pair may consist a transcription start site coupled to the gene regulated by that transcription start site. Positive control pairs are used to assess the power of a statistical analysis method.\nDiscovery pair: A target-response pair in which the target is a genomic element whose effect on the response is unknown. The main goal of a single-cell CRISPR screen is to search for new associations among discovery pairs.\nCis pair: A target-response pair in which the target and response are located in close proximity on the same chromosome. For example, a cis pair may consist of an enhancer and a gene whose transcription start site is located a few kilobases away.\nTrans pair: A target-response pair for which the target and response are not necessarily located in close proximity or on the same chromosome as one another.\nPairwise quality control: A procedure for filtering out target-response pairs whose data are too sparse to be analyzed reliably. Pairwise quality control is based on metrics that take into account the sparsity of the response variable and the number of cells in which the target has been perturbed.\nCellwise quality control: A procedure for filtering out cells whose data suggest aberrations in the library preparation or sequencing processes. This common step in single-cell sequencing analyses (not just CRISPR screens) is based on metrics like the total number of UMIs detected in a cell and the percentage of UMIs mapping to mitochondrial genes.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Glossary</span>"
    ]
  },
  {
    "objectID": "glossary.html#statistical-methodologies",
    "href": "glossary.html#statistical-methodologies",
    "title": "Appendix A — Glossary",
    "section": "\nA.3 Statistical methodologies",
    "text": "A.3 Statistical methodologies\nThe following terms describe the statistical methodologies used in single-cell CRISPR screen analysis. Their main focus is to compare the responses of cells that have been perturbed with those that have not.\n\nTreatment group: The group of cells for which a given target has been perturbed.\nControl group: A group of cells for which a given target has not been perturbed, which serve as a point of comparison to the treatment group. The control group is typically either the non-targeting set or the complement set; see below.\nNon-targeting set: The set of cells to which only a non-targeting gRNA has been delivered. This is the most common control group for low-MOI screens.\nComplement set: The set of cells for which a given target has not been perturbed (but for which other targets may have been perturbed). This is the most common control group for high-MOI screens.\nCovariate: An unwanted source of variation that may affect (the measurement of) the response and/or the perturbations in a cell. Covariates can be technical (relating to the library preparation or sequencing processes) or biological (relating to the cell itself). Common technical covariates include the sequencing depth of a cell and the number of gRNAs inserted into a cell; common biological covariates include cell cycle stage and cell type.\n\nFormula object: A formula object specifies the covariates and their transformations that should be used adjusted for in a statistical analysis method. An example of a formula object is\n\n~ log(response_n_nonzero) + log(response_n_umis) + response_p_mito + batch\n\n\nResampling: A computer-based procedure for estimating the null distribution of a test statistic that circumvents the use of asymptotic approximations (which may not hold for sparse single-cell data). Resampling procedures include the permutation test and the conditional randomization test (see below).\nPermutation test: A resampling procedure for estimating the null distribution of a test statistic based on permuting the treatment and control labels of the cells and recomputing the test statistic.\nConditional randomization test: A resampling procedure for estimating the null distribution of a test statistic based on randomly reassigning the treatment and control labels of the cells based on their covariate values.\nSkew-normal distribution: A generalization of the Gaussian distribution that has three parameters: a mean parameter, a variance parameter, and a skew parameter. The skew parameter controls the extent to which the distribution is asymmetric relative to a Gaussian distribution.\nMultiple testing procedure: A procedure that inputs a list of p-values for a set of target-response pairs and outputs a subset of these pairs that are deemed to have a statistically significant relationship. The most common multiple testing procedure is the Benjamini-Hochberg procedure, which aims to control the false discovery rate (see below) at a prespecified level, such as 0.1.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Glossary</span>"
    ]
  },
  {
    "objectID": "glossary.html#statistical-properties-and-their-assessment",
    "href": "glossary.html#statistical-properties-and-their-assessment",
    "title": "Appendix A — Glossary",
    "section": "\nA.4 Statistical properties and their assessment",
    "text": "A.4 Statistical properties and their assessment\nThe following terms describe the statistical properties of an analysis method (whether sceptre or otherwise) and how they are assessed. These statistical properties are essential to making reliable conclusions based on single-cell CRISPR screen data.\n\nFalse discovery rate (FDR): The proportion of the statistically significant target-response pairs returned by a multiple testing procedure that are false positives. A high FDR indicates significant contamination by false positives, making the underlying statistical methodology unreliable.\nCalibration: The extent to which the p-values returned by a statistical analysis method are uniformly distributed under the null hypothesis. A well-calibrated method will return p-values that, when processed by a multiple testing procedure, will result in an FDR close to the desired level.\nPower: Otherwise known as sensitivity, power is the ability of a statistical analysis method to detect true associations. For example, a method has high power if it can detect many of the true associations with high probability.\nCalibration check: A procedure for assessing the calibration of a statistical analysis method. A calibration check typically proceeds by applying the method to a set of negative control pairs and then checking the extent to which the resulting p-values are uniformly distributed.\nPower check: A procedure for assessing the power of a statistical analysis method. A power check typically proceeds by applying the method to a set of positive control pairs and then checking the extent to which the resulting p-values are small.\nQQ plot: A plot used to compare the set of p-values outputted by a method to the uniform distribution, which is the null distribution of a well-calibrated method. A QQ plot of the p-values returned by a method for a set of negative control pairs therefore can be used to check the method’s calibration. Visually, a well-calibrated method will produce a QQ plot whose points are close to the diagonal.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Glossary</span>"
    ]
  },
  {
    "objectID": "faq.html",
    "href": "faq.html",
    "title": "Appendix B — Frequently asked questions",
    "section": "",
    "text": "B.1 I am trying to install sceptre, but I am getting an error. What should I do?\nThe first thing to do is to remove any previous installations of sceptre and then try again. First, determine the directory on your computer in which R packages are stored by executing .libPaths() in the R console.\n.libPaths()\n\n[1] \"/Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\"\nNext, within your terminal, cd to this directory and then execute rm -rf sceptre.\nNow, try to install sceptre again.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Frequently asked questions</span>"
    ]
  },
  {
    "objectID": "faq.html#i-am-trying-to-install-sceptre-but-i-am-getting-an-error.-what-should-i-do",
    "href": "faq.html#i-am-trying-to-install-sceptre-but-i-am-getting-an-error.-what-should-i-do",
    "title": "Appendix B — Frequently asked questions",
    "section": "",
    "text": "Terminal\n\ncd /Library/Frameworks/R.framework/Versions/4.2/Resources/library # change me!\nrm -rf sceptre",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Frequently asked questions</span>"
    ]
  },
  {
    "objectID": "faq.html#how-can-i-install-a-previous-version-of-sceptre",
    "href": "faq.html#how-can-i-install-a-previous-version-of-sceptre",
    "title": "Appendix B — Frequently asked questions",
    "section": "\nB.2 How can I install a previous version of sceptre?",
    "text": "B.2 How can I install a previous version of sceptre?\nSee the instructions here.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Frequently asked questions</span>"
    ]
  },
  {
    "objectID": "faq.html#how-can-i-improve-the-speed-of-sceptre",
    "href": "faq.html#how-can-i-improve-the-speed-of-sceptre",
    "title": "Appendix B — Frequently asked questions",
    "section": "\nB.3 How can I improve the speed of sceptre?",
    "text": "B.3 How can I improve the speed of sceptre?\nCreate the file Makevars inside of your ~/.R directory (if it does not yet exist):\n\n\nTerminal\n\ntouch ~/.R/Makevars\n\nAdd the following line to your Makevars file:\n\n\n~/.R/Makevars\n\nCXXFLAGS += -O3 -Wall\n\nThis line tells the C++ compiler to use aggressive optimization in compiling C++ code contained within an R package. Finally, reinstall sceptre from source.\n\n\n\nR\n\ndevtools::install_github(\"katsevich-lab/sceptre\")",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Frequently asked questions</span>"
    ]
  },
  {
    "objectID": "faq.html#sceptre-unexpectedly-crashed-or-sceptre-is-using-an-unexpectedly-large-amount-of-memory-or-taking-an-unexpectedly-long-amount-of-time-to-run.-what-should-i-do",
    "href": "faq.html#sceptre-unexpectedly-crashed-or-sceptre-is-using-an-unexpectedly-large-amount-of-memory-or-taking-an-unexpectedly-long-amount-of-time-to-run.-what-should-i-do",
    "title": "Appendix B — Frequently asked questions",
    "section": "\nB.4 sceptre unexpectedly crashed, or sceptre is using an unexpectedly large amount of memory or taking an unexpectedly long amount of time to run. What should I do?",
    "text": "B.4 sceptre unexpectedly crashed, or sceptre is using an unexpectedly large amount of memory or taking an unexpectedly long amount of time to run. What should I do?\nThe most likely explanation is that something is going wrong with the parallel functionality of the package. Consider setting parallel = FALSE and then trying again. If the situation improves, consider setting parallel = TRUE and setting n_processors to a small number, such as 2 or 3.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Frequently asked questions</span>"
    ]
  },
  {
    "objectID": "faq.html#my-negative-control-p-values-are-miscalibrated.-what-should-i-do",
    "href": "faq.html#my-negative-control-p-values-are-miscalibrated.-what-should-i-do",
    "title": "Appendix B — Frequently asked questions",
    "section": "\nB.5 My negative control p-values are miscalibrated. What should I do?",
    "text": "B.5 My negative control p-values are miscalibrated. What should I do?\nNot to worry! First of all, the extent of the miscalibration may be mild enough not to cause significant issues with your analysis; see Table 5.1 for assessing the severity of your miscalibration. If the miscalibration is moderate to severe, then see Section 5.4 for several suggestions to improve calibration.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Frequently asked questions</span>"
    ]
  },
  {
    "objectID": "faq.html#how-many-negative-control-grnas-do-i-need",
    "href": "faq.html#how-many-negative-control-grnas-do-i-need",
    "title": "Appendix B — Frequently asked questions",
    "section": "\nB.6 How many negative control gRNAs do I need?",
    "text": "B.6 How many negative control gRNAs do I need?\nThe table below summarizes the minimum number of negative control gRNAs required to run an analysis as a function of the control group (either NT cells or complement set) and analysis type (either calibration check, discovery analysis, or power check). Recall that the default control group for low-MOI screens is the set of NT cells, while the default control group for high-MOI screens is the complement set.\n\nMinimum number of negative control gRNAs required to run an analysis as a function of the control group (vertical axis) and analysis type (horizontal axis).\n\n\n\n\n\n\n\nCalibration check\nDiscovery analysis or power check\n\n\n\nNT cells\n2\n1\n\n\nComplement set\n0\n0\n\n\n\nIn general having more negative control gRNAs is better. We recommend including at least ten to fifteen negative control gRNAs in the assay for the best chance of obtaining high-quality results.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Frequently asked questions</span>"
    ]
  },
  {
    "objectID": "faq.html#sec-multiple_analyses",
    "href": "faq.html#sec-multiple_analyses",
    "title": "Appendix B — Frequently asked questions",
    "section": "\nB.7 How should I run multiple sceptre analyses?",
    "text": "B.7 How should I run multiple sceptre analyses?\nSometimes users wish to carry out multiple sceptre analyses on a single dataset, such as\n\nrunning cis and trans analyses;\nrunning analyses with gRNAs grouped based on target and with singleton gRNAs.\n\nHere we demonstrate how to do this efficiently. We begin by loading the sceptre package.\n\nlibrary(sceptre)\n\n\nB.7.1 Running cis and trans analyses\nSome users may wish to run both a cis analysis and a trans analysis. We recommend that such users apply the sceptre pipeline twice: once to analyze the cis pairs and once to analyze the trans pairs. We illustrate this approach on the high-MOI CRISPRi data; we begin by creating a sceptre_object to represent these data.\n\nsceptre_object &lt;- import_data(\n  response_matrix = highmoi_example_data$response_matrix,\n  grna_matrix = highmoi_example_data$grna_matrix,\n  grna_target_data_frame = grna_target_data_frame_highmoi,\n  moi = \"high\",\n  extra_covariates = highmoi_example_data$extra_covariates,\n  response_names = highmoi_example_data$gene_names\n)\n\nFirst, we carry out an analysis of the cis pairs, storing the results in the directory \"~/sceptre_results_cis\".\n\n# positive control pairs\npositive_control_pairs &lt;- construct_positive_control_pairs(sceptre_object)\n\n# cis pairs\ndiscovery_pairs_cis &lt;- construct_cis_pairs(\n  sceptre_object = sceptre_object,\n  positive_control_pairs = positive_control_pairs,\n  distance_threshold = 5e6\n)\n# run cis analysis\nsceptre_object &lt;- sceptre_object |&gt;\n  set_analysis_parameters(\n    discovery_pairs = discovery_pairs_cis,\n    positive_control_pairs = positive_control_pairs,\n    side = \"left\"\n  ) |&gt;\n  assign_grnas(parallel = TRUE) |&gt;\n  run_qc(p_mito_threshold = 0.075) |&gt;\n  run_calibration_check(parallel = TRUE) |&gt;\n  run_power_check(parallel = TRUE) |&gt;\n  run_discovery_analysis(parallel = TRUE)\n\n# write outputs\nwrite_outputs_to_directory(\n  sceptre_object = sceptre_object,\n  directory = \"~/sceptre_results_cis\"\n)\n\nNext, we carry out an analysis of the trans pairs, storing the results in \"~/sceptre_results_trans\".\n\n# trans pairs\ndiscovery_pairs_trans &lt;- construct_trans_pairs(\n  sceptre_object = sceptre_object,\n  positive_control_pairs = positive_control_pairs,\n  exclude_positive_control_targets = TRUE\n)\n# run trans analysis\nsceptre_object &lt;- sceptre_object |&gt;\n  set_analysis_parameters(\n    discovery_pairs = discovery_pairs_trans,\n    positive_control_pairs = positive_control_pairs,\n    side = \"both\"\n  ) |&gt;\n  assign_grnas(parallel = TRUE) |&gt;\n  run_qc(p_mito_threshold = 0.075) |&gt;\n  run_calibration_check(parallel = TRUE) |&gt;\n  run_power_check(parallel = TRUE) |&gt;\n  run_discovery_analysis(parallel = TRUE)\n\n# write outputs\nwrite_outputs_to_directory(\n  sceptre_object = sceptre_object,\n  directory = \"~/sceptre_results_trans\"\n)\n\nNote that we update the sceptre_object with the output of the cis analysis. We then use the same sceptre_object to carry out the trans analysis. Under the hood sceptre stores (or “caches”) intermediate computations carried out as part of the cis analysis inside the sceptre_object. These intermediate computations are then recycled to carry out the trans analysis, thereby reducing compute.\n\nB.7.2 Running singleton and grouped analyses\nAnother common analysis paradigm is to run both a grouped analysis (in which gRNAs targeting the same site are integrated or “combined”) and a singleton analysis (in which gRNAs targeting the same site are analyzed individually). We carried out a grouped analysis of the cis pairs on the high-MOI CRISPRi data above. Below, we conduct a singleton analysis on the same set of pairs, storing the result in \"~/sceptre_results_cis_singleton\". We operate on the same sceptre_object so as to exploit caching.\n\n# singleton cis analysis\nsceptre_object &lt;- sceptre_object |&gt;\n  set_analysis_parameters(\n    discovery_pairs = discovery_pairs_cis,\n    positive_control_pairs = positive_control_pairs,\n    side = \"left\",\n    grna_integration_strategy = \"singleton\"\n  ) |&gt;\n  assign_grnas(parallel = TRUE) |&gt;\n  run_qc(p_mito_threshold = 0.075) |&gt;\n  run_calibration_check(parallel = TRUE) |&gt;\n  run_power_check(parallel = TRUE) |&gt;\n  run_discovery_analysis(parallel = TRUE)\n\n# write outputs\nwrite_outputs_to_directory(\n  sceptre_object = sceptre_object,\n  directory = \"~/sceptre_results_cis_singleton\"\n)\n\nIn summary, to carry out multiple analyses on the same dataset, users should apply the sceptre pipeline multiple times, reusing the underlying sceptre_object to exploit caching and reduce compute.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Frequently asked questions</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Appendix C — References",
    "section": "",
    "text": "Barry, Timothy, Kaishu Mason, Kathryn Roeder, and Eugene Katsevich.\n2023. “Robust differential expression testing\nfor single-cell CRISPR screens.” bioRxiv.\n\n\nBarry, Timothy, Kathryn Roeder, and Eugene Katsevich. 2022. “Exponential family measurement error models for\nsingle-cell CRISPR screens.” arXiv.\n\n\nBarry, Timothy, Xuran Wang, John A. Morris, Kathryn Roeder, and Eugene\nKatsevich. 2021. “SCEPTRE improves\ncalibration and sensitivity in single-cell CRISPR screen\nanalysis.” Genome Biology 22 (1): 1–19.\n\n\nGasperini, Molly, Andrew J. Hill, José L. McFaline-Figueroa, Beth\nMartin, Seungsoo Kim, Melissa D. Zhang, Dana Jackson, et al. 2019.\n“A Genome-wide Framework for Mapping Gene\nRegulation via Cellular Genetic Screens.” Cell\n176 (1): 377–90.\n\n\nPapalexi, Efthymia, Eleni Mimitou, Andrew W. Butler, Samantha Foster,\nBernadette Bracken, William M. Mauck III, Hans-Hermann Wessels, Bertrand\nZ. Yeung, Peter Smibert, and Rahul Satija. 2021. “Characterizing the molecular regulation of inhibitory\nimmune checkpoints with multi-modal single-cell screens.”\nNature Genetics 53 (3): 322–31.\n\n\nReplogle, Joseph M, Reuben A Saunders, Angela N Pogson, Jeffrey A\nHussmann, Alexander Lenail, Alina Guna, Lauren Mascibroda, et al. 2022.\n“Mapping Information-Rich Genotype-Phenotype Landscapes with\nGenome-Scale Perturb-Seq.” Cell 185 (14): 2559–75.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>References</span>"
    ]
  },
  {
    "objectID": "faq.html#sceptre-crashed-or-sceptre-is-using-an-unexpectedly-large-amount-of-memory-or-taking-an-unexpectedly-long-amount-of-time-to-run.-what-should-i-do",
    "href": "faq.html#sceptre-crashed-or-sceptre-is-using-an-unexpectedly-large-amount-of-memory-or-taking-an-unexpectedly-long-amount-of-time-to-run.-what-should-i-do",
    "title": "Appendix B — Frequently asked questions",
    "section": "\nB.4 sceptre crashed, or sceptre is using an unexpectedly large amount of memory or taking an unexpectedly long amount of time to run. What should I do?",
    "text": "B.4 sceptre crashed, or sceptre is using an unexpectedly large amount of memory or taking an unexpectedly long amount of time to run. What should I do?\nThe most likely explanation is that something is going wrong with the parallel functionality of the package. Consider setting parallel = FALSE and then trying again. If the situation improves, consider setting parallel = TRUE and setting n_processors to a small number, such as 2 or 3. Note that the parallel = TRUE option fails on clusters and Windows machines; to run sceptre in parallel on one of these platforms, use the Nextflow pipeline.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Frequently asked questions</span>"
    ]
  }
]