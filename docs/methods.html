<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Timothy Barry, Eugene Katsevich">

<title>Hands-On Single-Cell CRISPR Screen Analysis - 7&nbsp; Overview of methods</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./accelerations.html" rel="next">
<link href="./methods-and-theory.html" rel="prev">
<link href="./book_cover.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="custom.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./methods-and-theory.html">Part II: Methods and Algorithms</a></li><li class="breadcrumb-item"><a href="./methods.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Overview of methods</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      <img src="./hex.jpg" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Hands-On Single-Cell CRISPR Screen Analysis</a> 
        <div class="sidebar-tools-main">
    <a href="https://katsevich-lab.github.io/sceptre/" rel="" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-git"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sceptre.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">The whole game</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Hands-on data analysis</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./import-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Import data</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./set-analysis-parameters.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Set analysis parameters</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./assign-grnas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Assign gRNAs</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./run-qc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Run quality control</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./run-calibration-check.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Run calibration check</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./run-power-check-and-discovery-analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Run power check and discovery analysis</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./methods-and-theory.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Part II: Methods and Algorithms</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./methods.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Overview of methods</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./accelerations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Statistical and computational accelerations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./theory.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Theoretical issues</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./experimental-design.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Experimental design</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./glossary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Glossary</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./faq.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Frequently asked questions</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">References</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#notation" id="toc-notation" class="nav-link active" data-scroll-target="#notation"><span class="header-section-number">7.1</span> Notation</a></li>
  <li><a href="#sec-methods_assign_grnas" id="toc-sec-methods_assign_grnas" class="nav-link" data-scroll-target="#sec-methods_assign_grnas"><span class="header-section-number">7.2</span> Assigning gRNAs to cells</a>
  <ul class="collapse">
  <li><a href="#thresholding-and-maximum-methods" id="toc-thresholding-and-maximum-methods" class="nav-link" data-scroll-target="#thresholding-and-maximum-methods"><span class="header-section-number">7.2.1</span> Thresholding and maximum methods</a></li>
  <li><a href="#mixture-method" id="toc-mixture-method" class="nav-link" data-scroll-target="#mixture-method"><span class="header-section-number">7.2.2</span> Mixture method</a></li>
  </ul></li>
  <li><a href="#treatment-group-and-control-group" id="toc-treatment-group-and-control-group" class="nav-link" data-scroll-target="#treatment-group-and-control-group"><span class="header-section-number">7.3</span> Treatment group and control group</a></li>
  <li><a href="#differential-expression-testing-and-estimation" id="toc-differential-expression-testing-and-estimation" class="nav-link" data-scroll-target="#differential-expression-testing-and-estimation"><span class="header-section-number">7.4</span> Differential expression testing and estimation</a></li>
  <li><a href="#integrating-information-across-possibly-variably-effective-grnas" id="toc-integrating-information-across-possibly-variably-effective-grnas" class="nav-link" data-scroll-target="#integrating-information-across-possibly-variably-effective-grnas"><span class="header-section-number">7.5</span> Integrating information across (possibly variably effective) gRNAs</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-methods_overview" class="quarto-section-identifier"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Overview of methods</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>There are several statistical tasks involved in analyzing single-cell CRISPR screen data, including assigning gRNAs to cells, testing for association between gRNAs and the expression of responses (such as genes), and integrating information across gRNAs that target the same site (and that potentially exhibit variable effectiveness). This chapter provides an overview of the statistical methods that <code>sceptre</code> employs to carry out these analysis tasks. The methods described in this and subsequent chapters were introduced and validated on real data in <span class="citation" data-cites="barry2021">Barry et al. (<a href="references.html#ref-barry2021" role="doc-biblioref">2021</a>)</span>, <span class="citation" data-cites="barry2022c">Barry, Roeder, and Katsevich (<a href="references.html#ref-barry2022c" role="doc-biblioref">2022</a>)</span>, and <span class="citation" data-cites="barry2023">Barry et al. (<a href="references.html#ref-barry2023" role="doc-biblioref">2023</a>)</span>.</p>
<section id="notation" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="notation"><span class="header-section-number">7.1</span> Notation</h2>
<p>We begin by introducing some notation that we use throughout the chapter. Let <span class="math inline">\(\mathbb{N} = \{1, 2, \dots\}\)</span> denote the set of positive integers. For a given single-cell CRISPR screen dataset, let <span class="math inline">\(d\in\mathbb{N}\)</span> denote the number of responses, <span class="math inline">\(r\in\mathbb{N}\)</span> the number of gRNAs, and <span class="math inline">\(n\in\mathbb{N}\)</span> the number of cells in the dataset. Next, let <span class="math inline">\(Y\in \mathbb{N}^{d \times n}\)</span> be the matrix of response UMI counts, where responses are in the rows and cells in the columns. A given entry <span class="math inline">\(y_{ij}\)</span> of <span class="math inline">\(Y\)</span> indicates the number of UMIs from response <span class="math inline">\(i\)</span> sequenced in cell <span class="math inline">\(j\)</span>. Similarly, let <span class="math inline">\(G \in \mathbb{N}^{r \times n}\)</span> be the matrix of gRNA UMI counts; a given entry <span class="math inline">\(g_{ij}\)</span> of <span class="math inline">\(G\)</span> indicates the number of UMIs from gRNA <span class="math inline">\(i\)</span> sequenced in cell <span class="math inline">\(j\)</span>. Finally, let <span class="math inline">\(Z \in \mathbb{N}^{n\times p}\)</span> be the matrix of cell-specific covariates, which can include variables such as <code>response_n_umis</code>, <code>response_n_nonzero</code>, <code>grna_n_umis</code>, <code>grna_n_nonzero</code>, <code>response_p_mito</code>, <code>batch</code>, and cell type.</p>
</section>
<section id="sec-methods_assign_grnas" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="sec-methods_assign_grnas"><span class="header-section-number">7.2</span> Assigning gRNAs to cells</h2>
<p>The first statistical task involved in single-cell CRISPR screen analysis is to assign gRNAs to cells. The gRNA assignment task involves leveraging the gRNA count matrix <span class="math inline">\(G\)</span> (and possibly the covariate matrix <span class="math inline">\(Z\)</span>) to impute the (unobserved) binary matrix <span class="math inline">\(X \in \{0,1\}^{r \times n}\)</span> of gRNA presences and absences, where a given entry <span class="math inline">\(x_{ij}\)</span> of <span class="math inline">\(X\)</span> is defined to be <span class="math inline">\(1\)</span> (resp., <span class="math inline">\(0\)</span>) if gRNA <span class="math inline">\(i\)</span> is present (resp., absent) in cell <span class="math inline">\(j\)</span>. <code>sceptre</code> implements three gRNA assignment strategies: the thresholding method, maximum method, and the mixture method. All three methods account for background contamination, the phenomenon by which gRNA reads sometimes map to cells that do not contain the corresponding gRNA. (See <a href="sceptre.html#sec-sceptre_assign_grnas"><span>Section&nbsp;3</span></a> of the introductory chapter for a real-data example of background contamination.) We describe each method in greater depth here.</p>
<section id="thresholding-and-maximum-methods" class="level3" data-number="7.2.1">
<h3 data-number="7.2.1" class="anchored" data-anchor-id="thresholding-and-maximum-methods"><span class="header-section-number">7.2.1</span> Thresholding and maximum methods</h3>
<p>The thresholding method assigns a gRNA to a cell if the UMI count of the gRNA in the cell exceeds some integer threshold <span class="math inline">\(c \in \mathbb{N}\)</span>. Formally, the thresholding method sets <span class="math inline">\(x_{ij}\)</span> to <span class="math inline">\(1\)</span> if <span class="math inline">\(g_{ij} \geq c\)</span> and to <span class="math inline">\(0\)</span> if <span class="math inline">\(g_{ij} &lt; c\)</span>. The default value for <span class="math inline">\(c\)</span> is 5 (as proposed in <span class="citation" data-cites="gasperini2019">Gasperini et al. (<a href="references.html#ref-gasperini2019" role="doc-biblioref">2019</a>)</span> and further validated by <span class="citation" data-cites="barry2022c">Barry, Roeder, and Katsevich (<a href="references.html#ref-barry2022c" role="doc-biblioref">2022</a>)</span>). An important special case is to set <span class="math inline">\(c\)</span> to <span class="math inline">\(1\)</span>, which corresponds to the “naive” (but occasionally useful) strategy of assigning any gRNA expressed in a given cell to that cell (and ignoring background contamination). The thresholding method is available in both low- and high-MOI settings in <code>sceptre</code>.</p>
<p>The maximum method assigns the gRNA exhibiting the greatest UMI count in a given cell to that cell. Formally, consider a given cell <span class="math inline">\(j\)</span>; the UMI count of gRNA <span class="math inline">\(i\)</span> in cell <span class="math inline">\(j\)</span> is <span class="math inline">\(g_{ij}\)</span>. Let <span class="math inline">\(i^* \in \{1, \dots, r\}\)</span> be the index such that <span class="math display">\[ g_{i^*j} = \max_{i \in \{1, \dots, r\}}{g_{ij}}.\]</span> (If multiple indices satisfy this criterion, select <span class="math inline">\(i^*\)</span> among these arbitrarily.) We assign gRNA <span class="math inline">\(i^*\)</span> to cell <span class="math inline">\(j\)</span>, i.e.&nbsp;we set <span class="math inline">\(x_{i^*j}\)</span> to <span class="math inline">\(1\)</span> and <span class="math inline">\(x_{ij}\)</span> to <span class="math inline">\(0\)</span> for <span class="math inline">\(i \neq i^*\)</span>. In carrying out the maximum assignment step, <code>sceptre</code> also flags cells that likely contain multiple gRNAs. Let <span class="math inline">\(u \in [0,1]\)</span> be a user-specified threshold (default value <span class="math inline">\(0.8\)</span>). Suppose that the gRNA assigned to cell <span class="math inline">\(j\)</span> constitutes fewer than <span class="math inline">\(u\)</span> of the UMIs in that cell. In other words, suppose that</p>
<p><span class="math display">\[
\frac{g_{i^*j}}{\sum_{i=1}^{r} g_{ij}} &lt; u.
\]</span></p>
<p>Then cell <span class="math inline">\(j\)</span> is flagged as containing multiple gRNAs and is removed as part of the QC step. (Note that if multiple gRNAs are tied for most highly expressed in a given cell, and if <span class="math inline">\(u &gt; 0.5\)</span>, then that cell is flagged as containing multiple gRNAs, per the above rule.) The maximum method is available only in the low-MOI setting in <code>sceptre</code>.</p>
</section>
<section id="mixture-method" class="level3" data-number="7.2.2">
<h3 data-number="7.2.2" class="anchored" data-anchor-id="mixture-method"><span class="header-section-number">7.2.2</span> Mixture method</h3>
<p>The mixture method assigns gRNAs to cells using a latent variable generalized linear model (GLM). Consider a given gRNA <span class="math inline">\(i\)</span>. Let <span class="math inline">\(g_j\)</span> be the UMI count of gRNA <span class="math inline">\(i\)</span> in cell <span class="math inline">\(j\)</span>, and let <span class="math inline">\(x_j\)</span> be the (unobserved) variable indicating whether gRNA <span class="math inline">\(i\)</span> is present (<span class="math inline">\(x_j = 1\)</span>) or absent (<span class="math inline">\(x_j = 0\)</span>) in cell <span class="math inline">\(j\)</span>. (We drop the <span class="math inline">\(i\)</span> subscript for notational compactness.) Additionally, let <span class="math inline">\(z_j\)</span> be the vector of cell-specific covariates in cell <span class="math inline">\(j.\)</span> (We assume that the count-based covariates, such as <code>grna_n_nonzero</code> and <code>grna_n_umis</code>, have been log-transformed, which <code>sceptre</code> does by default.) We model the gRNA UMI counts using a latent variable Poisson GLM:</p>
<p><span id="eq-latent-variable-glm"><span class="math display">\[
\begin{cases}
g_j | \mu_j \sim \textrm{Pois}(\mu_j) \\
\log(\mu_j | x_j, z_j) = \beta_0 + \gamma x_j + \beta^T z_j \\
x_j \sim \textrm{Bernoulli}(\pi).
\end{cases}
\tag{7.1}\]</span></span></p>
<p>Here, <span class="math inline">\(\mu_j\)</span> is the mean expression level of gRNA <span class="math inline">\(i\)</span> in cell <span class="math inline">\(j\)</span> (given the covariates); <span class="math inline">\(\beta_0\)</span>, <span class="math inline">\(\gamma\)</span>, and <span class="math inline">\(\beta \in \mathbb{R}^d\)</span> are the (unknown) regression coefficients; and <span class="math inline">\(\pi \in [0,1]\)</span> is the (unknown) probability that gRNA <span class="math inline">\(i\)</span> is present in a given cell. We fit the model <a href="#eq-latent-variable-glm">Equation&nbsp;<span>7.1</span></a> using an EM algorithm, producing estimates <span class="math inline">\(\hat{\beta}_0\)</span>, <span class="math inline">\(\hat{\gamma}\)</span>, <span class="math inline">\(\hat{\beta}\)</span>, and <span class="math inline">\(\hat{\pi}\)</span> for the model coefficients <span class="math inline">\(\beta_0\)</span>, <span class="math inline">\(\gamma\)</span>, <span class="math inline">\(\beta\)</span>, and <span class="math inline">\(\pi\)</span>. Using these estimates, we can compute the probability <span class="math inline">\(T_{ij} := \mathbb{P}(x_{ij} = 1)\)</span> that a given cell <span class="math inline">\(j\)</span> contains gRNA <span class="math inline">\(i\)</span>. (The probabilities <span class="math inline">\(T_{i1}, \dots, T_{in}\)</span> are sometimes called “posterior probabilities.”) Finally, we threshold the posterior probabilities at some threshold <span class="math inline">\(u\)</span> (default value 0.8) to assign gRNA <span class="math inline">\(i\)</span> to the cells, i.e.&nbsp;we set <span class="math inline">\(x_{ij} = 1\)</span> if <span class="math inline">\(T_{ij} &gt; u\)</span> and <span class="math inline">\(x_{ij} = 0\)</span> if <span class="math inline">\(T_{ij} \leq u\)</span>. An advantage of the Poisson GLM framework is that it enables us to account for cell-specific covariates that might affect the level of background contamination, such as the number of gRNA UMIs sequenced in a given cell (i.e., <code>grna_n_umis</code>). The mixture method is available in both low- and high-MOI settings in <code>sceptre</code>.</p>
<p>Formulating the model <a href="#eq-latent-variable-glm">Equation&nbsp;<span>7.1</span></a> is fairly straightforward; fitting the model to data in a fast and numerically stable way is more challenging. <code>sceptre</code> leverages a novel variant of the EM algorithm for this purpose, which we describe below.</p>
<p>Approximating the model <a href="#eq-latent-variable-glm">Equation&nbsp;<span>7.1</span></a> with a simpler model. We begin by approximating the latent variable model <a href="#eq-latent-variable-glm">Equation&nbsp;<span>7.1</span></a> with a simpler latent variable model that is easier to estimate. First, we obtain accurate estimates for the parameters <span class="math inline">\(\beta_0\)</span> and <span class="math inline">\(\beta\)</span> by exploiting the fact that the gRNA is present in only a small fraction (typically <span class="math inline">\(&lt; 2\%\)</span>) of cells. Let <span class="math inline">\(f(g_j; \mu_j)\)</span> denote the probability mass function of the Poisson distribution with mean <span class="math inline">\(\mu_j\)</span> evaluated at <span class="math inline">\(g_j\)</span>, i.e.,</p>
<p><span class="math display">\[
f(g_j; \mu_j) = \frac{\mu_j^{g_j} e^{-\mu_j}}{g_j!}.
\]</span>Conditioning on the covariates (i.e., treating <span class="math inline">\(x_j\)</span> and <span class="math inline">\(z_j\)</span> as fixed), we can express the log-likelihood of the GLM in <a href="#eq-latent-variable-glm">Equation&nbsp;<span>7.1</span></a> as follows:<br>
<span class="math display">\[
\begin{multline}
L(\beta_0, \gamma, \beta^T) = \sum_{j=1}^n \log \left[ f(g_j;\mu_j )\right] = \sum_{j=1}^n \log \left[ f(g_j; \exp(\beta_0 + \gamma x_j + \beta^T z_j)) \right] \\ = \underbrace{\sum_{j:x_j = 1} \log \left[ f(g_j; \exp(\beta_0 + \gamma + \beta^T z_j)) \right]}_{\textrm{few terms}} + \underbrace{\sum_{j: x_j = 0} \log \left[ f(g_j; \exp(\beta_0 + \beta^T z_j)) \right]}_\textrm{many terms} \\ \approx \sum_{j=1}^n \log \left[ f(g_j; \exp(\beta_0 + \beta^T z_j)) \right].
\end{multline}
\]</span></p>
<p>In words, the gRNA indicator <span class="math inline">\(x_j\)</span> is equal to zero in the large majority of cells, and so we can approximate the GLM in <a href="#eq-latent-variable-glm">Equation&nbsp;<span>7.1</span></a> with the GLM that results from excluding <span class="math inline">\(x_j\)</span> from the model:</p>
<p><span id="eq-simplified_glm"><span class="math display">\[
\begin{cases}
g_j | \mu_j \sim \textrm{Pois} (\mu_j) \\
\log(\mu_j | z_j) = \beta_0 + \beta^T z_j.
\end{cases}
\tag{7.2}\]</span></span></p>
<p>We can fit the GLM <a href="#eq-simplified_glm">Equation&nbsp;<span>7.2</span></a> using the standard procedure for fitting GLMs (e.g., in R), as the covariates in this GLM are observed. Doing so yields estimates <span class="math inline">\(\hat{\beta}_0\)</span> and <span class="math inline">\(\hat{\beta}\)</span> for <span class="math inline">\(\beta_0\)</span> and <span class="math inline">\(\beta\)</span>, respectively. Assuming that <span class="math inline">\(\hat{\beta_0} \approx \beta_0\)</span> and <span class="math inline">\(\hat{\beta} \approx \beta\)</span> (which holds for large <span class="math inline">\(n\)</span> and small <span class="math inline">\(\pi\)</span>), we can write</p>
<p><span class="math display">\[\gamma x_j + \beta_0 x_j + \beta z_j \approx \gamma x_j + \hat{\beta}_0 + \hat{\beta} z_j = \gamma x_i + o_j,\]</span>where we have set <span class="math inline">\(o_j\)</span> to <span class="math inline">\(\hat{\beta}_0 + \hat{\beta}z_j\)</span>, i.e.&nbsp;the <span class="math inline">\(j\)</span>th fitted value (on the scale of the linear component) of the GLM <a href="#eq-simplified_glm">Equation&nbsp;<span>7.2</span></a>. Finally, we propose a simplified model for expression of the gRNA:</p>
<p><span id="eq-simplified_glm_2"><span class="math display">\[\begin{cases}
g_j | \mu_j \sim \textrm{Pois}(\mu_j) \\
\log(\mu_j | x_j) = \gamma x_j + o_j \\
x_j \sim \textrm{Bernoulli}(\pi).
\end{cases}
\tag{7.3}\]</span></span></p>
<p>Here, the <span class="math inline">\(o_j\)</span>s are offset terms in the GLM. Notice that the GLM in <a href="#eq-simplified_glm_2">Equation&nbsp;<span>7.3</span></a> does not include covariates or an intercept term; rather, all information about the covariates and the baseline expression level of the gRNA has been “encoded” into the offsets <span class="math inline">\(o_1, \dots, o_n\)</span>. In summary we (i) estimated <span class="math inline">\(\beta_0\)</span> and <span class="math inline">\(\beta\)</span> using the GLM <a href="#eq-simplified_glm">Equation&nbsp;<span>7.2</span></a> and then (ii) replaced <span class="math inline">\(\beta_0\)</span> and <span class="math inline">\(\beta\)</span> in <a href="#eq-latent-variable-glm">Equation&nbsp;<span>7.1</span></a> with their corresponding estimates, yielding the model <a href="#eq-simplified_glm_2">Equation&nbsp;<span>7.3</span></a>. The model <a href="#eq-simplified_glm_2">Equation&nbsp;<span>7.3</span></a> is a good approximation to <a href="#eq-latent-variable-glm">Equation&nbsp;<span>7.1</span></a> in the sense that the maximum likelihood estimates for <span class="math inline">\(\gamma\)</span> and <span class="math inline">\(\pi\)</span> in <a href="#eq-simplified_glm_2">Equation&nbsp;<span>7.3</span></a> are close to the corresponding estimates for these parameters in <a href="#eq-latent-variable-glm">Equation&nbsp;<span>7.1</span></a> when <span class="math inline">\(n\)</span> is large and <span class="math inline">\(\pi\)</span> is small (as is the case on most single-cell CRISPR screen datasets). We turn our attention to estimating the model <a href="#eq-simplified_glm_2">Equation&nbsp;<span>7.3</span></a>, treating the offset terms <span class="math inline">\(o_1, \dots, o_n\)</span> as known and fixed.</p>
<p>EM algorithm. We derive an EM algorithm to estimate the model <a href="#eq-simplified_glm_2">Equation&nbsp;<span>7.3</span></a>. Let <span class="math inline">\(\theta = (\gamma, \pi)\)</span> denote the unknown model parameters. Let <span class="math inline">\(G_j\)</span> be a random variable that represents the UMI count of the gRNA in the <span class="math inline">\(j\)</span>th cell, and let <span class="math inline">\(g_j\)</span> be the realized value of this random variable. (Similarly, let <span class="math inline">\(x_j\)</span> be the realized value of the random variable <span class="math inline">\(X_j\)</span>.) We begin by writing down the complete-data likelihood <span class="math inline">\(l\)</span> of this model, which is the likelihood that would result if <span class="math inline">\(x_1, \dots, x_n\)</span> <em>had</em> been observed.</p>
<p><span class="math display">\[
\begin{multline*}
l(\theta) = \prod_{j=1}^n \mathbb{P}(G_j = g_j, X_j = x_j) = \prod_{j=1}^n\mathbb{P}(G_j = g_j | X_j = x_j) \mathbb{P}(X_j = x_j) \\ = \prod_{j=1}^n f(g_j; \exp( \gamma x_j + o_j))\left[\pi^{x_i} (1-\pi)^{1-x_i} \right].
\end{multline*}
\]</span></p>
<p>We obtain the complete-data log-likelihood <span class="math inline">\(L\)</span> by taking the log of <span class="math inline">\(l\)</span>:</p>
<p><span class="math display">\[
L(\theta) = \log(l(\theta)) = \sum_{j=1}^n \log\left[ f(g_j; \exp(\gamma x_j + o_j)\right] + \sum_{j=1}^n x_j \log(\pi) + (1-x_j)(1-\pi).
\]</span></p>
<p>We derive the E and M steps for the EM algorithm in this model.</p>
<p><u>E step</u>: The E step entails computing the membership probability of each cell (i.e., the probability that each cell contains the gRNA given the current parameter estimates and the observed gRNA counts). Let <span class="math inline">\(\theta^{(t)} = (\gamma^{(t)}, \pi^{(t)})\)</span> be the parameter estimate for <span class="math inline">\(\theta\)</span> at the <span class="math inline">\(t\)</span>th iteration of the algorithm. The <span class="math inline">\(j\)</span>th membership probability at the <span class="math inline">\(t\)</span>th iteration of the algorithm <span class="math inline">\(T^{(t)}_j\)</span> is defined as <span class="math inline">\(T^{(t)}_j = \mathbb{P}(X_j = 1 | G_j = g_j, \theta^{(t)}).\)</span> Let <span class="math inline">\([\mu_j(k)]^{(t)}\)</span> be the mean gRNA UMI count in the <span class="math inline">\(j\)</span>th cell at the <span class="math inline">\(t\)</span>th iteration of the algorithm that results from setting <span class="math inline">\(x_j\)</span> to <span class="math inline">\(k \in \{0,1\}\)</span>, i.e.,</p>
<p><span class="math display">\[
[\mu_j(k)]^{(t)} = \exp( \gamma^{(t)} \cdot k + o_j ).
\]</span></p>
<p>Applying Bayes rule, we can express the membership probability <span class="math inline">\(T^{(t)}_j\)</span> as</p>
<p><span class="math display">\[
\begin{multline*}
T^{(t)}_j = \mathbb{P}(X_j = 1 | G_j = g_j, \theta^{(t)}) = \frac{\mathbb{P}(G_j = g_j | X_j = 1, \theta^{(t)})\mathbb{P}(X_j = 1 | \theta^{(t)})}{ \sum_{k=0}^1 \mathbb{P}(G_j = g_j | X_j = k, \theta^{(t)}) \mathbb{P}(X_j = k | \theta^{(t)})} \\ = \left(\frac{\mathbb{P}(G_j = g_j | X_j = 0, \theta^{(t)}) \mathbb{P}(X_j = 0)}{\mathbb{P}( G_j = g_j | X_j = 1, \theta^{(t)}) \mathbb{P}(X_j = 1)} +1\right)^{-1} = \left(\frac{f(g_j; [\mu_j(0)]^{(t)})(1-\pi^{(t)}))}{f(g_j; [\mu_j(1)]^{(t)})\pi^{(t)})} + 1 \right)^{-1} \\ = \left(\exp(q_j^{(t)}) + 1 \right)^{-1},
\end{multline*}
\]</span> where we define <span class="math display">\[q_j^{(t)} := \log\left( \frac{f(g_j; [\mu_j(0)]^{(t)})(1-\pi^{(t)})}{f(g_j; [\mu_j(1)]^{(t)})\pi^{(t)}} \right).\]</span></p>
<p>Plugging in the Poisson probability mass function for <span class="math inline">\(f\)</span>, we can express <span class="math inline">\(q_j^{(t)}\)</span> is follows.</p>
<p><span id="eq-q_j_expression"><span class="math display">\[
\begin{multline*}
q_j^{(t)} := \log(1-\pi^{(t)}) - \log(\pi^{(t)}) + g_j \left(\log([\mu_j(0)]^{(t)}) - \log([\mu_j(1)]^{(t)}) \right) \\ + [\mu_j(1)]^{(t)} - [\mu_j(0)]^{(t)}.
\end{multline*}
\tag{7.4}\]</span></span></p>
<p>This expression <a href="#eq-q_j_expression">Equation&nbsp;<span>7.4</span></a> for <span class="math inline">\(q_j^{(t)}\)</span> is numerically stable and fast to evaluate. In summary the M step consists of computing <span class="math inline">\(T^{(t)}_j\)</span> for all <span class="math inline">\(j\in\{1, \dots, n\}\)</span> by computing <span class="math inline">\(q^{(t)}_j\)</span> (using <a href="#eq-q_j_expression">Equation&nbsp;<span>7.4</span></a>) and then evaluating <span class="math inline">\(T^{(t)}_j = \exp(q_j^{(t)} + 1)^{-1}.\)</span></p>
<p><u>M step</u>: The M-step involves maximizing the so-called “Q function,” which is the function that results from taking the expectation of the complete-data log-likelihood with respect to the <span class="math inline">\(X_j\)</span>s while conditioning on the <span class="math inline">\(G_j\)</span>s and the current parameter estimates <span class="math inline">\(\theta^{(t)}\)</span>. Formally, the Q function <span class="math inline">\(Q(\theta | \theta^{(t)})\)</span> is defined as <span class="math inline">\(Q(\theta|\theta^{(t)}) = \mathbb{E}_{X_1, \dots, X_n}[L(\theta) | G_1 = g_1, \dots, G_n = g_n \theta^{(t)}]\)</span>. We can express the Q function as</p>
<p><span id="eq-q_function"><span class="math display">\[
\begin{multline*}
Q(\theta|\theta^{(t)}) = \sum_{j=1}^n T^{(t)}_j \log(\pi) + \sum_{j=1}^n (1 - T_j^{(t)})\log(1-\pi) \\ + \sum_{j=1}^n T_j^{(t)} \log \left[ f\left(g_j; \exp[\gamma + o_j] \right) \right] + \sum_{j=1}^n (1 - T^{(t)}_j) \log \left[f(g_j; \exp(o_j) \right].
\end{multline*}
\tag{7.5}\]</span></span></p>
<p>The goal of the M step to identify the parameter <span class="math inline">\(\theta = (\pi, \gamma)\)</span> that maximizes <a href="#eq-q_function">Equation&nbsp;<span>7.5</span></a>. The first two terms of <a href="#eq-q_function">Equation&nbsp;<span>7.5</span></a> are a function of <span class="math inline">\(\pi\)</span>, and the last two terms are a function of <span class="math inline">\(\gamma\)</span>. Thus, we can optimize these sets of terms separately.</p>
<p>To find the maximizer in <span class="math inline">\(\pi\)</span>, we differentiate the first two terms of <a href="#eq-q_function">Equation&nbsp;<span>7.5</span></a> with respect to <span class="math inline">\(\pi\)</span>, yielding</p>
<p><span id="eq-m_step_0"><span class="math display">\[
\frac{\sum_{j=1}^n T_j^{(t)}}{\pi} - \frac{\sum_{j=1}^n (1 - T_j^{(t)})}{1 - \pi}.
\tag{7.6}\]</span></span></p>
<p>Setting <a href="#eq-m_step_0">Equation&nbsp;<span>7.6</span></a> to zero and solving for <span class="math inline">\(\pi\)</span> produces the maximizer <span class="math inline">\(\pi^{(t+1)}\)</span>:</p>
<p><span id="eq-pi_update"><span class="math display">\[ \pi^{(t+1)} = (1/n) \sum_{j=1}^n T_j^{(t)}. \tag{7.7}\]</span></span></p>
<p>We turn our attention to the last two terms of <a href="#eq-q_function">Equation&nbsp;<span>7.5</span></a>. The final term is not a function of <span class="math inline">\(\gamma\)</span> and thus can be ignored. We rewrite the penultimate term as follows:</p>
<p><span id="eq-m_step_1"><span class="math display">\[
\begin{multline*}
\sum_{j=1}^n T^{(t)}_j \log\left[ f(g_j; \exp[\gamma + o_j])\right] \\ = \sum_{j=1}^n T^{(t)}_j \log\left[ \frac{\exp(\gamma + o_j)^{g_j} \exp(-\exp[\gamma + o_j])}{g_j!} \right] \\ =
\sum_{j=1}^n T_j^{(t)}\left[ g_j(\gamma + o_j) - \exp(\gamma + o_j) - \log(g_j!) \right].
\end{multline*}
\tag{7.8}\]</span></span></p>
<p>The derivative of <a href="#eq-m_step_1">Equation&nbsp;<span>7.8</span></a> with respect to <span class="math inline">\(\gamma\)</span> is</p>
<p><span id="eq-m_step_2"><span class="math display">\[
\begin{multline*}
\sum_{j=1}^n T^{(t)}_j g_j - T^{(t)}_j \exp(\gamma + o_j) = \sum_{j=1}^n T^{(t)}_j g_j - \exp(\gamma) \sum_{j=1}^n T_j^{(t)} \exp(o_j).
\end{multline*}
\tag{7.9}\]</span></span></p>
<p>Finally, setting <a href="#eq-m_step_2">Equation&nbsp;<span>7.9</span></a> to zero and solving for <span class="math inline">\(\gamma\)</span> yields the maximizer</p>
<p><span id="eq-gamma_update"><span class="math display">\[
\gamma^{(t+1)} = \log\left(\frac{\sum_{j=1}^n T^{(t)}_j y_j }{\sum_{j=1}^n T^{(t)}_j e^{o_j} }\right).
\tag{7.10}\]</span></span></p>
<p>In summary the M step entails computing the updated parameter estimates <span class="math inline">\(\pi^{(t+1)}\)</span> and <span class="math inline">\(\gamma^{(t+1)}\)</span> using the formulas <a href="#eq-pi_update">Equation&nbsp;<span>7.7</span></a> and <a href="#eq-gamma_update">Equation&nbsp;<span>7.10</span></a>, respectively.</p>
<p><u>Convergence</u>: The incomplete-data likelihood (which we obtain by integrating the complete-data likelihood with respect to the <span class="math inline">\(x_j\)</span>s) is</p>
<p><span class="math display">\[
l_\textrm{incomplete}(\theta) = \prod_{j=1}^n f(g_j; \gamma + o_j) \pi + f(g_j; o_j)(1-\pi).
\]</span></p>
<p>The incomplete-data log-likelihood is</p>
<p><span class="math display">\[
L_\textrm{incomplete}(\theta) = \log(l_\textrm{incomplete}(\theta)) = \sum_{j=1}^n \log\left[ f(g_j; \gamma + o_j) \pi + f(g_j; o_j)(1-\pi) \right].
\]</span></p>
<p>Note that the incomplete-data log-likelihood — in contrast to the complete-data log-likelihood — is computable (albeit hard to optimize directly). We iterate between E and M steps until <span class="math inline">\(L_\textrm{incomplete}\)</span> converges. We declare that the sequence of estimates <span class="math inline">\(\theta^{(0)}, \theta^{(1)}, \theta^{(2)}, \dots\)</span> has converged when</p>
<p><span class="math display">\[
\frac{|L_\textrm{incomplete}(\theta^{(t+1)}) - L_\textrm{incomplete}(\theta^{(t)})|}{ \min\left\{ |L_\textrm{incomplete}(\theta^{(t+1)})|, |L_\textrm{incomplete}(\theta^{(t)}) | \right\}} &lt; \epsilon
\]</span></p>
<p>for some <span class="math inline">\(\epsilon &gt; 0\)</span> (by default <span class="math inline">\(\epsilon = 0.5 \cdot 10^{-4}\)</span>). We set the final parameter estimates <span class="math inline">\(\hat{\pi}\)</span> and <span class="math inline">\(\hat{\gamma}\)</span> to <span class="math inline">\(\pi^{(t+1)}\)</span> and <span class="math inline">\(\gamma^{(t+1)}\)</span>. Additionally, we use the final membership probabilities <span class="math inline">\(T^{(t+1)}_1, \dots, T^{(t+1)}_n\)</span> to assign the gRNA to cells.</p>
<p>As is standard, we run the EM algorithm several times over random starting estimates for <span class="math inline">\(\pi\)</span> and <span class="math inline">\(\gamma\)</span> to improve chances of converging to the global maximizer of the incomplete-data likelihood. We take the run whose estimates yield the greatest incomplete-data log-likelihood as the final run.</p>
</section>
</section>
<section id="treatment-group-and-control-group" class="level2" data-number="7.3">
<h2 data-number="7.3" class="anchored" data-anchor-id="treatment-group-and-control-group"><span class="header-section-number">7.3</span> Treatment group and control group</h2>
<p>To test for association between a given gRNA (or gRNA target) and a response, <code>sceptre</code> divides the cells into two groups: the “treatment group” and the “control group.” <code>sceptre</code> tests for differential expression of the response across these two groups of cells, yielding a p-value for the test of association. The definitions of treatment group and control group are somewhat subtle and depend on the analysis parameters of gRNA integration strategy (i.e., union, singleton, or Bonferroni), and control group (i.e., complement set or NT cells), analysis type (i.e., discovery analysis or calibration check). (See <a href="set-analysis-parameters.html"><span>Chapter&nbsp;2</span></a> for a discussion of these parameters.) This section aims to carefully define “treatment group” and “control group,” in particular as a function of the aforementioned factors.</p>
<p>We first introduce some notation. Let <span class="math inline">\(\mathcal{S} =\{1, \dots, n\}\)</span> denote the set of cells. Let <span class="math inline">\(X \in \{0,1\}^{r \times n}\)</span> denote the matrix of imputed gRNA presences and absences (as determined in the gRNA assignment step; <a href="#sec-methods_assign_grnas"><span>Section&nbsp;7.2</span></a>). For <span class="math inline">\(i \in \{1, \dots, r\}\)</span>, let <span class="math inline">\(G_i\)</span> denote the set of cells that gRNA <span class="math inline">\(i\)</span> has infected, i.e.&nbsp;<span class="math inline">\(G_i := \{ j: x_{ij} = 1 \}.\)</span> Let <span class="math inline">\(\mathcal{N} \subset \{1, \dots, r\}\)</span> denote the set of non-targeting gRNAs, and let <span class="math inline">\(\mathcal{T} = \{1,\dots,r\} \setminus \mathcal{N}\)</span> denote the set of targeting gRNAs. (Typically, <span class="math inline">\(\mathcal{T}\)</span> consists of both discovery gRNAs and positive control gRNAs.) Note that in low MOI, after applying quality control, each cell contains a single gRNA, implying that the sets <span class="math inline">\(G_1, \dots, G_r\)</span> are disjoint, i.e.</p>
<p><span class="math display">\[
\bigcap_{i=1}^r G_i = \emptyset.
\]</span></p>
<p>We proceed by taking cases on gRNA integration strategy, first considering the union integration strategy and then considering the singleton and Bonferroni integration strategies.</p>
<p><strong>Union gRNA integration strategy.</strong> We first consider the “union” gRNA integration strategy. The union integration strategy involves combining multiple distinct gRNAs into a single “combined” gRNA and then testing this combined gRNA against responses as if it were a singleton gRNA. Suppose that we are running a discovery analysis, and let <span class="math inline">\(\mathcal{I} \subset \mathcal{T}\)</span> be a given set of gRNAs that target the same site. The table below defines the treatment group, the complement set control group, and the NT cells control group relative to <span class="math inline">\(\mathcal{I}\)</span>.</p>
<table class="table">
<caption>Union gRNA integration strategy, discovery analysis.</caption>
<colgroup>
<col style="width: 27%">
<col style="width: 36%">
<col style="width: 35%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">Treatment group</td>
<td style="text-align: center;">Complement set control group</td>
<td style="text-align: center;">NT cells control group</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\cup_{i \in \mathcal{I}} G_i\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathcal{S} \setminus \cup_{i \in \mathcal{I}} G_i\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\cup_{i \in \mathcal{N}} G_i\)</span></td>
</tr>
</tbody>
</table>
<p>Next, suppose that we are running a calibration check analysis (again using the union gRNA integration strategy). Let <span class="math inline">\(\mathcal{L} \subset \mathcal{N}\)</span> be a set of non-targeting gRNAs that have been combined into a “negative control” gRNA target. (By default, <span class="math inline">\(|\mathcal{L}| = |\mathcal{I}|\)</span>, i.e., the discovery target and negative control target contain the same number of gRNAs.) The treatment group, complement set control group, and NT cells control group are defined relative to <span class="math inline">\(\mathcal{L}\)</span> as follows.</p>
<table class="table">
<caption>Union gRNA integration strategy, calibration check.</caption>
<colgroup>
<col style="width: 27%">
<col style="width: 36%">
<col style="width: 35%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">Treatment group</td>
<td style="text-align: center;">Complement set control group</td>
<td style="text-align: center;">NT cells control group</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\cup_{l \in \mathcal{L}} G_l\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathcal{S} \setminus \cup_{l \in \mathcal{L}} G_l\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\cup_{l \in (\mathcal{N} \setminus \mathcal{L})} G_l\)</span></td>
</tr>
</tbody>
</table>
<p><strong>Singleton and Bonferroni gRNA integration strategies</strong>. Next, we consider the “singleton” and “Bonferroni” gRNA integration strategies. Both strategies involve testing singleton gRNAs for association against responses. Suppose that we are running a discovery analysis, and let <span class="math inline">\(i \in \mathcal{T}\)</span> be a given targeting gRNA. The table below defines the treatment group, complement set control group, and NT cells control group relative to <span class="math inline">\(i\)</span>.</p>
<table class="table">
<caption>Singleton/Bonferroni gRNA integration strategy, discovery analysis.</caption>
<colgroup>
<col style="width: 27%">
<col style="width: 36%">
<col style="width: 35%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">Treatment group</td>
<td style="text-align: center;">Complement set control group</td>
<td style="text-align: center;">NT cells control group</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(G_i\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathcal{S} \setminus G_i\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\cup_{i \in \mathcal{N}} G_i\)</span></td>
</tr>
</tbody>
</table>
<p>Finally, suppose that we are running a calibration check using the singleton or Bonferroni gRNA integration strategy. Let <span class="math inline">\(l \in \mathcal{N}\)</span> be a non-targeting gRNA. The treatment group, complement set control group, and NT cells control group are defined relative to <span class="math inline">\(l\)</span> as follows.</p>
<table class="table">
<caption>Singleton/Bonferroni gRNA integration strategy, calibration check.</caption>
<colgroup>
<col style="width: 27%">
<col style="width: 36%">
<col style="width: 35%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">Treatment group</td>
<td style="text-align: center;">Complement set control group</td>
<td style="text-align: center;">NT cells control group</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(G_l\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathcal{S} \setminus G_l\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\cup_{i \in (\mathcal{N}\setminus \{ l \} )} G_i\)</span></td>
</tr>
</tbody>
</table>
<p>Note that the Bonferroni gRNA integration strategy combines p-values across gRNAs that target the same site into a single “target-wide” p-value via a Bonferroni correction (discussed below). Note also that the complement set is available as a control group in both low- and high-MOI settings, while the NT cells are available as a control group only in the low-MOI setting.</p>
</section>
<section id="differential-expression-testing-and-estimation" class="level2" data-number="7.4">
<h2 data-number="7.4" class="anchored" data-anchor-id="differential-expression-testing-and-estimation"><span class="header-section-number">7.4</span> Differential expression testing and estimation</h2>
</section>
<section id="integrating-information-across-possibly-variably-effective-grnas" class="level2" data-number="7.5">
<h2 data-number="7.5" class="anchored" data-anchor-id="integrating-information-across-possibly-variably-effective-grnas"><span class="header-section-number">7.5</span> Integrating information across (possibly variably effective) gRNAs</h2>
<p>Suppose that gRNAs <span class="math inline">\(1, \dots, k\)</span> target the same site. Testing each of these gRNAs individually against a given response yields p-values <span class="math inline">\(p_1, \dots, p_k\)</span>.</p>
<p><strong>Theorem</strong>: Suppose that <span class="math inline">\(p_1, \dots, p_k\)</span> are superuniform, i.e.&nbsp;<span class="math inline">\(\mathbb{P}(p_i \leq \alpha) \leq \alpha\)</span> for all <span class="math inline">\(i \in \{1, \dots, k\}\)</span> and all <span class="math inline">\(\alpha \in [0,1]\)</span>. Then <span class="math inline">\(k \cdot \min\{p_1, \dots, p_k\}\)</span> also is superuniform.</p>
<p><strong>Proof</strong>:</p>
<p><span class="math display">\[
\begin{multline}
\mathbb{P}( k \cdot \min\{p_1, \dots, p_k\} \leq \alpha) = \mathbb{P}( \min\{p_1, \dots, p_k\} \leq \alpha/k )\\ = \mathbb{P}\left( p_1 \leq \alpha/k \textrm{ or } \dots \textrm{ or } p_k \leq \alpha /k  \right) \leq \sum_{i=1}^k \mathbb{P}(p_i \leq \alpha/k) \leq \sum_{i=1}^k \alpha/k = \alpha.
\end{multline}
\]</span></p>
<p>The penultimate inequality follows from the union bound, and the final inequality follows from the superuniformity of <span class="math inline">\(p_i\)</span>. <span class="math inline">\(\square\)</span></p>


<div id="refs" class="references csl-bib-body hanging-indent" role="list" style="display: none">
<div id="ref-barry2023" class="csl-entry" role="listitem">
Barry, Timothy, Kaishu Mason, Kathryn Roeder, and Eugene Katsevich. 2023. <span>“<span class="nocase">Robust differential expression testing for single-cell CRISPR screens</span>.”</span> <em>bioRxiv</em>.
</div>
<div id="ref-barry2022c" class="csl-entry" role="listitem">
Barry, Timothy, Kathryn Roeder, and Eugene Katsevich. 2022. <span>“<span class="nocase">Exponential family measurement error models for single-cell CRISPR screens</span>.”</span> <em>arXiv</em>.
</div>
<div id="ref-barry2021" class="csl-entry" role="listitem">
Barry, Timothy, Xuran Wang, John A. Morris, Kathryn Roeder, and Eugene Katsevich. 2021. <span>“<span class="nocase">SCEPTRE improves calibration and sensitivity in single-cell CRISPR screen analysis</span>.”</span> <em>Genome Biology</em> 22 (1): 1–19.
</div>
<div id="ref-gasperini2019" class="csl-entry" role="listitem">
Gasperini, Molly, Andrew J. Hill, José L. McFaline-Figueroa, Beth Martin, Seungsoo Kim, Melissa D. Zhang, Dana Jackson, et al. 2019. <span>“<span class="nocase">A Genome-wide Framework for Mapping Gene Regulation via Cellular Genetic Screens</span>.”</span> <em>Cell</em> 176 (1): 377–90.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./methods-and-theory.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Part II: Methods and Algorithms</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./accelerations.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Statistical and computational accelerations</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">Hands-On Single-Cell CRISPR Screen Analysis</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">This book was built with <a href="https://quarto.org/">Quarto</a>.</div>
  </div>
</footer>



</body></html>