<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Timothy Barry, Eugene Katsevich">

<title>Hands-On Single-Cell CRISPR Screen Analysis - 10&nbsp; Overview of methods</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./ondisc.html" rel="next">
<link href="./pipeline-args.html" rel="prev">
<link href="./book_cover.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="custom.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./methods.html">Part III. Methods and algorithms</a></li><li class="breadcrumb-item"><a href="./methods.html"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Overview of methods</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      <img src="./hex.jpg" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Hands-On Single-Cell CRISPR Screen Analysis</a> 
        <div class="sidebar-tools-main">
    <a href="https://katsevich-lab.github.io/sceptre/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-git"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sceptre.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">The whole game</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Part I. Introduction to sceptre</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./import-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Import data</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./set-analysis-parameters.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Set analysis parameters</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./assign-grnas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Assign gRNAs</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./run-qc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Run quality control</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./run-calibration-check.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Run calibration check</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./run-power-check-and-discovery-analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Run power check and discovery analysis</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Part II. At-scale sceptre</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./at-scale.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Introduction to the Nextflow pipeline</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./pipeline-details.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">A deeper dive into the Nextflow pipeline</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./pipeline-args.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Nextflow installation, pipeline arguments</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Part III. Methods and algorithms</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./methods.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Overview of methods</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ondisc.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">The <code>ondisc</code> package</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sceptredata.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Example data in the <code>sceptredata</code> package</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./glossary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Glossary</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./faq.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">Frequently asked questions</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">References</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#notation" id="toc-notation" class="nav-link active" data-scroll-target="#notation"><span class="header-section-number">10.1</span> Notation</a>
  <ul class="collapse">
  <li><a href="#thresholding-method" id="toc-thresholding-method" class="nav-link" data-scroll-target="#thresholding-method"><span class="header-section-number">10.1.1</span> Thresholding method</a></li>
  <li><a href="#maximum-method" id="toc-maximum-method" class="nav-link" data-scroll-target="#maximum-method"><span class="header-section-number">10.1.2</span> Maximum method</a></li>
  <li><a href="#sec-mixture_method" id="toc-sec-mixture_method" class="nav-link" data-scroll-target="#sec-mixture_method"><span class="header-section-number">10.1.3</span> Mixture method</a></li>
  </ul></li>
  <li><a href="#sec-defn_trt_cntrl_grp" id="toc-sec-defn_trt_cntrl_grp" class="nav-link" data-scroll-target="#sec-defn_trt_cntrl_grp"><span class="header-section-number">10.2</span> Definition of “treatment group” and “control group”</a></li>
  <li><a href="#differential-expression-testing" id="toc-differential-expression-testing" class="nav-link" data-scroll-target="#differential-expression-testing"><span class="header-section-number">10.3</span> Differential expression testing</a>
  <ul class="collapse">
  <li><a href="#resampling-the-treatment-vector" id="toc-resampling-the-treatment-vector" class="nav-link" data-scroll-target="#resampling-the-treatment-vector"><span class="header-section-number">10.3.1</span> Resampling the treatment vector</a></li>
  <li><a href="#computing-the-test-statistics" id="toc-computing-the-test-statistics" class="nav-link" data-scroll-target="#computing-the-test-statistics"><span class="header-section-number">10.3.2</span> Computing the test statistics</a></li>
  <li><a href="#computing-the-p-value" id="toc-computing-the-p-value" class="nav-link" data-scroll-target="#computing-the-p-value"><span class="header-section-number">10.3.3</span> Computing the p-value</a></li>
  </ul></li>
  <li><a href="#estimating-the-log-fold-change" id="toc-estimating-the-log-fold-change" class="nav-link" data-scroll-target="#estimating-the-log-fold-change"><span class="header-section-number">10.4</span> Estimating the log-fold change</a></li>
  <li><a href="#integrating-information-across-grnas" id="toc-integrating-information-across-grnas" class="nav-link" data-scroll-target="#integrating-information-across-grnas"><span class="header-section-number">10.5</span> Integrating information across gRNAs</a></li>
  <li><a href="#accelerations" id="toc-accelerations" class="nav-link" data-scroll-target="#accelerations"><span class="header-section-number">10.6</span> Accelerations</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./methods.html">Part III. Methods and algorithms</a></li><li class="breadcrumb-item"><a href="./methods.html"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Overview of methods</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-methods_overview" class="quarto-section-identifier"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Overview of methods</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Part III of this book describes the statistical and algorithmic methods that underlie <code>sceptre</code>. Part III primarily is oriented towards methods developers. Users who wish to apply <code>sceptre</code> to analyze their data — but do not need to know about the specifics of the methods contained within the software — safely can skip this part.</p>
</div>
</div>
<p>Several statistical tasks are involved in the analysis of single-cell CRISPR screen data, including assigning gRNAs to cells, testing for association between gRNAs and the expression of responses (such as genes), and integrating information across gRNAs that target the same site. This chapter provides a high-level overview of the statistical methods that <code>sceptre</code> employs to carry out these analysis tasks.</p>
<section id="notation" class="level2" data-number="10.1">
<h2 data-number="10.1" class="anchored" data-anchor-id="notation"><span class="header-section-number">10.1</span> Notation</h2>
<p>We begin by introducing some notation that we use throughout the chapter. Let <span class="math inline">\(\mathbb{N} = \{0, 1, 2, \dots\}\)</span> denote the set of nonnegative integers. For a given single-cell CRISPR screen dataset, let <span class="math inline">\(p\in\mathbb{N}\)</span> denote the number of responses, <span class="math inline">\(r\in\mathbb{N}\)</span> the number of gRNAs, and <span class="math inline">\(n\in\mathbb{N}\)</span> the number of cells in the dataset. Next, let <span class="math inline">\(Y\in \mathbb{N}^{p \times n}\)</span> be the matrix of response UMI counts, where responses are in the rows and cells in the columns. A given entry <span class="math inline">\(Y_{ij}\)</span> of <span class="math inline">\(Y\)</span> indicates the number of UMIs from response <span class="math inline">\(i\)</span> sequenced in cell <span class="math inline">\(j\)</span>. Similarly, let <span class="math inline">\(G \in \mathbb{N}^{r \times n}\)</span> be the matrix of gRNA UMI counts; a given entry <span class="math inline">\(G_{ij}\)</span> of <span class="math inline">\(G\)</span> indicates the number of UMIs from gRNA <span class="math inline">\(i\)</span> sequenced in cell <span class="math inline">\(j\)</span>. Finally, let <span class="math inline">\(Z_1, \dots, Z_n \in \mathbb{R}^{d}\)</span> be the cell-specific covariates (e.g., <code>response_n_umis</code>, <code>response_n_nonzero</code>, <code>response_p_mito</code>, <code>grna_n_umis</code>, <code>grna_n_nonzero</code>, <code>batch</code>, etc.), where we have included a “1” in each <span class="math inline">\(Z_j\)</span> to serve as an intercept term. (We assume that the count-based covariates, such as <code>grna_n_nonzero</code> and <code>grna_n_umis</code>, have been log-transformed.) Finally, let <span class="math inline">\(Z \in \mathbb{R}^{n \times d}\)</span> denote the vectors <span class="math inline">\(Z_1, \dots, Z_n\)</span> assembled into a matrix. Throughout, we use an uppercase letter (e.g., <span class="math inline">\(G_{ij}\)</span>) to refer to a random variable and a lowercase letter (e.g., <span class="math inline">\(g_{ij}\)</span>) to refer to the realized value of the random variable.</p>
<p>The first statistical task involved in single-cell CRISPR screen analysis is to assign gRNAs to cells. The gRNA assignment task involves leveraging the gRNA count matrix <span class="math inline">\(G\)</span> (and possibly the covariate matrix <span class="math inline">\(Z\)</span>) to impute the (unobserved) binary matrix <span class="math inline">\(X \in \{0,1\}^{r \times n}\)</span> of gRNA presences and absences, where a given entry <span class="math inline">\(X_{ij}\)</span> of <span class="math inline">\(X\)</span> is defined to be <span class="math inline">\(1\)</span> (resp., <span class="math inline">\(0\)</span>) if gRNA <span class="math inline">\(i\)</span> is present (resp., absent) in cell <span class="math inline">\(j\)</span>. <code>sceptre</code> implements three gRNA assignment strategies: the thresholding method, maximum method, and the mixture method. All three methods account for background contamination, the phenomenon by which gRNA reads sometimes map to cells that do not contain the corresponding gRNA. (See <a href="./assign-grnas.html">Assign gRNAs</a> for a real-data example of background contamination.) We describe each method in greater depth here.</p>
<section id="thresholding-method" class="level3" data-number="10.1.1">
<h3 data-number="10.1.1" class="anchored" data-anchor-id="thresholding-method"><span class="header-section-number">10.1.1</span> Thresholding method</h3>
<p>The thresholding method assigns a gRNA to a cell if the UMI count of the gRNA in the cell exceeds some integer threshold <span class="math inline">\(c \in \mathbb{N}\)</span>. Formally, the thresholding method sets <span class="math inline">\(X_{ij}\)</span> to <span class="math inline">\(1\)</span> if <span class="math inline">\(G_{ij} \geq c\)</span> and to <span class="math inline">\(0\)</span> if <span class="math inline">\(G_{ij} &lt; c\)</span>. The default value for <span class="math inline">\(c\)</span> is 5 (as proposed in <span class="citation" data-cites="gasperini2019">Gasperini et al. (<a href="references.html#ref-gasperini2019" role="doc-biblioref">2019</a>)</span> and further validated by <span class="citation" data-cites="barry2022c">Barry, Roeder, and Katsevich (<a href="references.html#ref-barry2022c" role="doc-biblioref">2024</a>)</span>). An important special case involves setting <span class="math inline">\(c\)</span> to <span class="math inline">\(1\)</span>, which implements the “naive” (but occasionally useful) strategy of assigning any gRNA expressed in a given cell to that cell (and thus ignoring background contamination).</p>
</section>
<section id="maximum-method" class="level3" data-number="10.1.2">
<h3 data-number="10.1.2" class="anchored" data-anchor-id="maximum-method"><span class="header-section-number">10.1.2</span> Maximum method</h3>
<p>The maximum method assigns the gRNA that exhibits the greatest UMI count in a given cell to that cell. Formally, consider a given cell <span class="math inline">\(j\)</span>. Let <span class="math inline">\(i^* \in \{1, \dots, r\}\)</span> be the index such that <span class="math display">\[ G_{i^*j} = \max_{i \in \{1, \dots, r\}}{G_{ij}}.\]</span> (If multiple indices satisfy this criterion, select <span class="math inline">\(i^*\)</span> among these arbitrarily.) We assign gRNA <span class="math inline">\(i^*\)</span> to cell <span class="math inline">\(j\)</span>, i.e.&nbsp;we set <span class="math inline">\(X_{i^*j}\)</span> to <span class="math inline">\(1\)</span> and <span class="math inline">\(X_{ij}\)</span> to <span class="math inline">\(0\)</span> for <span class="math inline">\(i \neq i^*\)</span>. In carrying out the maximum assignment step, <code>sceptre</code> also flags cells that likely contain multiple gRNAs. Let <span class="math inline">\(u \in [0,1]\)</span> be a user-specified threshold (default value <span class="math inline">\(0.8\)</span>). Suppose that the gRNA assigned to cell <span class="math inline">\(j\)</span> constitutes fewer than <span class="math inline">\(u\)</span> of the UMIs in that cell. In other words, suppose that</p>
<p><span class="math display">\[
\frac{G_{i^*j}}{\sum_{i=1}^{r} G_{ij}} &lt; u.
\]</span></p>
<p>Then cell <span class="math inline">\(j\)</span> is flagged as containing multiple gRNAs. Similarly, <code>scepre</code> flags cells that likely contain zero gRNAs. Suppose that the sum of the gRNA UMI counts in a given cell <span class="math inline">\(j\)</span> is less than <span class="math inline">\(t \in \mathbb{N}\)</span> (default value 5):</p>
<p><span class="math display">\[
\sum_{i = 1}^r G_{ij} &lt; t.
\]</span></p>
<p>Then cell <span class="math inline">\(j\)</span> is flagged as containing zero gRNAs. Cells containing zero gRNAs or multiple gRNAs are removed as part of the cellwise QC step. (Note that if multiple gRNAs are tied for most highly expressed in a given cell, and if <span class="math inline">\(u &gt; 0.5\)</span>, then that cell is flagged as containing multiple gRNAs, per the above rule.)</p>
</section>
<section id="sec-mixture_method" class="level3" data-number="10.1.3">
<h3 data-number="10.1.3" class="anchored" data-anchor-id="sec-mixture_method"><span class="header-section-number">10.1.3</span> Mixture method</h3>
<p>The mixture method assigns gRNAs to cells using a latent variable generalized linear model (GLM). Consider a given gRNA <span class="math inline">\(i\)</span>. Let <span class="math inline">\(G_j\)</span> be the UMI count of gRNA <span class="math inline">\(i\)</span> in cell <span class="math inline">\(j\)</span>, and let <span class="math inline">\(X_j\)</span> be the (unobserved) variable indicating whether gRNA <span class="math inline">\(i\)</span> is present (<span class="math inline">\(X_j = 1\)</span>) or absent (<span class="math inline">\(X_j = 0\)</span>) in cell <span class="math inline">\(j\)</span>. (We suppress the <span class="math inline">\(i\)</span> subscript for notational compactness.) We model the gRNA UMI counts using a latent variable Poisson GLM:</p>
<p><span id="eq-latent-variable-glm"><span class="math display">\[
\begin{cases}
G_j | \mu_j \sim \textrm{Pois}(\mu_j) \\
\log(\mu_j | X_j, Z_j) = \gamma X_j + \beta^T Z_j \\
X_j \sim \textrm{Bernoulli}(\pi).
\end{cases}
\tag{10.1}\]</span></span></p>
<p>Here, <span class="math inline">\(\mu_j\)</span> is the mean expression level of gRNA <span class="math inline">\(i\)</span> in cell <span class="math inline">\(j\)</span> (given the covariates); <span class="math inline">\(\gamma \in \mathbb{R}\)</span> and <span class="math inline">\(\beta \in \mathbb{R}^{d}\)</span> are the (unknown) regression coefficients; and <span class="math inline">\(\pi \in [0,1]\)</span> is the (unknown) probability that gRNA <span class="math inline">\(i\)</span> is present in a given cell. We fit the model <a href="#eq-latent-variable-glm" class="quarto-xref">Equation&nbsp;<span>10.1</span></a> using an EM algorithm, producing estimates <span class="math inline">\(\hat{\beta}\)</span>, <span class="math inline">\(\hat{\gamma}\)</span> and <span class="math inline">\(\hat{\pi}\)</span> for the model coefficients <span class="math inline">\(\beta\)</span>, <span class="math inline">\(\gamma\)</span>, and <span class="math inline">\(\pi\)</span>. Using these estimates, we can compute the probability <span class="math inline">\(T_{ij} := \mathbb{P}(X_{ij} = 1)\)</span> that a given cell <span class="math inline">\(j\)</span> contains gRNA <span class="math inline">\(i\)</span>. (The probabilities <span class="math inline">\(T_{i1}, \dots, T_{in}\)</span> are sometimes called “posterior probabilities.”) Finally, we threshold the posterior probabilities at some threshold <span class="math inline">\(u\)</span> (default value 0.8) to assign gRNA <span class="math inline">\(i\)</span> to the cells, i.e.&nbsp;we set <span class="math inline">\(X_{ij} = 1\)</span> if <span class="math inline">\(T_{ij} &gt; u\)</span> and <span class="math inline">\(X_{ij} = 0\)</span> if <span class="math inline">\(T_{ij} \leq u\)</span>. An advantage of the Poisson GLM framework is that it enables us to account for cell-specific covariates that might affect the expression level of the gRNA, such as the number of gRNA UMIs sequenced in a given cell or batch. Formulating the model <a href="#eq-latent-variable-glm" class="quarto-xref">Equation&nbsp;<span>10.1</span></a> is fairly straightforward; fitting the model to data in a fast and numerically stable way is more challenging. <code>sceptre</code> leverages a novel variant of the EM algorithm for this purpose, which we describe below.</p>
<p><strong>Approximating the model <a href="#eq-latent-variable-glm" class="quarto-xref">Equation&nbsp;<span>10.1</span></a> with a simpler model</strong>. We begin by approximating the latent variable model <a href="#eq-latent-variable-glm" class="quarto-xref">Equation&nbsp;<span>10.1</span></a> with a simpler latent variable model that is easier to estimate. First, we obtain accurate estimates for the parameter <span class="math inline">\(\beta\)</span> by exploiting the fact that the gRNA is present in only a small fraction (typically <span class="math inline">\(&lt; 2\%\)</span>) of cells. Let <span class="math inline">\(f(g_j; \mu_j)\)</span> denote the probability mass function of the Poisson distribution with mean <span class="math inline">\(\mu_j\)</span> evaluated at <span class="math inline">\(g_j\)</span>, i.e.,</p>
<p><span class="math display">\[
f(g_j; \mu_j) = \frac{\mu_j^{g_j} e^{-\mu_j}}{g_j!}.
\]</span>Conditioning on the covariates (i.e., treating <span class="math inline">\(X_j = x_j\)</span> and <span class="math inline">\(Z_j = z_j\)</span> as fixed), we can express the log-likelihood of the GLM in <a href="#eq-latent-variable-glm" class="quarto-xref">Equation&nbsp;<span>10.1</span></a> as follows:<br>
<span class="math display">\[
\begin{multline}
L(\beta, \gamma) = \sum_{j=1}^n \log \left[f(g_j;\mu_j)\right] = \sum_{j=1}^n \log \left[f(g_j; \exp(\gamma x_j + \beta^T z_j)) \right] \\ = \underbrace{\sum_{j:x_j = 1} \log \left[ f(g_j; \exp(\gamma + \beta^T z_j)) \right]}_{\textrm{few terms}} + \underbrace{\sum_{j: x_j = 0} \log \left[ f(g_j; \exp(\beta^T z_j)) \right]}_\textrm{many terms} \\ \approx \sum_{j=1}^n \log \left[f(g_j; \exp(\beta^T z_j)) \right].
\end{multline}
\]</span></p>
<p>In words, the gRNA indicator <span class="math inline">\(x_j\)</span> is equal to zero in the large majority of cells, and so we can approximate the GLM in <a href="#eq-latent-variable-glm" class="quarto-xref">Equation&nbsp;<span>10.1</span></a> with the GLM that results from excluding <span class="math inline">\(x_j\)</span> from the model:</p>
<p><span id="eq-simplified_glm"><span class="math display">\[
\begin{cases}
G_j | \mu_j \sim \textrm{Pois} (\mu_j) \\
\log(\mu_j | z_j) = \beta^T Z_j.
\end{cases}
\tag{10.2}\]</span></span></p>
<p>We can estimate the GLM <a href="#eq-simplified_glm" class="quarto-xref">Equation&nbsp;<span>10.2</span></a> using standard maximum likelihood estimation, as all the variables in this GLM are observed. Doing so yields an estimate <span class="math inline">\(\hat{\beta}\)</span> for <span class="math inline">\(\beta\)</span>. Assuming that <span class="math inline">\(\hat{\beta} \approx \beta\)</span> (which holds for large <span class="math inline">\(n\)</span> and small <span class="math inline">\(\pi\)</span>), we can write</p>
<p><span class="math display">\[\gamma X_j + \beta Z_j \approx \gamma X_j + \hat{\beta} Z_j = \gamma X_j + o_j,\]</span>where we have set <span class="math inline">\(o_j\)</span> to <span class="math inline">\(\hat{\beta}^TZ_j\)</span>, i.e.&nbsp;the <span class="math inline">\(j\)</span>th fitted value (on the scale of the cannonical parameter) of the GLM <a href="#eq-simplified_glm" class="quarto-xref">Equation&nbsp;<span>10.2</span></a>. Finally, we propose a simplified model for expression of the gRNA:</p>
<p><span id="eq-simplified_glm_2"><span class="math display">\[\begin{cases}
G_j | \mu_j \sim \textrm{Pois}(\mu_j) \\
\log(\mu_j | X_j) = \gamma X_j + o_j \\
X_j \sim \textrm{Bernoulli}(\pi).
\end{cases}
\tag{10.3}\]</span></span></p>
<p>Here, the <span class="math inline">\(o_j\)</span>s are offset terms in the GLM. Notice that the GLM in <a href="#eq-simplified_glm_2" class="quarto-xref">Equation&nbsp;<span>10.3</span></a> does not include covariates or an intercept term; rather, all information about the covariates and the baseline expression level of the gRNA has been “encoded” into the offsets <span class="math inline">\(o_1, \dots, o_n\)</span>. In summary we (i) estimated <span class="math inline">\(\beta\)</span> using the GLM <a href="#eq-simplified_glm" class="quarto-xref">Equation&nbsp;<span>10.2</span></a> and then (ii) replaced <span class="math inline">\(\beta\)</span> in <a href="#eq-latent-variable-glm" class="quarto-xref">Equation&nbsp;<span>10.1</span></a> with its estimate, yielding the model <a href="#eq-simplified_glm_2" class="quarto-xref">Equation&nbsp;<span>10.3</span></a>. The model <a href="#eq-simplified_glm_2" class="quarto-xref">Equation&nbsp;<span>10.3</span></a> is a good approximation to <a href="#eq-latent-variable-glm" class="quarto-xref">Equation&nbsp;<span>10.1</span></a> in the sense that the maximum likelihood estimates for <span class="math inline">\(\gamma\)</span> and <span class="math inline">\(\pi\)</span> in <a href="#eq-simplified_glm_2" class="quarto-xref">Equation&nbsp;<span>10.3</span></a> are close to the corresponding estimates for these parameters in <a href="#eq-latent-variable-glm" class="quarto-xref">Equation&nbsp;<span>10.1</span></a> when <span class="math inline">\(n\)</span> is large and <span class="math inline">\(\pi\)</span> is small (as is the case on most single-cell CRISPR screen datasets). We turn our attention to estimating the model <a href="#eq-simplified_glm_2" class="quarto-xref">Equation&nbsp;<span>10.3</span></a>, treating the offset terms <span class="math inline">\(o_1, \dots, o_n\)</span> as known and fixed.</p>
<p><strong>EM algorithm</strong>. We derive an EM algorithm to estimate the model <a href="#eq-simplified_glm_2" class="quarto-xref">Equation&nbsp;<span>10.3</span></a>. Let <span class="math inline">\(\theta = (\gamma, \pi)\)</span> denote the unknown model parameters. We begin by writing down the complete-data likelihood <span class="math inline">\(l\)</span> of this model, which is the likelihood that would result if <span class="math inline">\(X_1, \dots, X_n\)</span> <em>had</em> been observed.</p>
<p><span class="math display">\[
\begin{multline*}
l(\theta) = \prod_{j=1}^n \mathbb{P}(G_j = g_j, X_j = x_j) = \prod_{j=1}^n\mathbb{P}(G_j = g_j | X_j = x_j) \mathbb{P}(X_j = x_j) \\ = \prod_{j=1}^n f(g_j; \exp( \gamma x_j + o_j))\left[\pi^{x_i} (1-\pi)^{1-x_i} \right].
\end{multline*}
\]</span></p>
<p>We obtain the complete-data log-likelihood <span class="math inline">\(L\)</span> by taking the log of <span class="math inline">\(l\)</span>:</p>
<p><span class="math display">\[
L(\theta) = \log(l(\theta)) = \sum_{j=1}^n \log\left[ f(g_j; \exp(\gamma x_j + o_j)\right] + \sum_{j=1}^n x_j \log(\pi) + (1-x_j)(1-\pi).
\]</span></p>
<p>We derive the E and M steps for the EM algorithm in this model.</p>
<p><u>E step</u>: The E step entails computing the membership probability of each cell (i.e., the probability that each cell contains the gRNA given the current parameter estimates and the observed gRNA counts). Let <span class="math inline">\(\theta^{(t)} = (\gamma^{(t)}, \pi^{(t)})\)</span> be the parameter estimate for <span class="math inline">\(\theta\)</span> at the <span class="math inline">\(t\)</span>th iteration of the algorithm. The <span class="math inline">\(j\)</span>th membership probability at the <span class="math inline">\(t\)</span>th iteration of the algorithm <span class="math inline">\(T^{(t)}_j\)</span> is defined as <span class="math inline">\(T^{(t)}_j = \mathbb{P}(X_j = 1 | G_j = g_j, \theta^{(t)}).\)</span> Let <span class="math inline">\([\mu_j(k)]^{(t)}\)</span> be the mean gRNA UMI count in the <span class="math inline">\(j\)</span>th cell at the <span class="math inline">\(t\)</span>th iteration of the algorithm that results from setting <span class="math inline">\(x_j\)</span> to <span class="math inline">\(k \in \{0,1\}\)</span>, i.e.,</p>
<p><span class="math display">\[
[\mu_j(k)]^{(t)} = \exp( \gamma^{(t)} \cdot k + o_j ).
\]</span></p>
<p>Applying Bayes rule, we can express the membership probability <span class="math inline">\(T^{(t)}_j\)</span> as</p>
<p><span class="math display">\[
\begin{multline*}
T^{(t)}_j = \mathbb{P}(X_j = 1 | G_j = g_j, \theta^{(t)}) \\ = \frac{\mathbb{P}(G_j = g_j | X_j = 1, \theta^{(t)})\mathbb{P}(X_j = 1 | \theta^{(t)})}{ \sum_{k=0}^1 \mathbb{P}(G_j = g_j | X_j = k, \theta^{(t)}) \mathbb{P}(X_j = k | \theta^{(t)})} \\ = \left(\frac{\mathbb{P}(G_j = g_j | X_j = 0, \theta^{(t)}) \mathbb{P}(X_j = 0)}{\mathbb{P}( G_j = g_j | X_j = 1, \theta^{(t)}) \mathbb{P}(X_j = 1)} +1\right)^{-1}\\ = \left(\frac{f(g_j; [\mu_j(0)]^{(t)})(1-\pi^{(t)}))}{f(g_j; [\mu_j(1)]^{(t)})\pi^{(t)})} + 1 \right)^{-1} = \left(\exp(q_j^{(t)}) + 1 \right)^{-1},
\end{multline*}
\]</span> where we define <span class="math display">\[q_j^{(t)} := \log\left( \frac{f(g_j; [\mu_j(0)]^{(t)})(1-\pi^{(t)})}{f(g_j; [\mu_j(1)]^{(t)})\pi^{(t)}} \right).\]</span></p>
<p>Plugging in the Poisson probability mass function for <span class="math inline">\(f\)</span>, we can express <span class="math inline">\(q_j^{(t)}\)</span> is follows.</p>
<p><span id="eq-q_j_expression"><span class="math display">\[
\begin{multline*}
q_j^{(t)} := \log(1-\pi^{(t)}) - \log(\pi^{(t)}) + g_j \left(\log([\mu_j(0)]^{(t)}) - \log([\mu_j(1)]^{(t)}) \right) \\ + [\mu_j(1)]^{(t)} - [\mu_j(0)]^{(t)}.
\end{multline*}
\tag{10.4}\]</span></span></p>
<p>This expression <a href="#eq-q_j_expression" class="quarto-xref">Equation&nbsp;<span>10.4</span></a> for <span class="math inline">\(q_j^{(t)}\)</span> is numerically stable and fast to evaluate. In summary the M step consists of computing <span class="math inline">\(T^{(t)}_j\)</span> for all <span class="math inline">\(j\in\{1, \dots, n\}\)</span> by computing <span class="math inline">\(q^{(t)}_j\)</span> (using <a href="#eq-q_j_expression" class="quarto-xref">Equation&nbsp;<span>10.4</span></a>) and then evaluating <span class="math inline">\(T^{(t)}_j = \exp(q_j^{(t)} + 1)^{-1}.\)</span></p>
<p><u>M step</u>: The M-step involves maximizing the so-called “Q function,” which is the function that results from taking the expectation of the complete-data log-likelihood with respect to the <span class="math inline">\(X_j\)</span>s while conditioning on the <span class="math inline">\(G_j\)</span>s and the current parameter estimates <span class="math inline">\(\theta^{(t)}\)</span>. Formally, the Q function <span class="math inline">\(Q(\theta | \theta^{(t)})\)</span> is defined as <span class="math inline">\(Q(\theta|\theta^{(t)}) = \mathbb{E}_{X_1, \dots, X_n}[L(\theta) | G_1 = g_1, \dots, G_n = g_n \theta^{(t)}]\)</span>. We can express the Q function as</p>
<p><span id="eq-q_function"><span class="math display">\[
\begin{multline*}
Q(\theta|\theta^{(t)}) = \sum_{j=1}^n T^{(t)}_j \log(\pi) + \sum_{j=1}^n (1 - T_j^{(t)})\log(1-\pi) \\ + \sum_{j=1}^n T_j^{(t)} \log \left[ f\left(g_j; \exp[\gamma + o_j] \right) \right] + \sum_{j=1}^n (1 - T^{(t)}_j) \log \left[f(g_j; \exp(o_j) \right].
\end{multline*}
\tag{10.5}\]</span></span></p>
<p>The goal of the M step to identify the parameter <span class="math inline">\(\theta = (\pi, \gamma)\)</span> that maximizes <a href="#eq-q_function" class="quarto-xref">Equation&nbsp;<span>10.5</span></a>. The first two terms of <a href="#eq-q_function" class="quarto-xref">Equation&nbsp;<span>10.5</span></a> are a function of <span class="math inline">\(\pi\)</span>, and the last two terms are a function of <span class="math inline">\(\gamma\)</span>. Thus, we can optimize these sets of terms separately.</p>
<p>To find the maximizer in <span class="math inline">\(\pi\)</span>, we differentiate the first two terms of <a href="#eq-q_function" class="quarto-xref">Equation&nbsp;<span>10.5</span></a> with respect to <span class="math inline">\(\pi\)</span>, yielding</p>
<p><span id="eq-m_step_0"><span class="math display">\[
\frac{\sum_{j=1}^n T_j^{(t)}}{\pi} - \frac{\sum_{j=1}^n (1 - T_j^{(t)})}{1 - \pi}.
\tag{10.6}\]</span></span></p>
<p>Setting <a href="#eq-m_step_0" class="quarto-xref">Equation&nbsp;<span>10.6</span></a> to zero and solving for <span class="math inline">\(\pi\)</span> produces the maximizer <span class="math inline">\(\pi^{(t+1)}\)</span>:</p>
<p><span id="eq-pi_update"><span class="math display">\[\pi^{(t+1)} = (1/n) \sum_{j=1}^n T_j^{(t)}. \tag{10.7}\]</span></span></p>
<p>We turn our attention to the last two terms of <a href="#eq-q_function" class="quarto-xref">Equation&nbsp;<span>10.5</span></a>. The final term is not a function of <span class="math inline">\(\gamma\)</span> and thus can be ignored. We rewrite the penultimate term as follows:</p>
<p><span id="eq-m_step_1"><span class="math display">\[
\begin{multline*}
\sum_{j=1}^n T^{(t)}_j \log\left[ f(g_j; \exp[\gamma + o_j])\right] \\ = \sum_{j=1}^n T^{(t)}_j \log\left[ \frac{\exp(\gamma + o_j)^{g_j} \exp(-\exp[\gamma + o_j])}{g_j!} \right] \\ =
\sum_{j=1}^n T_j^{(t)}\left[ g_j(\gamma + o_j) - \exp(\gamma + o_j) - \log(g_j!) \right].
\end{multline*}
\tag{10.8}\]</span></span></p>
<p>The derivative of <a href="#eq-m_step_1" class="quarto-xref">Equation&nbsp;<span>10.8</span></a> with respect to <span class="math inline">\(\gamma\)</span> is</p>
<p><span id="eq-m_step_2"><span class="math display">\[
\begin{multline*}
\sum_{j=1}^n T^{(t)}_j g_j - T^{(t)}_j \exp(\gamma + o_j) = \sum_{j=1}^n T^{(t)}_j g_j - \exp(\gamma) \sum_{j=1}^n T_j^{(t)} \exp(o_j).
\end{multline*}
\tag{10.9}\]</span></span></p>
<p>Finally, setting <a href="#eq-m_step_2" class="quarto-xref">Equation&nbsp;<span>10.9</span></a> to zero and solving for <span class="math inline">\(\gamma\)</span> yields the maximizer</p>
<p><span id="eq-gamma_update"><span class="math display">\[
\gamma^{(t+1)} = \log\left(\frac{\sum_{j=1}^n T^{(t)}_j y_j }{\sum_{j=1}^n T^{(t)}_j e^{o_j} }\right).
\tag{10.10}\]</span></span></p>
<p>In summary the M step entails computing the updated parameter estimates <span class="math inline">\(\pi^{(t+1)}\)</span> and <span class="math inline">\(\gamma^{(t+1)}\)</span> using the formulas <a href="#eq-pi_update" class="quarto-xref">Equation&nbsp;<span>10.7</span></a> and <a href="#eq-gamma_update" class="quarto-xref">Equation&nbsp;<span>10.10</span></a>, respectively.</p>
<p><u>Convergence</u>: The incomplete-data likelihood (which we obtain by integrating the complete-data likelihood with respect to the <span class="math inline">\(X_j\)</span>s) is</p>
<p><span class="math display">\[
l_\textrm{incomplete}(\theta) = \prod_{j=1}^n f(g_j; \gamma + o_j) \pi + f(g_j; o_j)(1-\pi).
\]</span></p>
<p>The incomplete-data log-likelihood is</p>
<p><span class="math display">\[
L_\textrm{incomplete}(\theta) = \log(l_\textrm{incomplete}(\theta)) = \sum_{j=1}^n \log\left[ f(g_j; \gamma + o_j) \pi + f(g_j; o_j)(1-\pi) \right].
\]</span></p>
<p>Note that the incomplete-data log-likelihood — in contrast to the complete-data log-likelihood — is computable (albeit hard to optimize directly). We iterate between E and M steps until <span class="math inline">\(L_\textrm{incomplete}\)</span> converges. We declare that the sequence of estimates <span class="math inline">\(\theta^{(0)}, \theta^{(1)}, \theta^{(2)}, \dots\)</span> has converged when</p>
<p><span class="math display">\[
\frac{|L_\textrm{incomplete}(\theta^{(t+1)}) - L_\textrm{incomplete}(\theta^{(t)})|}{ \min\left\{ |L_\textrm{incomplete}(\theta^{(t+1)})|, |L_\textrm{incomplete}(\theta^{(t)}) | \right\}} &lt; \epsilon
\]</span></p>
<p>for some small <span class="math inline">\(\epsilon &gt; 0\)</span> (in the code, <span class="math inline">\(\epsilon = 0.5 \cdot 10^{-4}\)</span>). We set the final parameter estimates <span class="math inline">\(\hat{\pi}\)</span> and <span class="math inline">\(\hat{\gamma}\)</span> to <span class="math inline">\(\pi^{(t+1)}\)</span> and <span class="math inline">\(\gamma^{(t+1)}\)</span>. Additionally, we use the final membership probabilities <span class="math inline">\(T^{(t+1)}_1, \dots, T^{(t+1)}_n\)</span> to assign the gRNA to cells.</p>
<p>As is standard, we run the EM algorithm several times over random starting estimates for <span class="math inline">\(\pi\)</span> and <span class="math inline">\(\gamma\)</span> to improve chances of converging to the global maximizer of the incomplete-data likelihood. We use the run whose estimates yield the greatest incomplete-data log-likelihood to assign gRNAs to cells.</p>
</section>
</section>
<section id="sec-defn_trt_cntrl_grp" class="level2" data-number="10.2">
<h2 data-number="10.2" class="anchored" data-anchor-id="sec-defn_trt_cntrl_grp"><span class="header-section-number">10.2</span> Definition of “treatment group” and “control group”</h2>
<p>To test for association between a given gRNA (or gRNA target) and a response, <code>sceptre</code> divides the cells into two groups: the “treatment group” and the “control group.” <code>sceptre</code> tests for differential expression of the response across these two groups of cells, yielding a p-value for the test of association between the gRNA and response. Defining the cells that constitute the treatment group and control group is somewhat subtle and depends on the analysis parameters of gRNA integration strategy (i.e., union, singleton, or Bonferroni), control group (i.e., complement set or NT cells), and analysis type (i.e., discovery analysis or calibration check). (See <a href="./set-analysis-parameters.html">Set analysis parameters</a> for a discussion of these parameters.) This section aims to carefully define “treatment group” and “control group,” in particular as a function of the aforementioned analysis parameters.</p>
<p>We first introduce some notation. Let <span class="math inline">\(\mathcal{S} =\{1, \dots, n\}\)</span> denote the entire set of cells. Let <span class="math inline">\(X \in \{0,1\}^{r \times n}\)</span> denote the matrix of imputed gRNA presences and absences (as determined in the gRNA assignment step). Index the gRNAs by <span class="math inline">\(\{1, \dots, r\}\)</span>. For <span class="math inline">\(i \in \{1, \dots, r\}\)</span>, let <span class="math inline">\(G_i\)</span> denote the set of cells that gRNA <span class="math inline">\(i\)</span> has infected, i.e.&nbsp;<span class="math inline">\(G_i := \{j: X_{ij} = 1\}.\)</span> Let <span class="math inline">\(\mathcal{N} \subset \{1, \dots, r\}\)</span> denote the set of non-targeting gRNAs, and let <span class="math inline">\(\mathcal{T} = \{1,\dots,r\} \setminus \mathcal{N}\)</span> denote the set of targeting gRNAs. (Typically, <span class="math inline">\(\mathcal{T}\)</span> consists of both discovery gRNAs and positive control gRNAs.) Note that in low MOI, after applying quality control, each cell contains a single gRNA, implying that the sets <span class="math inline">\(G_1, \dots, G_r\)</span> are disjoint, i.e.</p>
<p><span class="math display">\[
\bigcap_{i=1}^r G_i = \emptyset.
\]</span></p>
<p>This is not the case in high-MOI; in that setting the intersection of <span class="math inline">\(G_{i_1}\)</span> and <span class="math inline">\(G_{i_2}\)</span> for <span class="math inline">\(i_1 \neq i_2\)</span> is nonempty (in general). We proceed by taking cases on gRNA integration strategy, first considering the union integration strategy and then considering the singleton and Bonferroni integration strategies.</p>
<p><strong>Union gRNA integration strategy.</strong> We first consider the “union” gRNA integration strategy. The union integration strategy involves combining multiple gRNAs into a single “combined” gRNA and then testing this combined gRNA against responses as if it were a singleton gRNA. Suppose that we are running a discovery analysis, and let <span class="math inline">\(\mathcal{I} \subset \mathcal{T}\)</span> be a given set of gRNAs that targets the same site. The table below defines the treatment group, the complement set control group, and the NT cells control group relative to <span class="math inline">\(\mathcal{I}\)</span>.</p>
<table class="table">
<caption>Union gRNA integration strategy, discovery analysis.</caption>
<colgroup>
<col style="width: 27%">
<col style="width: 44%">
<col style="width: 27%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">Treatment group</td>
<td style="text-align: center;">Complement set control group</td>
<td style="text-align: center;">NT cells control group</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\cup_{i \in \mathcal{I}} G_i\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathcal{S} \setminus \cup_{i \in \mathcal{I}} G_i\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\cup_{i \in \mathcal{N}} G_i\)</span></td>
</tr>
</tbody>
</table>
<p>Next, suppose that we are running a calibration check analysis (again using the union gRNA integration strategy). Let <span class="math inline">\(\mathcal{L} \subset \mathcal{N}\)</span> be a set of non-targeting gRNAs that has been randomly combined into a “negative control” gRNA target. (By default, <span class="math inline">\(|\mathcal{L}| = |\mathcal{I}|\)</span>, i.e., the discovery target and negative control target contain the same number of gRNAs.) The treatment group, complement set control group, and NT cells control group are defined relative to <span class="math inline">\(\mathcal{L}\)</span> as follows.</p>
<table class="table">
<caption>Union gRNA integration strategy, calibration check.</caption>
<colgroup>
<col style="width: 26%">
<col style="width: 36%">
<col style="width: 36%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">Treatment group</td>
<td style="text-align: center;">Complement set control group</td>
<td style="text-align: center;">NT cells control group</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\cup_{l \in \mathcal{L}} G_l\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathcal{S} \setminus \cup_{l \in \mathcal{L}} G_l\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\cup_{l \in (\mathcal{N} \setminus \mathcal{L})} G_l\)</span></td>
</tr>
</tbody>
</table>
<p><strong>Singleton and Bonferroni gRNA integration strategies</strong>. Next, we consider the “singleton” and “Bonferroni” gRNA integration strategies. Both strategies involve testing singleton gRNAs for association against responses. Suppose that we are running a discovery analysis, and let <span class="math inline">\(i \in \mathcal{T}\)</span> be a given targeting gRNA. The table below defines the treatment group, complement set control group, and NT cells control group relative to <span class="math inline">\(i\)</span>.</p>
<table class="table">
<caption>Singleton/Bonferroni gRNA integration strategy, discovery analysis.</caption>
<colgroup>
<col style="width: 26%">
<col style="width: 35%">
<col style="width: 38%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">Treatment group</td>
<td style="text-align: center;">Complement set control group</td>
<td style="text-align: center;">NT cells control group</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(G_i\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathcal{S} \setminus G_i\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\cup_{i \in \mathcal{N}} G_i\)</span></td>
</tr>
</tbody>
</table>
<p>Finally, suppose that we are running a calibration check using the singleton or Bonferroni gRNA integration strategy. Let <span class="math inline">\(l \in \mathcal{N}\)</span> be a non-targeting gRNA. The treatment group, complement set control group, and NT cells control group are defined relative to <span class="math inline">\(l\)</span> as follows.</p>
<table class="table">
<caption>Singleton/Bonferroni gRNA integration strategy, calibration check.</caption>
<colgroup>
<col style="width: 26%">
<col style="width: 27%">
<col style="width: 45%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">Treatment group</td>
<td style="text-align: center;">Complement set control group</td>
<td style="text-align: center;">NT cells control group</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(G_l\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathcal{S} \setminus G_l\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\cup_{i \in (\mathcal{N}\setminus \{ l \} )} G_i\)</span></td>
</tr>
</tbody>
</table>
<p>Note that the Bonferroni gRNA integration strategy combines p-values across gRNAs that target the same site into a single “target-wide” p-value via a Bonferroni correction. Note also that the complement set is available as a control group in both low- and high-MOI settings, while the NT cells are available as a control group only in the low-MOI setting.</p>
</section>
<section id="differential-expression-testing" class="level2" data-number="10.3">
<h2 data-number="10.3" class="anchored" data-anchor-id="differential-expression-testing"><span class="header-section-number">10.3</span> Differential expression testing</h2>
<p>We next explicate the differential expression testing paradigm of <code>sceptre</code>. <code>sceptre</code> is based on the combination of a negative binomial model and a resampling framework for differential expression, improving its robustness relative to a standard negative binomial model. We begin by refining the notation introduced above. Consider a given target-response pair. Suppose that there are <span class="math inline">\(n\)</span> cells across the treatment and control groups. (We are abusing notation slightly here; in a low-MOI analysis in which we use the NT cells as our control group, the number of cells in a given pair is not equal to the number of cells in the whole dataset.) Let <span class="math inline">\(Y = [Y_1, \dots, Y_n]^T\)</span> be the vector of raw gene (or protein, etc.) UMI counts. Next, let <span class="math inline">\(X = [X_1, \dots, X_n]^T\)</span> be a binary vector indicating whether a given cell <span class="math inline">\(j\)</span> is in the treatment group (<span class="math inline">\(X_j = 1\)</span>) or the control group (<span class="math inline">\(X_j = 0\)</span>). Finally, let <span class="math inline">\(Z_1, \dots, Z_n \in \mathbb{R}^{d}\)</span> be the cell-specific covariates, where we have included a “1” in each <span class="math inline">\(Z_j\)</span> to serve as an intercept term. Finally, let <span class="math inline">\(Z \in \mathbb{R}^{n \times d}\)</span> denote the vectors <span class="math inline">\(Z_1, \dots, Z_n\)</span> assembled into a matrix, and let <span class="math inline">\([X, Z] \in \mathbb{R}^{n \times (d+1)}\)</span> denote the matrix that results from concatenating <span class="math inline">\(X\)</span> and <span class="math inline">\(Z\)</span>. Testing for association between a gRNA target and response involves three steps: first, “resampling” the treatment vector <span class="math inline">\(B\)</span> times to form “null” treatment vectors <span class="math inline">\(\tilde{X}_1, \dots \tilde{X}_B\)</span>; second, evaluating a negative binomial test statistic on the original treatment vector <span class="math inline">\(X\)</span> and null treatment vectors <span class="math inline">\(\tilde{X}_1, \dots, \tilde{X}_B\)</span>; and third, comparing the original test statistic to the null test statistics to compute a p-value. We describe each of these steps below.</p>
<section id="resampling-the-treatment-vector" class="level3" data-number="10.3.1">
<h3 data-number="10.3.1" class="anchored" data-anchor-id="resampling-the-treatment-vector"><span class="header-section-number">10.3.1</span> Resampling the treatment vector</h3>
<p>The first step is to “resample” the treatment vector <span class="math inline">\(X\)</span> to form <span class="math inline">\(B\)</span> “null” treatment vectors <span class="math inline">\(\tilde{X}_1, \dots, \tilde{X}_B\)</span>. The “null” treatment vectors are constructed such that they are not associated with the response vector <span class="math inline">\(Y\)</span>, enabling a natural comparison to the original treatment vector. <code>sceptre</code> provides two methods for resampling the original treatment vector: permutations and conditional resampling. One can set the <code>resampling_mechanism</code> argument of <code>set_analysis_parameters()</code> to <code>"permutations"</code> and <code>"crt"</code> to select between these options.</p>
<p>The permutation strategy simply involves permuting the <span class="math inline">\(X\)</span> vector <span class="math inline">\(B\)</span> times. More precisely, among the <span class="math inline">\(n!\)</span> possible permutations of <span class="math inline">\(X\)</span>, we sample <span class="math inline">\(B\)</span> permutations randomly (with replacement and uniformly over the set of all permutations), yielding <span class="math inline">\(\tilde{X}_1, \dots, \tilde{X}_B\)</span>.</p>
<p>The conditional resampling strategy involves resampling <span class="math inline">\(\tilde{X}_1, \dots, \tilde{X}_B\)</span> <em>conditional</em> on the values of the cell-specific covariates <span class="math inline">\(Z_1, \dots, Z_n\)</span>. It involves several steps. First, we model <span class="math inline">\(X_j\)</span> as a function of <span class="math inline">\(Z_j\)</span> using a logistic regression GLM:</p>
<p><span class="math display">\[
X_j \sim \textrm{Bern}(\mu_i); \quad \textrm{logit}(\mu_i) = \delta^TZ_j.
\]</span></p>
<p>Here, <span class="math inline">\(\delta^T \in \mathbb{R}^{d}\)</span> is an unknown regression coefficient, and <span class="math inline">\(\textrm{logit}\)</span> is the logit function <span class="math display">\[\textrm{logit}(\mu) = \log\left(\frac{\mu}{1 - \mu}\right).\]</span></p>
<p>We produce an estimate <span class="math inline">\(\hat{\delta}\)</span> for <span class="math inline">\(\delta\)</span> by regressing <span class="math inline">\(X\)</span> onto <span class="math inline">\(Z\)</span> via a logistic GLM. Next, we estimate the conditional mean <span class="math inline">\(\hat{\mu}_j\)</span> of <span class="math inline">\(X_j\)</span> given <span class="math inline">\(Z_j\)</span> by evaluating the fitted mean of the GLM <span class="math inline">\(\hat{\mu}_j = \sigma(\hat{\delta}^T Z_j)\)</span>, where <span class="math inline">\(\sigma\)</span> is the logistic function: <span class="math display">\[ \sigma(\eta) = \frac{1}{1 + e^{-\eta}}.\]</span> Finally, for each <span class="math inline">\(k \in \{1, \dots, B\}\)</span>, we sample the null treatment vector <span class="math inline">\(\tilde{X}_k\)</span> from the distribution <span class="math display">\[\left[ \textrm{Bern}(\hat{\mu}_1), \textrm{Bern}(\hat{\mu}_2), \dots, \textrm{Bern}(\hat{\mu}_n)\right]^T,\]</span> yielding null treatment vectors <span class="math inline">\(\tilde{X}_1, \dots, \tilde{X}_B\)</span>. The permutation and conditional resampling strategies pose distinct advantages and disadvantages; see <a href="set-analysis-parameters.html#sec-set_analysis_parameters_resampling_mech" class="quarto-xref"><span>Section 2.7</span></a> for a discussion.</p>
</section>
<section id="computing-the-test-statistics" class="level3" data-number="10.3.2">
<h3 data-number="10.3.2" class="anchored" data-anchor-id="computing-the-test-statistics"><span class="header-section-number">10.3.2</span> Computing the test statistics</h3>
<p>The second step is to evaluate a test statistic on the original treatment vector <span class="math inline">\(X\)</span> and the resampled treatment vectors <span class="math inline">\(\tilde{X}_1, \dots, \tilde{X}_B\)</span>, enabling us to compare the original treatment vector to the resampled treatment vectors (via their test statistics). The test statistic that we use for this purpose is based on a negative binomial GLM. We propose the following working model for the response UMI count <span class="math inline">\(Y_j\)</span> as a function of the cell-specific covariates <span class="math inline">\(Z_j\)</span>: <span id="eq-nb_glm"><span class="math display">\[ Y_j \sim \textrm{NB}_{\theta}(\mu_j); \quad \log(\mu_j) = \tau^T Z_j. \tag{10.11}\]</span></span> Here, <span class="math inline">\(\theta\)</span> is the (unknown) negative binomial size parameter, and <span class="math inline">\(\tau^T \in \mathbb{R}^d\)</span> is an (unknown) regression coefficient. The probability mass function <span class="math inline">\(f_\theta(y_j; \mu_j)\)</span> of the negative binomial distribution with mean <span class="math inline">\(\mu_j\)</span> and size parameter <span class="math inline">\(\theta\)</span> evaluated at <span class="math inline">\(y_j\)</span> is as follows: <span class="math display">\[ f_\theta(y_j; \mu_j) = \binom{y_j + \theta - 1}{y_j} \left(\frac{\mu_j}{\mu_j+\theta} \right)^{y_j} \left(\frac{\theta}{\mu_j + \theta}\right)^\theta.\]</span></p>
<p>This is the parameterization of the negative binomial distribution in which the variance <span class="math inline">\(\mathbb{V}(Y_i | \mu_i)\)</span> of <span class="math inline">\(Y_i\)</span> given mean <span class="math inline">\(\mu_i\)</span> is <span class="math display">\[\mathbb{V}(Y_i | \mu_i) = \mu_i + \mu_i^2 / \theta.\]</span> The model (<a href="#eq-nb_glm" class="quarto-xref">Equation&nbsp;<span>10.11</span></a>) corresponds to the null hypothesis of no association between the response <span class="math inline">\(Y\)</span> and the treatment <span class="math inline">\(X\)</span>.</p>
<p>We regress <span class="math inline">\(Y\)</span> onto <span class="math inline">\(Z\)</span> via a negative binomial GLM, yielding estimates <span class="math inline">\(\hat{\tau}^T\)</span> and <span class="math inline">\(\hat{\theta}\)</span> for <span class="math inline">\(\tau\)</span> and <span class="math inline">\(\theta\)</span>, respectively.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> Next, we test the original treatment vector <span class="math inline">\(X\)</span> and resampled treatment vectors <span class="math inline">\(\tilde{X}_1, \dots, \tilde{X}_B\)</span> for inclusion in the fitted GLM by computing a GLM score test on each of these vectors. The GLM score test statistic <span class="math inline">\(T_\textrm{orig}\)</span> for the original treatment vector <span class="math inline">\(X\)</span> is given by <span id="eq-score_stat_formula"><span class="math display">\[
T_\textrm{orig} = \frac{X^T W M (Y - \hat{\mu})}{\sqrt{X^T W X - X^T W Z (Z^T W Z)^{-1} Z^T W X}},
\tag{10.12}\]</span></span></p>
<p>where <span class="math inline">\(W\)</span> and <span class="math inline">\(M(Y - \hat{\mu})\)</span> are a matrix and vector, respectively, that depend on the fitted means <span class="math inline">\(\hat{\mu}\)</span>, response expression vector <span class="math inline">\(Y\)</span>, and estimated size parameter <span class="math inline">\(\hat{\theta}\)</span>:</p>
<p><span class="math display">\[
\begin{split}
\hat{\mu} = \left[\exp(\hat{\tau}^T z_1), \dots, \exp(\hat{\tau}^T z_n)\right]^T; \\
W = \textrm{diag}\left\{\frac{\hat{\mu}_1}{1 + \hat{\mu}_1/\hat{\theta}}, \dots, \frac{\hat{\mu}_n}{1 + \hat{\mu}_n/\hat{\theta}} \right\}; \\ M(Y - \hat{\mu}) = \left[\frac{Y_1}{\hat{\mu}_1} - 1, \dots, \frac{Y_n}{\hat{\mu}_n} - 1\right]^T.
\end{split}
\]</span></p>
<p>We compute the score test statistic <span class="math inline">\(T_k\)</span> corresponding to the <span class="math inline">\(k\)</span>th resampled treatment vector for <span class="math inline">\(k \in \{1, \dots, B\}\)</span> by replacing <span class="math inline">\(X\)</span> with <span class="math inline">\(\tilde{X}_k\)</span> in (<a href="#eq-score_stat_formula" class="quarto-xref">Equation&nbsp;<span>10.12</span></a>).</p>
<p>Note that the score test statistic is asymptotically equivalent to a Wald statistic. In other words, we instead could compute the test statistic regressing <span class="math inline">\(Y\)</span> onto the matrix <span class="math inline">\([X, Z]\)</span> and testing the hypothesis that the coefficient corresponding to <span class="math inline">\(X\)</span> is equal to zero via a Wald test. This latter approach is asymptotically equivalent to the score statistic approach outlined above but is much less computationally efficient.</p>
</section>
<section id="computing-the-p-value" class="level3" data-number="10.3.3">
<h3 data-number="10.3.3" class="anchored" data-anchor-id="computing-the-p-value"><span class="header-section-number">10.3.3</span> Computing the p-value</h3>
<p>The third and final step is to compute a p-value. The standard negative binomial GLM p-value <span class="math inline">\(p_\textrm{NB}\)</span> is obtained by evaluating the tail probability of a standard Gaussian distribution at <span class="math inline">\(T_\textrm{orig}\)</span>. For example, the left-tailed negative binomial p-value is given by <span class="math inline">\(p_\textrm{NB} = F(T_\textrm{orig}),\)</span> where <span class="math inline">\(F\)</span> is the standard Gaussian distribution. We instead propose to compute the p-value by comparing the original test statistic <span class="math inline">\(T_\textrm{orig}\)</span> to the null test statistics <span class="math inline">\(T_1, \dots, T_B\)</span>; this latter approach is more robust. The “exact” left-, right-, and two-tailed permutation test p-values (which also are valid for a conditional randomization test) are given below.</p>
<p><span class="math display">\[
\begin{split}
p_\textrm{left} = \frac{1}{B+1}\left(1 + \sum_{i=1}^B \mathbb{I}(T_\textrm{orig} \geq T_i)\right), \\
p_\textrm{right} = \frac{1}{B+1} \left(1 + \sum_{i=1}^B \mathbb{I}(T_\textrm{orig} \leq T_i)\right), \\
p_\textrm{both} = 2 \cdot \textrm{min}\left\{ p_\textrm{left}, p_\textrm{right} \right\}.
\end{split}
\]</span> <code>sceptre</code> returns the exact permutation test p-value when <code>resampling_approximation</code> is set to <code>"no_approximation"</code> in <code>set_analysis_parameters()</code>.</p>
<p>Unfortunately, computing an exact permutation test p-value can be slow, especially when the number of hypotheses to be tested is large. Thus, <code>sceptre</code> provides the option of approximating the null distribution of the test statistics via a skew-normal distribution. A skew-normal distribution is a bell-shaped distribution that generalizes a Gaussian distribution by allowing for skew (i.e., asymmetry) about the mode of the distribution. A skew-normal distribution has three paramters: <span class="math inline">\(\mu\)</span> (the mean), <span class="math inline">\(\sigma\)</span> (the standard deviation), and <span class="math inline">\(\alpha\)</span> (the skew; setting <span class="math inline">\(\alpha = 0\)</span> recovers a Gaussian distribution with parameters <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\sigma\)</span>). One can activate the skew-normal functionality of <code>sceptre</code> by setting <code>resampling_approximation</code> to <code>"skew_normal"</code> in <code>set_analysis_parameters()</code>. In this case <code>sceptre</code> fits a skew-normal distribution to the null test statistics <span class="math inline">\(T_1, \dots, T_B\)</span> via a method of moments estimator, yielding estimates <span class="math inline">\(\hat{\mu}, \hat{\sigma}\)</span> and <span class="math inline">\(\hat{\alpha}\)</span> for <span class="math inline">\(\mu\)</span>, <span class="math inline">\(\sigma\)</span>, and <span class="math inline">\(\alpha\)</span>, respectively. Next, <code>sceptre</code> computes the p-value by evaluating the tail probability of the fitted skew-normal distribution at the original test statistic <span class="math inline">\(z_\textrm{orig}\)</span>. In particular, letting <span class="math inline">\(f_{\hat{\mu}, \hat{\sigma}, \hat{\alpha}}\)</span> denote the probability density function of the skew-normal distribution with parameters <span class="math inline">\(\hat{\mu}, \hat{\sigma}\)</span>, and <span class="math inline">\(\hat{\alpha}\)</span>, the left-, right-, and two-tailed p-values are given as follows.</p>
<p><span class="math display">\[
\begin{split}
p_\textrm{left} = \int_{-\infty}^{T_\textrm{orig}} f_{\hat{\mu}, \hat{\sigma}, \hat{\alpha}}(x) dx, \\
p_\textrm{right} = \int_{T_\textrm{orig}}^{\infty} f_{\hat{\mu}, \hat{\sigma}, \hat{\alpha}}(x) dx,  \\
p_\textrm{both} = 2 \cdot \textrm{min}\left\{ p_\textrm{right}, p_\textrm{left} \right\}.
\end{split}
\]</span></p>
</section>
</section>
<section id="estimating-the-log-fold-change" class="level2" data-number="10.4">
<h2 data-number="10.4" class="anchored" data-anchor-id="estimating-the-log-fold-change"><span class="header-section-number">10.4</span> Estimating the log-fold change</h2>
<p><code>sceptre</code> employs a simple and fast strategy for to estimate the log-fold change. Recall that, before computing the test statistics <span class="math inline">\(T_\textrm{orig}, T_1, \dots, T_B\)</span>, we fit the negative binomial GLM (<a href="#eq-nb_glm" class="quarto-xref">Equation&nbsp;<span>10.11</span></a>), yielding parameter estimates <span class="math inline">\(\hat{\tau}\)</span> and <span class="math inline">\(\hat{\theta}\)</span> for <span class="math inline">\(\tau\)</span> and <span class="math inline">\(\theta\)</span>, respectively. To estimate the log-fold change, we posit the simplified model <span id="eq-simplified_nb_model"><span class="math display">\[Y_j \sim \textrm{NB}_{\theta}(\mu_j); \quad \log(\mu_j) = \xi X_j + o_j, \tag{10.13}\]</span></span> where <span class="math inline">\(o_j = \hat{\tau}^T Z_j\)</span> is the <span class="math inline">\(j\)</span>th fitted value of the negative binomial GLM (<a href="#eq-nb_glm" class="quarto-xref">Equation&nbsp;<span>10.11</span></a>). (This simplification is analogous to the simplification employed in the context of fitting the gRNA mixture model; <a href="#sec-mixture_method" class="quarto-xref"><span>Section 10.1.3</span></a>.) Estimating the log fold change reduces to estimating <span class="math inline">\(\xi\)</span>. We treat the terms <span class="math inline">\(o_1, \dots, o_n\)</span> as i.i.d. draws from some distribution <span class="math inline">\(P\)</span>; this approximation is reasoanble for large <span class="math inline">\(n\)</span>. The log-likelihood of the model (<a href="#eq-simplified_nb_model" class="quarto-xref">Equation&nbsp;<span>10.13</span></a>) is</p>
<p><span class="math display">\[
\begin{multline*}
L(\xi) = \sum_{j : x_j = 0 }^n \log\left[f_\theta(y_j; \exp[o_j])\right] + \sum_{j : x_j = 1 }^n \log\left[f_\theta(y_j; \exp[\xi + o_j])\right] \\ = C + \sum_{j : x_j = 1 }^n \log\left[f_\theta(y_j; \exp[\xi + o_j])\right],
\end{multline*}
\]</span></p>
<p>where <span class="math inline">\(C\)</span> is a constant in the unknown parameter <span class="math inline">\(\xi\)</span>. Observe that, among the set of observations <span class="math inline">\(\{(Y_1, X_1), \dots, (Y_n, X_n)\}\)</span>, we can ignore the observations for which <span class="math inline">\(X_i = 0\)</span>, as these observations do not contribute to the log likelihood. Relabel the observations for which <span class="math inline">\(X_i = 1\)</span> as <span class="math inline">\(\{(Y_1, X_1), \dots, (Y_s, X_s)\}\)</span>, where <span class="math inline">\(s = \sum_{i=1}^n X_i\)</span> is the number of observations for which <span class="math inline">\(X_i = 1\)</span>. Using this notation, the log-likelihood of (<a href="#eq-simplified_nb_model" class="quarto-xref">Equation&nbsp;<span>10.13</span></a>) can be expressed as</p>
<p><span class="math display">\[
\begin{multline*}
L(\xi) = \xi \sum_{j=1}^s y_j - \sum_{j=1}^s y_j \log(\theta + \exp[\xi + o_j]) - \theta \sum_{j=1}^s \log(\theta + \exp[\xi + o_j]) \\ = \xi \sum_{j=1}^s y_j - \sum_{j=1}^s (y_j + \theta) \log(\theta + \exp[\xi + o_j]).
\end{multline*}
\]</span></p>
<p>Differentiating the above in <span class="math inline">\(\xi\)</span> and setting to zero yields the MLE equation: <span class="math display">\[ L'(\xi) = \exp(\xi) \sum_{j=1}^s \frac{(y_j + \theta) \exp(o_j)}{\theta + \exp(\xi + o_j)} = \sum_{j=1}^s y_j,\]</span></p>
<p>or</p>
<p><span id="eq-mle_eqn"><span class="math display">\[
\xi = \log\left\{\frac{(1/n)\sum_{j=1}^s y_j }{(1/n)\sum_{j=1}^s (y_j + \theta)\exp(o_j)/[\theta + \exp(\xi + o_j)]}\right\}.
\tag{10.14}\]</span></span></p>
<p>The unknown parameter <span class="math inline">\(\xi\)</span> appears on both sides of (<a href="#eq-mle_eqn" class="quarto-xref">Equation&nbsp;<span>10.14</span></a>). Thus, we cannot solve for the MLE analytically. However, we can derive an approximate solution for the MLE. Notice that both numerator and denominator of (<a href="#eq-mle_eqn" class="quarto-xref">Equation&nbsp;<span>10.14</span></a>) are the mean of i.i.d. random variables. The expectation of the numerator is <span class="math inline">\(\mathbb{E}[Y_j]\)</span>, and that of the denominator is <span class="math inline">\(\mathbb{E}[\exp(o_j)].\)</span> Thus, by the law of large numbers and the continuous mapping theorem, the MLE <span class="math inline">\(\hat{\xi}\)</span> for <span class="math inline">\(\xi\)</span> converges in probability to <span class="math display">\[\hat{\xi} \xrightarrow{P} \log\left(\frac{\mathbb{E}[Y_j]}{\mathbb{E}[\exp(o_j)]}\right).\]</span> However, the following quantity converges in probability to the same limit: <span id="eq-approximate_mle"><span class="math display">\[\log\left(\frac{(1/n) \sum_{j=1}^s Y_j }{ (1/n) \sum_{j=1}^s \exp[o_j] }\right) \xrightarrow{P} \log\left(\frac{\mathbb{E}[Y_j]}{\mathbb{E}[\exp(o_j)]}\right). \tag{10.15}\]</span></span></p>
<p>Thus, we can approximate the MLE <span class="math inline">\(\hat{\xi}\)</span> with the right-hand side of (<a href="#eq-approximate_mle" class="quarto-xref">Equation&nbsp;<span>10.15</span></a>):</p>
<p><span class="math display">\[
\hat{\xi} \approx \log\left(\frac{\sum_{j=1}^s Y_j }{\sum_{j=1}^s \exp[o_j] }\right).
\]</span></p>
<p>This is the simple estimator that <code>sceptre</code> uses for the log fold change. An advantage to this estimator is that it is quite fast to compute using the fitted GLM (<a href="#eq-nb_glm" class="quarto-xref">Equation&nbsp;<span>10.11</span></a>). Interestingly, this estimator circumvents estimation of the size parameter <span class="math inline">\(\theta\)</span>.</p>
</section>
<section id="integrating-information-across-grnas" class="level2" data-number="10.5">
<h2 data-number="10.5" class="anchored" data-anchor-id="integrating-information-across-grnas"><span class="header-section-number">10.5</span> Integrating information across gRNAs</h2>
<p><code>sceptre</code> provides three strategies for integrating information across gRNAs that target the same site: <code>"singleton"</code>, <code>"union"</code>, <code>"bonferroni"</code>. (One can select between these strategies by specifying the <code>grna_integration_strategy</code> argument in the <code>set_analysis_parameters()</code> function.) The “singleton” and “union” strategies are straightforward; see <a href="set-analysis-parameters.html#sec-grna_integration_strategy" class="quarto-xref"><span>Section 2.4</span></a> and <a href="#sec-defn_trt_cntrl_grp" class="quarto-xref"><span>Section 10.2</span></a> for more information. The Bonferroni strategy is slightly more complicated. Consider a given target-response pair. Suppose that <span class="math inline">\(k\)</span> gRNAs <span class="math inline">\(\textrm{gRNA}_1 \dots \textrm{gRNA}_k\)</span> target this target. Moreover, suppose that, upon testing for association between each of these gRNAs and the response, we obtain gRNA-wise p-values <span class="math inline">\(p_1, \dots, p_k\)</span>. The Bonferroni p-value is defined as follows:</p>
<p><span class="math display">\[ p = k \cdot \min\{p_1, \dots, p_k\}.\]</span> The Bonferroni p-value is valid in the following sense: if <span class="math inline">\(p_1, \dots, p_k\)</span> are valid (i.e., uniformly distributed) p-values, then <span class="math inline">\(p\)</span> too is a valid (i.e., uniformly distributed) p-value. (The gRNA-wise p-values <span class="math inline">\(p_1, \dots, p_k\)</span> can be arbitrarily dependent.) Below, we state this result in a slightly more precise way and prove its correctness. “Superuniformity” is more general than uniformity and is sufficient for p-value validity. This proof is standard; see, e.g., the Bonferroni correction <a href="https://en.wikipedia.org/wiki/Bonferroni_correction">Wikipedia page</a>.</p>
<p><strong>Theorem</strong>: Suppose that <span class="math inline">\(p_1, \dots, p_k\)</span> are superuniform, i.e.&nbsp;<span class="math inline">\(\mathbb{P}(p_i \leq \alpha) \leq \alpha\)</span> for all <span class="math inline">\(i \in \{1, \dots, k\}\)</span> and all <span class="math inline">\(\alpha \in [0,1]\)</span>. Then <span class="math inline">\(p = k \cdot \min\{p_1, \dots, p_k\}\)</span> also is superuniform.</p>
<p><strong>Proof</strong>:</p>
<p><span class="math display">\[
\begin{multline}
\mathbb{P}( k \cdot \min\{p_1, \dots, p_k\} \leq \alpha) = \mathbb{P}( \min\{p_1, \dots, p_k\} \leq \alpha/k )\\ = \mathbb{P}\left( p_1 \leq \alpha/k \textrm{ or } \dots \textrm{ or } p_k \leq \alpha /k  \right) \leq \sum_{i=1}^k \mathbb{P}(p_i \leq \alpha/k) \leq \sum_{i=1}^k \alpha/k = \alpha.
\end{multline}
\]</span></p>
<p>The penultimate inequality follows from the union bound, while the final inequality follows from the superuniformity of <span class="math inline">\(p_i\)</span>. <span class="math inline">\(\square\)</span></p>
</section>
<section id="accelerations" class="level2" data-number="10.6">
<h2 data-number="10.6" class="anchored" data-anchor-id="accelerations"><span class="header-section-number">10.6</span> Accelerations</h2>
<p><code>sceptre</code> leverages several statistical and algorithmic accelerations to considerably improve the speed of the methods described above, including a sparsity-exploiting algorithm for computing GLM score tests and a strategy for recycling computation across permutation tests. We plan to describe these accelerations in a subsequent chapter.</p>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-barry2022c" class="csl-entry" role="listitem">
Barry, Timothy, Kathryn Roeder, and Eugene Katsevich. 2024. <span>“<span class="nocase">Exponential family measurement error models for single-cell CRISPR screens</span>.”</span> <em>Biostatistics</em>.
</div>
<div id="ref-gasperini2019" class="csl-entry" role="listitem">
Gasperini, Molly, Andrew J. Hill, José L. McFaline-Figueroa, Beth Martin, Seungsoo Kim, Melissa D. Zhang, Dana Jackson, et al. 2019. <span>“<span class="nocase">A Genome-wide Framework for Mapping Gene Regulation via Cellular Genetic Screens</span>.”</span> <em>Cell</em> 176 (1): 377–90.
</div>
</div>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>We fit the negative binomial GLM by fitting a Poisson GLM to the data, taking as the negative binomial GLM coefficients the Poisson GLM coefficients, and then estimating the negative binomial size parameter using the residuals of the fitted Poisson GLM. This procedure is faster than standard procedures for fitting a negative binomial GLM. A more detailed description of this procedure will appear in a subsequent chapter.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./pipeline-args.html" class="pagination-link  aria-label=" &lt;span="" installation,="" pipeline="" arguments&lt;="" span&gt;"="">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Nextflow installation, pipeline arguments</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./ondisc.html" class="pagination-link" aria-label="<span class='chapter-number'>A</span>&nbsp; <span class='chapter-title'>The `ondisc` package</span>">
        <span class="nav-page-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">The <code>ondisc</code> package</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Hands-On Single-Cell CRISPR Screen Analysis</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>This book was built with <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>




</body></html>